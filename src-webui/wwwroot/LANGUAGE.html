<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>LANGUAGE</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">:root { --bg:#0d1117; --panel:#161b22; --border:#30363d; --fg:#c9d1d9; --fg-soft:#a5b1bd; --accent:#58a6ff; --radius:8px; }html { scroll-behavior:smooth; }body { font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; margin:0 auto; max-width:980px; padding:2.2rem 1.6rem 4rem; line-height:1.55; background:var(--bg); color:var(--fg); }h1,h2,h3,h4,h5 { line-height:1.15; font-weight:600; }h1 { font-size:2.25rem; margin-top:0; }h2 { margin-top:2.4rem; padding-top:.4rem; border-top:1px solid var(--border); font-size:1.6rem; }h3 { margin-top:1.8rem; font-size:1.25rem; }p { margin:1rem 0; }pre,code { font-family: ui-monospace,Consolas,"Cascadia Code",monospace; font-size:.85rem; }pre { background:var(--panel); padding:1rem 1.1rem; border:1px solid var(--border); border-radius:var(--radius); overflow:auto; position:relative; }code { background:var(--panel); padding:.15rem .4rem; border:1px solid var(--border); border-radius:5px; }pre code { background:transparent; padding:0; border:none; }table { border-collapse:collapse; width:100%; margin:1.25rem 0; }th,td { border:1px solid var(--border); padding:.55rem .7rem; text-align:left; vertical-align:top; }tr:nth-child(even) { background:#1b2230; }a { color:var(--accent); text-decoration:none; }a:hover { text-decoration:underline; }blockquote { margin:1.2rem 0; padding:.75rem 1rem; background:#132032; border-left:4px solid var(--accent); border-radius:4px; color:#fff; }hr { border:none; border-top:1px solid var(--border); margin:3rem 0 2.2rem; }nav#toc { background:var(--panel); border:1px solid var(--border); padding:1rem 1.25rem 1.1rem; border-radius:var(--radius); font-size:.85rem; line-height:1.35; }nav#toc strong { display:block; font-size:.75rem; letter-spacing:.08em; font-weight:700; text-transform:uppercase; margin-bottom:.35rem; opacity:.85; }nav#toc ul { list-style:none; margin:0; padding-left:0; }nav#toc ul ul { margin-left:1rem; }nav#toc a { text-decoration:none; }nav#toc a:hover { text-decoration:underline; }.title-block { margin-bottom:1.5rem; }.title-block h1 { margin-bottom:.25rem; }.meta { color:var(--fg-soft); font-size:.85rem; }.footnotes { font-size:.85rem; opacity:.92; }.highlight table { border:none; }.highlight td { border:none; padding:0; }.highlight pre { margin:0; }@media (max-width:760px){ body{padding:1.4rem .95rem 3rem;} h1{font-size:1.9rem;} }</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">LANGUAGE</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#language-reference" id="toc-language-reference">Language
Reference</a>
<ul>
<li><a href="#overview--philosophy" id="toc-overview--philosophy">Overview &amp; Philosophy</a></li>
<li><a href="#core-constructs--syntax-cheatsheet" id="toc-core-constructs--syntax-cheatsheet">Core Constructs &amp; Syntax
Cheatsheet</a></li>
<li><a href="#command--expression-chaining-language-feature" id="toc-command--expression-chaining-language-feature">Command /
Expression Chaining (Language Feature)</a></li>
<li><a href="#placeholders--multiparameter-forms" id="toc-placeholders--multiparameter-forms">Placeholders &amp;
Multi‑parameter Forms</a></li>
<li><a href="#lists--ranges" id="toc-lists--ranges">Lists &amp;
Ranges</a></li>
<li><a href="#church-encodings-used-by-pretty-printer" id="toc-church-encodings-used-by-pretty-printer">Church Encodings (Used
by Pretty Printer)</a></li>
<li><a href="#infix-operators" id="toc-infix-operators">Infix
Operators</a></li>
<li><a href="#builtin-special-operators" id="toc-builtin-special-operators">Built‑in Special Operators</a></li>
<li><a href="#operator-precedence--associativity" id="toc-operator-precedence--associativity">Operator Precedence &amp;
Associativity</a></li>
<li><a href="#formal-grammar-condensed" id="toc-formal-grammar-condensed">Formal Grammar (Condensed)</a></li>
<li><a href="#macro-system" id="toc-macro-system">Macro System</a></li>
<li><a href="#pretty-printing-rules" id="toc-pretty-printing-rules">Pretty Printing Rules</a></li>
<li><a href="#structural-equivalence-helpers-always-on" id="toc-structural-equivalence-helpers-always-on">Structural Equivalence
Helpers (Always On)</a></li>
<li><a href="#selected-extended-examples" id="toc-selected-extended-examples">Selected Extended Examples</a></li>
<li><a href="#see-also" id="toc-see-also">See Also</a></li>
</ul></li>
</ul>
</nav>
<section id="language-reference" class="level1">
<h1>Language Reference</h1>
<p>This document describes the surface language, syntax constructs,
macro system and core semantic sugar of the Lambda Calculus Interpreter.
It is extracted from the original monolithic README for easier
navigation.</p>
<p>Sections</p>
<ul>
<li>Overview &amp; Philosophy</li>
<li>Core Constructs &amp; Syntax Cheatsheet</li>
<li>Examples (Essentials)</li>
<li>Command / Expression Chaining (Language Feature)</li>
<li>Placeholders &amp; Multi‑parameter Forms</li>
<li>Lists &amp; Ranges</li>
<li>Church Encodings (Integers, Booleans, Pairs, Maybe, Either – forms
used by pretty printer)</li>
<li>Infix Operators (Definition &amp; Precedence)</li>
<li>Built‑in Special Operators (|&gt;, ∘, ., $)</li>
<li>Operator Precedence &amp; Associativity Ladder</li>
<li>Formal Grammar (EBNF‑style)</li>
<li>Macro System (Basic → Advanced Enhancements)</li>
<li>Pretty Printing Rules (Output Representation)</li>
</ul>
<hr />
<section id="overview--philosophy" class="level3">
<h3>Overview &amp; Philosophy</h3>
<p>The interpreter is a CEK‑machine based lambda calculus environment
with pragmatic extensions:</p>
<ul>
<li>Pure lambda calculus core (variables, abstraction,
application).</li>
<li>Church encodings for numerals, booleans, lists, pairs, optionals,
either.</li>
<li>Syntax sugar to reduce ceremony (multi‑parameter arrows,
<code>let</code>, <code>def</code>, list literals, ranges, pipelines,
application chaining, composition, low‑precedence application).</li>
<li>A pattern‑driven macro system (multi‑clause, guards, variadic/rest,
structural patterns, wildcards, integer literal patterns, precedence
heuristics).</li>
<li>User‑declared infix operators via Pratt parser with dynamic
precedence table.</li>
</ul>
<p>Design goals: expressiveness, readability, hackable experimentation,
performance transparency.</p>
<hr />
</section>
<section id="core-constructs--syntax-cheatsheet" class="level3">
<h3>Core Constructs &amp; Syntax Cheatsheet</h3>
<pre class="lambda"><code>λx.x            # Lambda (Alt: \x.x or x -&gt; x)
λx y.x          # Multi-parameter (desugars to λx.λy.x)
x, y, z -&gt; e    # Arrow multi-parameter equivalently nested
def inc x = x+1 # def sugar: inc = x -&gt; x + 1
let id = x-&gt;x in id 42          # (λid.id 42) (λx.x)
let x = 3, y = 4 in x * y       # Multi let → nested lets / lambdas
let rec f = n -&gt; ... in f 5     # Recursion via Y combinator desugaring

_ -&gt; 42         # Placeholder (ignored parameter)
(x, _, _) -&gt; x  # Multiple placeholders become fresh uniques
swap = (_, _) -&gt; _ _  # Uses generated vars positionally

[1,2,3]         # cons 1 (cons 2 (cons 3 nil))
[1 .. 5]        # Inclusive literal range
[1,3 .. 11]     # Stepped literal range (step=2)
[f a .. g b]    # Non-literal → (range (f a) (g b)) lazily
[a, a+2 .. b]   # Non-literal stepped → (range2 a (a+2) b)

5 |&gt; succ |&gt; mult 2   # Pipeline (g (f 5))
f . x . y              # Application chaining: (f x) y
f ∘ g                  # Composition λx.f (g x)
f $ x $ y              # Low precedence application

3 + 4 * 5       # Infix (precedence driven)</code></pre>
<p>Church numerals: <code>0 1 2 42</code> recognized &amp; pretty
printed; negative literals <code>-3</code> parsed atomically.</p>
<hr />
</section>
<section id="command--expression-chaining-language-feature" class="level3">
<h3>Command / Expression Chaining (Language Feature)</h3>
<p>Top‑level semicolons separate segments (commands or expressions)
processed left→right. Only the final expression result is printed.</p>
<pre class="shell"><code>:macro (sq $x) =&gt; (mult $x $x); sq 7   # Define then use ⇒ 49
:load stdlib.lambda; plus 2 3          # Chain load + eval ⇒ 5
let x = 10 in succ x; succ 5           # Final result ⇒ 6</code></pre>
<p>Rules:</p>
<ul>
<li>Semicolons only at REPL/file root (not inside parentheses, lists,
lambdas, lets, macros).</li>
<li>Empty segments ignored; errors abort remaining segments.</li>
<li><code>:exit</code> / <code>:quit</code> stop further segments.</li>
</ul>
<hr />
</section>
<section id="placeholders--multiparameter-forms" class="level3">
<h3>Placeholders &amp; Multi‑parameter Forms</h3>
<p><code>_</code> in parameter lists creates a fresh unique variable
(ignored unless referenced). Multiple underscores map positionally in
the body when used.</p>
<pre class="lambda"><code>first = (x, _, _) -&gt; x
swap  = (_, _) -&gt; _ _      # (λa.λb.b a)
map (_ -&gt; 0) [1,2,3]       # Zero out list
addBoth = _ + _ -&gt; mult _ _  # (x,y) -&gt; mult (x + y) (x + y)</code></pre>
<p>Underscores improve clarity where some parameters are intentionally
dropped.</p>
<hr />
</section>
<section id="lists--ranges" class="level3">
<h3>Lists &amp; Ranges</h3>
<p>Literal lists desugar to nested <code>cons</code>/<code>nil</code>
chains. Ranges:</p>
<table>
<thead>
<tr>
<th>Form</th>
<th>Expansion</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[a .. b]</code> (all integer literals)</td>
<td>Eager expanded list</td>
</tr>
<tr>
<td><code>[a, b .. c]</code> literals</td>
<td>Eager stepped list (step = b-a)</td>
</tr>
<tr>
<td>Non‑literal endpoints</td>
<td><code>(range a b)</code> lazy</td>
</tr>
<tr>
<td>Non‑literal stepped</td>
<td><code>(range2 a b c)</code> lazy</td>
</tr>
</tbody>
</table>
<p>Descending &amp; negative endpoints supported. Zero step yields
singleton.</p>
<hr />
</section>
<section id="church-encodings-used-by-pretty-printer" class="level3">
<h3>Church Encodings (Used by Pretty Printer)</h3>
<ul>
<li>Numerals: <code>λf.λx.f^n x</code></li>
<li>Booleans: <code>true = λa.λb.a</code>,
<code>false = λa.λb.b</code></li>
<li>Lists (fold right): <code>λf.λz.f a1 (f a2 (... z))</code></li>
<li>Pairs: <code>pair a b = λf.f a b</code></li>
<li>Maybe: <code>just x</code>, <code>nothing</code></li>
<li>Either: <code>left x</code>, <code>right y</code></li>
</ul>
<p>Pretty printer detects canonical shapes and renders concise forms;
disable via <code>:pretty off</code> to inspect raw lambdas.</p>
<hr />
</section>
<section id="infix-operators" class="level3">
<h3>Infix Operators</h3>
<p>Declare:
<code>:infix &lt;symbol&gt; &lt;precedence&gt; &lt;left|right&gt;</code>
then bind the symbol with a definition.</p>
<p>Example:</p>
<pre class="lambda"><code>:infix + 6 left
:infix * 7 left
:infix ^ 8 right
plus = λa b. ...
mult = λa b. ...
exp  = λa b. ...
1 + 2 * 3      # precedence ⇒ 1 + (2 * 3)
2 ^ 3 ^ 2      # right associative ⇒ 2 ^ (3 ^ 2)</code></pre>
<p>Built‑ins always present: <code>|&gt;</code>, <code>∘</code>,
<code>.</code>, <code>$</code> (their semantics shouldn’t be
overridden).</p>
<hr />
</section>
<section id="builtin-special-operators" class="level3">
<h3>Built‑in Special Operators</h3>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
<th>Desugaring</th>
</tr>
</thead>
<tbody>
<tr>
<td>`a</td>
<td>&gt; f`</td>
<td>Pipeline (left→right data)</td>
</tr>
<tr>
<td><code>f . x</code></td>
<td>Application chaining</td>
<td><code>(f x)</code> (chains right‑assoc)</td>
</tr>
<tr>
<td><code>f ∘ g</code></td>
<td>Function composition</td>
<td><code>λx.f (g x)</code></td>
</tr>
<tr>
<td><code>f $ x</code></td>
<td>Low precedence application</td>
<td><code>f x</code> (right‑assoc; removes parentheses)</td>
</tr>
</tbody>
</table>
<p>Usage examples:</p>
<pre class="lambda"><code>5 |&gt; succ |&gt; mult 2
f . g . 5          # f (g 5)
(f ∘ g) x          # f (g x)
mult 2 $ succ 5</code></pre>
<hr />
</section>
<section id="operator-precedence--associativity" class="level3">
<h3>Operator Precedence &amp; Associativity</h3>
<p>Loosest → tightest (conceptual ladder):</p>
<ol type="1">
<li>Top‑level <code>;</code> (segment separator)</li>
<li><code>let … in …</code> (right‑assoc)</li>
<li>Arrow <code>p1, p2 -&gt; body</code> (right‑assoc)</li>
<li>Infix operators (numeric precedence: higher = tighter)</li>
<li>Special operators tier (pipeline / low‑prec / chaining / composition
as declared) – note <code>|&gt;</code> &amp; <code>$</code> low;
<code>.</code> &amp; <code>∘</code> high</li>
<li>Juxtaposition (application) – left‑assoc, tighter than any
infix</li>
<li>Atom (parenthesized expr, literal, identifier, lambda, list)</li>
</ol>
<p>Guidelines:</p>
<ul>
<li>Application binds tighter than any infix. <code>f x + g y</code> ⇒
<code>plus (f x) (g y)</code>.</li>
<li><code>$</code> and <code>|&gt;</code> share lowest precedence but
opposite associativity.</li>
<li>Parentheses trump precedence; add them when mixing special
operators.</li>
</ul>
<hr />
</section>
<section id="formal-grammar-condensed" class="level3">
<h3>Formal Grammar (Condensed)</h3>
<p>EBNF‑style (simplified from full README; Pratt handles infix
dynamically):</p>
<pre><code>Program      ::= Segment (&#39;;&#39; Segment)*
Segment      ::= (Command | Definition | Expression)?
Definition   ::= Identifier &#39;=&#39; Expression
Expression   ::= LetExpr | ArrowExpr | InfixExpr
LetExpr      ::= &#39;let&#39; (&#39;rec&#39;)? LetBinding (&#39;,&#39; LetBinding)* &#39;in&#39; Expression
LetBinding   ::= Identifier &#39;=&#39; Expression | Identifier ParamList &#39;-&gt;&#39; Expression
ArrowExpr    ::= ParamList &#39;-&gt;&#39; Expression
ParamList    ::= Param (&#39;,&#39; Param)* | &#39;(&#39; Param (&#39;,&#39; Param)* &#39;)&#39;
Param        ::= Identifier | &#39;_&#39;
InfixExpr    ::= Application (InfixOp Application)*
Application  ::= Atom+
Atom         ::= Integer | Identifier | Lambda | List | &#39;(&#39; Expression &#39;)&#39;
Lambda       ::= (&#39;λ&#39; | &#39;\\&#39;) Param+ &#39;.&#39; Expression
List         ::= &#39;[&#39; ListBody? &#39;]&#39;
ListBody     ::= Elements | RangeSpec | SteppedRange
RangeSpec    ::= Expression &#39;..&#39; Expression
SteppedRange ::= Expression &#39;,&#39; Expression &#39;..&#39; Expression</code></pre>
<p>Desugarings (informal):</p>
<pre><code>let x = A in B           ≡ (λx.B) A
let x = A, y = B in C    ≡ (λx.λy.C) A B
let rec f = E in B       ≡ (λf.B) (Y (λf.E))
x, y -&gt; R                ≡ x -&gt; (y -&gt; R)
[a,b,c]                  ≡ cons a (cons b (cons c nil))
a |&gt; f |&gt; g              ≡ g (f a)
f . a . b                ≡ (f a) b
f ∘ g                    ≡ λx.f (g x)
f $ x $ y                ≡ f x y</code></pre>
<p>Parser error taxonomy includes: <code>UnexpectedToken</code>,
<code>MissingLetEquals</code>, <code>UnexpectedArrow</code>,
<code>UnexpectedComma</code>, <code>UnexpectedSemicolon</code>,
<code>IllegalAssignment</code>, <code>UnexpectedDot</code>,
<code>UnterminatedList</code>, <code>MacroPatternError</code>.</p>
<hr />
</section>
<section id="macro-system" class="level3">
<h3>Macro System</h3>
<p>Basic form:</p>
<pre class="lambda"><code>:macro (square $x) =&gt; (mult $x $x)
square 7   # → 49</code></pre>
<p>Advanced capabilities:</p>
<ol type="1">
<li>Multi‑clause macros with guards:</li>
</ol>
<pre class="lambda"><code>:macro (max2 $a $b) when (geq $a $b) =&gt; $a
:macro (max2 $a $b) =&gt; $b</code></pre>
<ol start="2" type="1">
<li>Variadic / rest patterns: <code>$xs ...</code> (tail capture →
Church list of args)</li>
<li>Guards with <code>when (expr)</code> referencing pattern vars</li>
<li>Structural application patterns: <code>(cons 1 $t)</code>,
<code>($f $x $y)</code></li>
<li>Wildcards <code>_</code> ignore subexpressions</li>
<li>Integer literal patterns match exact numerals</li>
<li>Specificity ordering (literal &amp; structural &gt; variable &gt;
rest) with tie break on arity then recency</li>
<li>Safe placeholder substitution preventing accidental capture (hygiene
roadmap)</li>
</ol>
<p>Examples:</p>
<pre class="lambda"><code>:macro (head (cons $h $t)) =&gt; $h
:macro (swapArgs ($f $a $b)) =&gt; ($f $b $a)
:macro (list $xs ...) =&gt; $xs
list 1 2 3  # expands to [1,2,3]</code></pre>
<p>Planned enhancements: hygiene / gensym, quasiquote/unquote, macro
removal, nested rest, compile‑time eval.</p>
<hr />
</section>
<section id="pretty-printing-rules" class="level3">
<h3>Pretty Printing Rules</h3>
<p>Enabled by default (<code>:pretty on</code>). Converts: | Raw Shape |
Display | |-----------|---------| | Church numeral λf.λx.f^n x |
<code>n</code> | | Church boolean | <code>true</code> /
<code>false</code> | | cons / nil chain | <code>[a, b, c]</code> | |
Church fold list | <code>[a, b, c]</code> | | Thunk (unforced/forced) |
<code>&lt;thunk: …&gt;</code> / <code>&lt;forced: …&gt;</code> |</p>
<p>Negative literals preserved; output truncates after large length with
suffix. Disable using <code>:pretty off</code> to inspect raw forms
(useful for macro debugging &amp; structural comparison).</p>
<hr />
</section>
<section id="structural-equivalence-helpers-always-on" class="level3">
<h3>Structural Equivalence Helpers (Always On)</h3>
<table>
<thead>
<tr>
<th>Helper</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alphaEq a b</code></td>
<td>Normalize &amp; alpha‑compare</td>
</tr>
<tr>
<td><code>betaEq a b</code></td>
<td>Beta normalize then alpha compare</td>
</tr>
<tr>
<td><code>hashEq a b</code></td>
<td>Hash based normalized structural check</td>
</tr>
<tr>
<td><code>etaEq a b</code></td>
<td>Beta normalize + eta reduce then alpha compare</td>
</tr>
</tbody>
</table>
<p>Intended for regression / property style tests (counters via
<code>:test result</code>).</p>
<section id="structural-equivalence-suite-extended" class="level4">
<h4>Structural Equivalence Suite (Extended)</h4>
<p>These helpers are native and always enabled (independent of
<code>:native</code> arithmetic toggles):</p>
<table>
<thead>
<tr>
<th>Helper</th>
<th>Operation Pipeline</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alphaEq a b</code></td>
<td>Normalize both; alpha-compare</td>
<td>Ignores binder names only</td>
</tr>
<tr>
<td><code>betaEq a b</code></td>
<td>Beta-normalize; alpha compare</td>
<td>Skips pre-normalization shortcut</td>
</tr>
<tr>
<td><code>hashEq a b</code></td>
<td>Beta-normalize; structural hash compare</td>
<td>Fast approximate screen; fall back to <code>betaEq</code> if
needed</td>
</tr>
<tr>
<td><code>etaEq a b</code></td>
<td>Beta-normalize; eta-reduce; alpha compare</td>
<td>Captures extensional equalities (λx.f x ≡ f)</td>
</tr>
</tbody>
</table>
<p>Process outline:</p>
<ol type="1">
<li>Force required thunks (lazy only) to expose heads.</li>
<li>Perform bounded normalization (beta; limited inlining of known
combinators; guarded to avoid runaway expansion).</li>
<li>Apply comparison strategy (hash or alpha).</li>
</ol>
<p>Guidance:</p>
<ul>
<li>Prefer <code>hashEq</code> for quick negative checks; confirm
positives with <code>betaEq</code> / <code>etaEq</code>.</li>
<li>Use <code>etaEq</code> only when eta-extensionality matters
(slightly more work).</li>
<li>Rising structural test counts (<code>:test result</code>) can
highlight hot equivalence paths—optimize upstream definitions or add
sharing.</li>
</ul>
<p>Limitations: Not a proof system; normalization bounds may yield
conservative <code>false</code> on enormous expanding macros. Eta is not
applied in <code>alphaEq</code> / <code>betaEq</code> to keep their
semantics predictable.</p>
<hr />
</section>
</section>
<section id="selected-extended-examples" class="level3">
<h3>Selected Extended Examples</h3>
<pre class="lambda"><code>compose = f -&gt; g -&gt; x -&gt; f (g x)
twice = f -&gt; x -&gt; f (f x)
map (mult 2) [1,2,3,4]           # [2,4,6,8]
5 |&gt; succ |&gt; mult 2              # 12
(mult 2 ∘ succ) 5                # 12</code></pre>
<p>For additional standard library functions see
<code>stdlib.lambda</code>.</p>
<hr />
</section>
<section id="see-also" class="level3">
<h3>See Also</h3>
<ul>
<li><code>COMMANDS.md</code> for REPL / colon command usage</li>
<li><code>COMPILER.md</code> for build, packaging, embedding &amp;
deployment</li>
<li><code>THEORY.md</code> for theoretical background</li>
</ul>
</section>
</section>
</body>
</html>
