<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lambda Calculus Interpreter UI</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Disable caching -->
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    :root { --bg:#0d1117; --panel:#161b22; --border:#30363d; --accent:#58a6ff; --text:#c9d1d9; --bad:#ff6b6b; --good:#3fb950; }
    body { font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:var(--text); margin:0; }
    header { padding:1rem 1.5rem; background:var(--panel); border-bottom:1px solid var(--border); }
  main { max-width:1400px; margin:0 auto; padding:1.25rem; display:grid; gap:1rem; grid-template-columns: 1fr 1fr; }
    section { background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:1rem 1.25rem; display:flex; flex-direction:column; }
    h1 { margin:0; font-size:1.25rem; }
    textarea, input[type=text] { background:#0f141a; color:var(--text); border:1px solid var(--border); border-radius:6px; padding:.6rem .7rem; font-family:ui-monospace,Consolas,monospace; font-size:.95rem; resize:vertical; }
    textarea:focus, input:focus { outline:1px solid var(--accent); }
    button { cursor:pointer; border:1px solid var(--accent); background:var(--accent); color:#fff; border-radius:6px; padding:.55rem .9rem; font-size:.9rem; font-weight:600; display:inline-flex; gap:.4rem; align-items:center; }
    button.secondary { background:transparent; color:var(--accent); }
    button:disabled { opacity:.5; cursor:default; }
    pre { background:#0f141a; border:1px solid var(--border); border-radius:6px; padding:.75rem; overflow:auto; font-size:.85rem; line-height:1.3; }
    code { font-family:ui-monospace,Consolas,monospace; }
    footer { text-align:center; padding:1rem; font-size:.75rem; opacity:.7; }
    .actions { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem; }
    label { font-size:.75rem; font-weight:600; text-transform:uppercase; letter-spacing:.06em; margin-bottom:.25rem; opacity:.85; }
    .small { font-size:.7rem; opacity:.7; }
    .split { display:flex; gap:.75rem; }
    .status { font-size:.75rem; letter-spacing:.05em; text-transform:uppercase; font-weight:600; }
    .bad { color:var(--bad); }
    .good { color:var(--good); }
  .full-span { grid-column:1 / -1; }
  #output { width:100%; max-width:100%; box-sizing:border-box; white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere; }
  .cont-hint { font-size:.65rem; letter-spacing:.05em; text-transform:uppercase; margin-top:.35rem; color:#e3b341; display:none; font-weight:600; }
  .cont-hint.active { display:block; }
  @media (max-width: 960px) { main { grid-template-columns:1fr; } #output { width:100%; } }
    /* Log color classes */
    .log-error{color:#ff6b6b;}
    .log-comment{color:#e3b341;}
  .log-result{color:var(--good);}
  .log-norm{color:var(--good); opacity:.85;}
    .log-step{color:#e3b341;}
    .log-time{color:#58a6ff;}
    .log-name{color:#58a6ff;}
    .log-eval{color:#d2a8ff;}
    .log-macro{color:#58a6ff;}
    .log-test{color:#d2a8ff;}
    .log-test-pass{color:var(--good);}
    .log-test-fail{color:#ff6b6b;}
    .log-command{color:#ff7b72;}
    .log-loading{color:#76e3ea;}
    .log-fileline{color:#8b949e;}
    .log-fileresult{color:var(--good);}
    .log-progress{color:#58a6ff; opacity:.7;}
  .log-processing{color:#8b949e;}
  /* Simple filters */
  #filters { display:flex; flex-wrap:wrap; gap:.5rem; margin:.4rem 0 .3rem; }
  #filters label { font-size:.55rem; letter-spacing:.08em; text-transform:uppercase; font-weight:600; display:flex; gap:.25rem; align-items:center; background:#0f141a; padding:.25rem .45rem; border:1px solid var(--border); border-radius:4px; cursor:pointer; }
  #filters input { margin:0; }
  .hidden-log { display:none !important; }
  /* Floating search nav */
  #searchFloat { position:fixed; bottom:14px; right:16px; display:none; gap:.35rem; background:rgba(22,27,34,.92); border:1px solid var(--border); padding:.4rem .55rem; border-radius:6px; box-shadow:0 2px 6px rgba(0,0,0,.4); z-index:999; font-size:.6rem; align-items:center; }
  #searchFloat button { font-size:.6rem; padding:.25rem .45rem; }
  #searchFloat .count { opacity:.7; font-weight:500; }
  @media (max-width:600px){ #searchFloat { right:8px; left:8px; justify-content:space-between; } }
  </style>
</head>
<body>
  <header><h1>Lambda Calculus Interpreter</h1></header>
  <main>
    <section id="repl">
      <label for="expr">Expression / Commands</label>
      <textarea id="expr" rows="8" style="height: 130px;" placeholder=":help or succ 41 or let add = x,y -> x + y in add 2 3"></textarea>
  <div id="contHint" class="cont-hint" aria-live="polite">Continuation: line will join with next</div>
      <div class="actions">
        <button id="runBtn">Evaluate</button>
        <button class="secondary" id="clearBtn" type="button">Clear Output</button>
  <button class="secondary" id="clearInputBtn" type="button">Clear Input</button>
        <button class="secondary" id="streamToggle" type="button" data-on="0">Streaming: Off</button>
        <button class="secondary" id="wsToggle" type="button" data-on="0">WS: Off</button>
      </div>
  <div class="small">Multiple expressions separated by semicolons are processed sequentially. Each line is evaluated independently.</div>
    </section>
    <section>
      <label for="filePath">Load .lambda File</label>
      <div class="split">
        <input type="text" id="filePath" placeholder="path e.g. stdlib.lambda" />
        <button id="loadBtn" type="button">Load</button>
        <button id="localLoadBtn" type="button" class="secondary">Local...</button>
        <input id="localFile" type="file" accept=".lambda,.txt" style="display:none" />
      </div>
      <div id="fileStatus" class="status" style="margin-top:.5rem;">Idle</div>
      <div id="fileProgress" style="margin-top:.4rem;height:6px;background:#222;border:1px solid var(--border);border-radius:4px;overflow:hidden;display:none;">
        <div id="fileProgressBar" style="height:100%;width:0;background:var(--accent);transition:width .25s;"></div>
      </div>
      <hr style="margin:1rem 0; border:0; border-top:1px solid var(--border);" />
      <h3 style="margin-top:0;">Quick Examples</h3>
      <ul style="margin:.25rem 0 0 1.1rem; padding:0; font-size:.8rem; line-height:1.4;">
        <li>succ 5</li><li>let inc = x -> succ x in inc 41</li><li>[1,2,3]</li><li>let rec fact = n -> if (iszero n) 1 (mult n (fact (pred n))) in fact 5</li>
      </ul>
    </section>
    <section class="full-span" aria-label="Result Log">
      <div style="display:flex; flex-wrap:wrap; gap:.75rem; align-items:flex-end; justify-content:space-between;">
        <label for="output" style="font-size:.75rem;font-weight:600;text-transform:uppercase;letter-spacing:.06em;opacity:.85;">Result / Log</label>
        <div id="searchBox" style="display:flex; gap:.4rem; align-items:center; font-size:.65rem;">
          <input id="searchInput" type="text" placeholder="Search" style="width:140px; font-size:.65rem; padding:.4rem .5rem;" />
          <button class="secondary" id="searchPrev" type="button" style="font-size:.6rem; padding:.35rem .5rem;">Prev</button>
          <button class="secondary" id="searchNext" type="button" style="font-size:.6rem; padding:.35rem .5rem;">Next</button>
          <button class="secondary" id="searchClear" type="button" style="font-size:.6rem; padding:.35rem .5rem;">Clear</button>
        </div>
      </div>
  <div id="filters"></div>
      <pre id="output" aria-live="polite"></pre>
    </section>
  </main>
  <footer>Lambda Calculus Interpreter UI • <span id="health">checking...</span></footer>
  <div id="searchFloat" aria-hidden="true"><span class="count" id="searchCount">0/0</span> <button id="sfPrev" type="button" class="secondary">Prev</button> <button id="sfNext" type="button" class="secondary">Next</button> <button id="sfClear" type="button" class="secondary" title="Clear (Esc)">✕</button></div>
  <script>
    // ---- Cache busting & cache clearing ----
    (function(){
      // Attempt to clear Service Worker registrations & caches (if any were previously installed)
      if('serviceWorker' in navigator){
        navigator.serviceWorker.getRegistrations().then(rs=> rs.forEach(r=> r.unregister().catch(()=>{}))).catch(()=>{});
      }
      if('caches' in window){
        caches.keys().then(keys=> keys.forEach(k=> caches.delete(k).catch(()=>{}))).catch(()=>{});
      }
      // Add a cache-busting token to URL strings
      window.__cacheBust = function(u){ try { const t = Date.now().toString(36)+Math.random().toString(36).slice(2); return u + (u.includes('?')?'&':'?') + '_='+ t; } catch { return u; } };
    })();
    // ---- API helpers ----
    async function evalExpr(expr){
      const r = await fetch(__cacheBust(`/api/eval?expr=${encodeURIComponent(expr)}`), {cache:'no-store'});
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }
    async function loadFile(p){
      const r = await fetch(__cacheBust('/api/load'),{method:'POST',headers:{'Content-Type':'application/json','Cache-Control':'no-cache','Pragma':'no-cache'},body:JSON.stringify({path:p}),cache:'no-store'});
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }

    // ---- Elements ----
    const exprEl = document.getElementById('expr');
    const outEl = document.getElementById('output');
    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');
  const clearInputBtn = document.getElementById('clearInputBtn');
    const streamToggle = document.getElementById('streamToggle');
    const wsToggle = document.getElementById('wsToggle');
  const loadBtn = document.getElementById('loadBtn');
  const localLoadBtn = document.getElementById('localLoadBtn');
  const localFileInput = document.getElementById('localFile');
    const filePathEl = document.getElementById('filePath');
    const fileStatus = document.getElementById('fileStatus');
    const fileProgress = document.getElementById('fileProgress');
    const fileProgressBar = document.getElementById('fileProgressBar');
  // Search elements
  const searchInput = document.getElementById('searchInput');
  const searchPrev = document.getElementById('searchPrev');
  const searchNext = document.getElementById('searchNext');
  const searchClear = document.getElementById('searchClear');
  // Floating nav elements
  const searchFloat = document.getElementById('searchFloat');
  const sfPrev = document.getElementById('sfPrev');
  const sfNext = document.getElementById('sfNext');
  const sfClear = document.getElementById('sfClear');
  const searchCount = document.getElementById('searchCount');

    // ---- Log classification & append (with cap) ----
    const MAX_LOG_LINES = 4000;
    function classify(line){
      const s = line.trimStart();
      if(s.startsWith('PROGRESS::')) return 'log-progress';
      if(s.startsWith('Error:')) return 'log-error';
      if(s.startsWith('#')) return 'log-comment';
      if(s.startsWith('Norm:')) return 'log-norm';
      if(s.startsWith('->')) return 'log-result';
      if(s.startsWith('Step')) return 'log-step';
      if(s.startsWith('Time:')) return 'log-time';
      if(s.startsWith('Name:')) return 'log-name';
      if(s.startsWith('Eval:')) return 'log-eval';
      if(s.startsWith('Macro')) return 'log-macro';
      if(s.startsWith('Test: passed')) return 'log-test-pass';
      if(s.startsWith('Test: failed')) return 'log-test-fail';
      if(s.startsWith('Test:')) return 'log-test';
      if(s.startsWith('Processing:')) return 'log-processing';
      if(s.startsWith(':')) return 'log-command';
      if(s.includes('Loading')) return 'log-loading';
      if(s.includes('<<')) return 'log-fileline';
      if(s.includes('>>')) return 'log-fileresult';
      return '';
    }
    function append(text){
      const cls = classify(text);
      const span = document.createElement('span');
      if(cls) span.className = cls;
      // Include trailing newline inside the span so hiding the span also hides its line break
      span.textContent = text + '\n';
      if(isFilteredSpan(span)) span.classList.add('hidden-log');
      outEl.appendChild(span);
      // Cap total lines by counting spans (one per line now)
      if(outEl.childNodes.length > MAX_LOG_LINES){
        while(outEl.childNodes.length > MAX_LOG_LINES){ outEl.removeChild(outEl.firstChild); }
      }
      outEl.scrollTop = outEl.scrollHeight;
    }

    // ---- Streaming (SSE / WebSocket) ----
    let es=null, ws=null; let streaming=false, useWS=false;
    function handleProgress(pct){
      fileProgress.style.display='block';
      fileProgressBar.style.width=pct+'%';
      if(pct>=100) setTimeout(()=>{ fileProgress.style.display='none'; fileProgressBar.style.width='0%'; },1200);
    }
    function ensureStream(){
      if(!streaming) return;
      if(useWS){
        if(ws && ws.readyState===WebSocket.OPEN) return;
        if(ws) { try{ ws.close(); }catch{} ws=null; }
  ws = new WebSocket(__cacheBust((location.protocol==='https:'?'wss':'ws')+'://'+location.host+'/ws'));
        ws.onmessage = ev => {
          const d = ev.data;
            if(typeof d==='string'){
              if(d.startsWith('PROGRESS::')) handleProgress(parseInt(d.split('::')[1]||'0',10)); else append(d);
            }
        };
        ws.onclose = ()=>{ if(streaming && useWS) setTimeout(ensureStream, 1200); };
        ws.onerror = ()=>{ try{ ws.close(); }catch{} if(streaming && useWS) setTimeout(ensureStream,1200); };
      } else {
        if(es) return;
  es = new EventSource(__cacheBust('/api/stream'));
        es.onmessage = e => {
          if(e.data && e.data!=='.'){
            if(e.data.startsWith('PROGRESS::')) handleProgress(parseInt(e.data.split('::')[1]||'0',10)); else append(e.data);
          }
        };
        es.onerror = ()=>{ es.close(); es=null; if(streaming && !useWS) setTimeout(ensureStream,1500); };
      }
    }
    streamToggle.addEventListener('click',()=>{
      streaming = !streaming;
      streamToggle.dataset.on = streaming ? '1':'0';
      streamToggle.textContent = 'Streaming: ' + (streaming?'On':'Off');
      if(streaming){ ensureStream(); append('[streaming enabled via '+(useWS?'WebSocket':'SSE')+']'); }
      else { if(es){ es.close(); es=null; } if(ws){ ws.close(); ws=null; } append('[streaming disabled]'); }
    });
    wsToggle.addEventListener('click',()=>{
      useWS = !useWS;
      wsToggle.dataset.on = useWS ? '1':'0';
      wsToggle.textContent = 'WS: ' + (useWS?'On':'Off');
      if(streaming){ if(es){ es.close(); es=null; } if(ws){ try{ ws.close(); }catch{} ws=null; } ensureStream(); append('[switched to '+(useWS?'WebSocket':'SSE')+']'); }
    });

    // ---- Evaluation ----
    async function doEval(){
      // Split into raw lines, then merge lines ending with an unescaped backslash (\\) as continuations
      const rawLines = exprEl.value.split(/\r?\n/);
      const merged = [];
      let buffer = '';
      for(let i=0;i<rawLines.length;i++){
        let line = rawLines[i];
        const continued = /(^|[^\\])\\$/.test(line); // backslash at end not escaped by another backslash
        if(continued){
          line = line.replace(/\\$/,'');
          buffer += line;
          continue; // accumulate
        } else {
          buffer += line;
          const finalLine = buffer.trim();
          if(finalLine.length) merged.push(finalLine);
          buffer='';
        }
      }
      if(buffer.trim().length){ merged.push(buffer.trim()); }
      const lines = merged.filter(l=>l.length>0);
      if(lines.length === 0) return;
      runBtn.disabled = true;
      try {
        for(const raw of lines) {
          const res = await evalExpr(raw);
          append(`> ${raw}`);
          if(!streaming){
            if(Array.isArray(res.logs) && res.logs.length) res.logs.forEach(l=>append(l));
            const primary = res.output || res.normalized || '(no output)';
            const logsArray = Array.isArray(res.logs) ? res.logs : [];
            const hasResultLine = logsArray.some(l=> l.startsWith('-> '));
            // Only append primary / normalized if not already represented in logs
            if(!hasResultLine && (!logsArray.includes(primary))) append(primary);
            let appendedNorm = false;
            if(res.normalized && res.normalized !== primary){
              const alreadyLogged = logsArray.some(l=> l.trim() === res.normalized.trim() || l.trim() === ('Norm: '+res.normalized).trim());
              if(!alreadyLogged){ append('Norm: ' + res.normalized); appendedNorm = true; }
            }
            if(appendedNorm) append('');
          } else {
            // streaming: only final outputs (logs already streamed)
            const primary = res.output || res.normalized || '(no output)';
            append(primary);
            let appendedNorm = false;
            if(res.normalized && res.normalized !== primary){ append(res.normalized); appendedNorm = true; }
            if(appendedNorm) append('');
          }
        }
      } catch(e){ append(`ERR: ${e.message}`); }
      finally { runBtn.disabled=false; }
  // --- History: push each evaluated line (after successful attempt or error) ---
  try { lines.forEach(l=> pushHistory(l)); } catch { /* ignore */ }
    }

    // ---- Continuation hint (live) ----
    function updateContinuationHint(){
      const v = exprEl.value;
      const lines = v.split(/\r?\n/);
      const last = lines[lines.length-1];
      const active = /(^|[^\\])\\$/.test(last || '');
      document.getElementById('contHint').classList.toggle('active', active);
    }
    exprEl.addEventListener('input', updateContinuationHint);
    exprEl.addEventListener('keyup', updateContinuationHint);
    updateContinuationHint();

    runBtn.addEventListener('click', doEval);
    exprEl.addEventListener('keydown', e=>{ if(e.key==='Enter' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); doEval(); }});
    // --- Search ---
    let searchHits = [];
    let searchIndex = -1;
    function clearSearch(){
      searchHits.forEach(el=> el.classList.remove('search-hit','search-current'));
      searchHits=[]; searchIndex=-1; updateSearchFloat();
    }
    function performSearch(){
      clearSearch();
      const term = searchInput.value.trim();
      if(!term){ updateSearchFloat(); return; }
      let rx;
      try { rx = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),'i'); } catch { return; }
      outEl.querySelectorAll('span').forEach(s=>{ if(rx.test(s.textContent)){ s.classList.add('search-hit'); searchHits.push(s); } });
      if(searchHits.length){ searchIndex=0; focusSearch(); }
      updateSearchFloat();
    }
    function focusSearch(){
      searchHits.forEach(el=> el.classList.remove('search-current'));
      if(searchIndex>=0 && searchIndex<searchHits.length){
        const el = searchHits[searchIndex];
        el.classList.add('search-current');
        el.scrollIntoView({block:'center'});
      }
      updateSearchFloat();
    }
    function updateSearchFloat(){
      if(!searchFloat) return;
      if(searchHits.length){
        searchFloat.style.display='flex';
        searchCount.textContent = (searchIndex>=0? (searchIndex+1):0) + '/' + searchHits.length;
        searchFloat.setAttribute('aria-hidden','false');
      } else {
        searchFloat.style.display='none';
        searchFloat.setAttribute('aria-hidden','true');
      }
    }
    searchInput?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ performSearch(); } });
    function nextHit(){ if(!searchHits.length) performSearch(); else { searchIndex=(searchIndex+1)%searchHits.length; focusSearch(); } }
    function prevHit(){ if(!searchHits.length) performSearch(); else { searchIndex=(searchIndex-1+searchHits.length)%searchHits.length; focusSearch(); } }
    searchNext?.addEventListener('click', nextHit);
    searchPrev?.addEventListener('click', prevHit);
    searchClear?.addEventListener('click',()=>{ searchInput.value=''; clearSearch(); });
    sfNext?.addEventListener('click', nextHit);
    sfPrev?.addEventListener('click', prevHit);
    sfClear?.addEventListener('click',()=>{ searchInput.value=''; clearSearch(); });
    // Keyboard shortcuts: / focus, F3/Enter next, Shift+F3 previous, n/N for next/prev when not in input, Esc clears
    document.addEventListener('keydown', e=>{
      const active = document.activeElement;
      const inEditable = active && (active.tagName==='INPUT' || active.tagName==='TEXTAREA');
      if(e.key==='/' && !inEditable){ e.preventDefault(); searchInput.focus(); }
      else if(e.key==='F3'){ e.preventDefault(); if(e.shiftKey) prevHit(); else nextHit(); }
      else if(e.key==='Enter' && active===searchInput){ e.preventDefault(); nextHit(); }
      else if((e.key==='n' || e.key==='N') && !inEditable){ e.preventDefault(); e.key==='n'? nextHit(): prevHit(); }
      else if(e.key==='Escape'){ if(searchHits.length){ clearSearch(); } }
    });
    // Placeholder hint update
    if(searchInput) searchInput.placeholder = 'Search (/ F3 n/N)';
    // Add search highlight styles dynamically
    (function(){ const style=document.createElement('style'); style.textContent='.search-hit{background:#1f2a33; border-radius:3px;} .search-current{outline:1px solid var(--accent);}'; document.head.appendChild(style); })();
    // --- Simple Filters (Macro, Test, Time, Step, Processing) ---
    const FILTER_CONFIG = [
      {label:'Macro', classes:['log-macro']},
      {label:'Test', classes:['log-test','log-test-pass','log-test-fail']},
      {label:'Time', classes:['log-time']},
      {label:'Step', classes:['log-step']},
      {label:'Eval', classes:['log-eval']},
      {label:'Norm', classes:['log-norm']},
      {label:'Name', classes:['log-name']},
      {label:'Processing', classes:['log-processing']}
    ];
    let disabledGroups = new Set(); // start with all enabled
    // Determine if a span should be hidden based on ANY of its classes
    function isFilteredSpan(el){
      for(const g of FILTER_CONFIG){
        if(disabledGroups.has(g.label)){
          // If element has any class belonging to this disabled group -> hide
            for(const cls of g.classes){ if(el.classList.contains(cls)) return true; }
        }
      }
      return false;
    }
    function renderFilters(){
      const host=document.getElementById('filters'); if(!host) return; host.innerHTML='';
      FILTER_CONFIG.forEach(g=>{
        const id='f_'+g.label.toLowerCase();
        const lab=document.createElement('label');
        const cb=document.createElement('input'); cb.type='checkbox'; cb.id=id; cb.checked=!disabledGroups.has(g.label);
        cb.addEventListener('change',()=>{ if(cb.checked) disabledGroups.delete(g.label); else disabledGroups.add(g.label); applyLineFilters(); });
        lab.appendChild(cb); lab.appendChild(document.createTextNode(g.label)); host.appendChild(lab);
      });
    }
    function applyLineFilters(){
      outEl.querySelectorAll('span').forEach(s=>{
        if(isFilteredSpan(s)) s.classList.add('hidden-log'); else s.classList.remove('hidden-log');
      });
    }
    renderFilters();
    // --- History navigation (Up/Down at boundaries) ---
    const HISTORY_KEY = 'lambdaHistory';
    let history = [];
    let histIndex = 0;
    function loadHistory(){
      try { history = JSON.parse(localStorage.getItem(HISTORY_KEY)||'[]'); if(!Array.isArray(history)) history=[]; } catch { history=[]; }
      histIndex = history.length;
    }
    function saveHistory(){ try { localStorage.setItem(HISTORY_KEY, JSON.stringify(history.slice(-500))); } catch { }
    }
    function pushHistory(entry){
      if(!entry || !entry.trim()) return;
      if(history[history.length-1] === entry) return; // avoid consecutive duplicate
      history.push(entry);
      histIndex = history.length;
      saveHistory();
    }
    loadHistory();
    exprEl.addEventListener('keydown', e=>{
      if(e.key === 'ArrowUp' && exprEl.selectionStart===0 && exprEl.selectionEnd===0){
        if(histIndex > 0){ histIndex--; exprEl.value = history[histIndex]; updateContinuationHint(); e.preventDefault(); }
      } else if(e.key === 'ArrowDown' && exprEl.selectionStart===exprEl.value.length && exprEl.selectionEnd===exprEl.value.length){
        if(histIndex < history.length-1){ histIndex++; exprEl.value = history[histIndex]; updateContinuationHint(); e.preventDefault(); }
        else if(histIndex === history.length-1){ histIndex = history.length; exprEl.value=''; updateContinuationHint(); e.preventDefault(); }
      }
    });
    clearBtn.addEventListener('click', ()=>{ outEl.textContent=''; });
  clearInputBtn.addEventListener('click', ()=>{ exprEl.value=''; updateContinuationHint(); exprEl.focus(); });
    loadBtn.addEventListener('click', async ()=>{
      const p = filePathEl.value.trim(); if(!p) return;
      fileStatus.textContent='Loading...';
      if(streaming){ fileProgress.style.display='block'; fileProgressBar.style.width='0%'; }
      try {
        const r = await loadFile(p);
        fileStatus.textContent = 'Loaded: ' + r.message;
        if(!streaming && r.logs && Array.isArray(r.logs) && r.logs.length){ r.logs.forEach(l=>append(l)); append(''); }
      } catch(e){ fileStatus.textContent = 'Error: ' + e.message; }
    });
    // ---- Local file loading (.lambda) ----
    localLoadBtn?.addEventListener('click', ()=> localFileInput?.click());
    localFileInput?.addEventListener('change', ()=>{
      const f = localFileInput.files?.[0];
      if(!f) return;
      loadLocalLambdaFile(f);
      // reset input so selecting same file again re-triggers
      localFileInput.value='';
    });
    async function loadLocalLambdaFile(file){
      fileStatus.textContent = `Local: ${file.name} (reading...)`;
      try {
        const text = await file.text();
        const rawLines = text.split(/\r?\n/);
        // Simple filtering: keep lines, preserve blank lines for counting but skip evaluating blanks/comments
        const toEval = rawLines.map(l=>l.trim()).filter(l=> l.length && !l.startsWith('#'));
        if(!toEval.length){ fileStatus.textContent = `Local: ${file.name} (no expressions found)`; return; }
        append(`[local load start: ${file.name} expressions=${toEval.length}]`);
        // Show progress bar even if not streaming for user feedback
        fileProgress.style.display='block'; fileProgressBar.style.width='0%';
        for(let i=0;i<toEval.length;i++){
          const expr = toEval[i];
          try {
            const res = await evalExpr(expr);
            append(`> ${expr}`);
            if(!streaming){
              if(Array.isArray(res.logs) && res.logs.length) res.logs.forEach(l=>append(l));
              const primary = res.output || res.normalized || '(no output)';
              const logsArray = Array.isArray(res.logs)? res.logs:[];
              const hasResultLine = logsArray.some(l=> l.startsWith('-> '));
              if(!hasResultLine && (!logsArray.includes(primary))) append(primary);
              let appendedNorm = false;
              if(res.normalized && res.normalized !== primary){
                const alreadyLogged = logsArray.some(l=> l.trim() === res.normalized.trim() || l.trim() === ('Norm: '+res.normalized).trim());
                if(!alreadyLogged){ append('Norm: ' + res.normalized); appendedNorm = true; }
              }
              if(appendedNorm) append('');
            } else {
              const primary = res.output || res.normalized || '(no output)';
              append(primary);
              let appendedNorm = false;
              if(res.normalized && res.normalized !== primary){ append(res.normalized); appendedNorm = true; }
              if(appendedNorm) append('');
            }
          } catch(err){
            append(`ERR: ${err.message}`);
          }
          const pct = Math.round(((i+1)/toEval.length)*100);
          fileProgressBar.style.width = pct + '%';
        }
        setTimeout(()=>{ fileProgress.style.display='none'; fileProgressBar.style.width='0%'; }, 900);
        fileStatus.textContent = `Local: ${file.name} loaded (${toEval.length} expressions)`;
        append(`[local load done: ${file.name}]`);
      } catch(e){
        fileStatus.textContent = `Local load error: ${e.message}`;
      }
    }

    // ---- Health + auto-init ----
  fetch(__cacheBust('/api/health'), {cache:'no-store'}).then(r=>r.ok?document.getElementById('health').textContent='ready':null).catch(()=>{});
    if(location.hash.includes('stream')) streamToggle.click();
  </script>
</body>
</html>
