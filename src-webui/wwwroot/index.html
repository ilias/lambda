<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lambda Calculus Interpreter UI</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Disable caching -->
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <link rel="stylesheet" href="app.css" />
  <style>
  main { max-width:1400px; margin:0 auto; padding:1.25rem; display:grid; gap:1rem; grid-template-columns: 1fr 1fr; }
  section { background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:1rem 1.25rem; display:flex; flex-direction:column; }
  .full-span { grid-column:1 / -1; }
  #output { width:100%; max-width:100%; box-sizing:border-box; white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere; }
  #outputTabs, #inputTabs { display:flex; gap:.35rem; margin:.4rem 0 .5rem; align-items:stretch; flex-wrap:wrap; }
  #outputTabs.inline-tabs { margin:0 .75rem 0 .75rem; }
  #outputTabs .tab, #inputTabs .tab { position:relative; padding:.35rem .65rem; background:var(--panel); border:1px solid var(--border); border-radius:5px; cursor:pointer; font-size:.65rem; font-weight:600; letter-spacing:.05em; -webkit-user-select:none; user-select:none; display:inline-flex; align-items:center; gap:.4rem; }
  /* active tab style moved to app.css */
  #outputTabs .tab .close, #inputTabs .tab .close { font-weight:700; font-size:.75rem; line-height:1; cursor:pointer; opacity:.8; }
  #outputTabs .tab .close:hover, #inputTabs .tab .close:hover { opacity:1; }
  #addTabBtn { padding:.35rem .55rem; font-size:.7rem; }
  .output-pane { display:none; overflow-y:auto; overflow-x:hidden; }
  .output-pane.active { display:block; }
  .cont-hint { font-size:.65rem; letter-spacing:.05em; text-transform:uppercase; margin-top:.35rem; color:#e3b341; display:none; font-weight:600; }
  .cont-hint.active { display:block; }
  /* Log color classes */
  .log-error{color:#ff6b6b;} .log-comment{color:#e3b341;} .log-result{color:var(--good);} .log-norm{color:var(--good); opacity:.85;} .log-step{color:#e3b341;} .log-time{color:#58a6ff;} .log-name{color:#58a6ff;} .log-eval{color:#d2a8ff;} .log-macro{color:#58a6ff;} .log-alpha{color:#d2a8ff;} .log-alpha-pass{color:var(--good);} .log-alpha-fail{color:#ff6b6b;} .log-command{color:#ff7b72;} .log-loading{color:#76e3ea;} .log-fileline{color:#8b949e;} .log-fileresult{color:var(--good);} .log-progress{color:#58a6ff; opacity:.7;} .log-processing{color:#8b949e;}
  #filters { display:flex; flex-wrap:wrap; gap:.5rem; margin:.4rem 0 .3rem; }
  #filters label { font-size:.55rem; letter-spacing:.08em; text-transform:uppercase; font-weight:600; display:flex; gap:.25rem; align-items:center; background:var(--panel); padding:.25rem .45rem; border:1px solid var(--border); border-radius:4px; cursor:pointer; }
  #filters input { margin:0; accent-color:var(--accent); }
  .hidden-log { display:none !important; }
  @media (max-width: 960px) { main { grid-template-columns:1fr; } #output { width:100%; } }
  @media (max-width:600px){ #searchFloat { right:8px; /* left removed to keep it anchored right */ } }
  /* Scroll nav buttons (moved to left side) */
  #scrollBottomBtn, #scrollTopBtn { position:fixed; z-index:1000; padding:.4rem .55rem; font-size:.65rem; left:10px; }
  #scrollBottomBtn { top:10px; }
  #scrollTopBtn { bottom:10px; }
  .max-lines-wrap { display:flex; align-items:center; gap:.35rem; margin-left:.75rem; }
  .max-lines-wrap label { font-size:.55rem; letter-spacing:.08em; font-weight:600; text-transform:uppercase; }
  #maxLinesInput { width:5.2rem; padding:.15rem .3rem; font-size:.7rem; }
  </style>
</head>
<body>
  <header class="site-header">
    <h1 class="site-title">Lambda Calculus Interpreter</h1>
    <nav class="site-nav">
      <a href="readme.html" rel="noopener" target="_blank">Help ↗</a>
      <a href="https://github.com/ilias/lambda" target="_blank" rel="noopener">GitHub ↗</a>
      <select id="themeSel" class="theme-select" aria-label="Theme">
        <option value="dark">Dark</option>
        <option value="light">Light</option>
        <option value="colorful">Colorful</option>
      </select>
    </nav>
  </header>
  <main>
    <section id="repl">
      <div class="bar bar-space">
        <label for="expr" class="m0">Expression / Commands</label>
        <div id="inputTabs" class="flex-tabs"></div>
      </div>
      <div id="inputEditors"></div>
      <!-- Initial textarea will be transformed into first tab by script (kept for noscript fallback) -->
      <textarea id="expr" rows="8" class="expr-area" placeholder=":help or succ 41 or let add = x,y -> x + y in add 2 3"></textarea>
  <div id="contHint" class="cont-hint" aria-live="polite">Continuation: line will join with next</div>
      <div class="actions">
        <button id="runBtn">Evaluate</button>
        <button class="secondary" id="clearBtn" type="button">Clear Output</button>
  <button class="secondary" id="clearInputBtn" type="button">Clear Input</button>
        <button class="secondary" id="streamToggle" type="button" data-on="0">Streaming: Off</button>
        <button class="secondary" id="wsToggle" type="button" data-on="0">WS: Off</button>
      </div>
  <div class="small">Multiple expressions separated by semicolons are processed sequentially. Each line is evaluated independently.</div>
    </section>
    <section>
      <label for="filePath">Load .lambda File</label>
      <div class="split">
        <input type="text" id="filePath" placeholder="path e.g. stdlib.lambda" />
        <button id="loadBtn" type="button">Load</button>
        <button id="localLoadBtn" type="button" class="secondary">Local...</button>
  <input id="localFile" type="file" accept=".lambda,.txt" class="hidden" aria-label="Local lambda file" />
      </div>
      <div id="fileStatus" class="status mt-sm">Idle</div>
      <div id="fileProgress" class="progress"><div id="fileProgressBar" class="progress-bar"></div>
      </div>
      <hr class="rule" />
      <h3 class="mt0">Quick Examples</h3>
      <ul class="examples-list">
        <li>succ 5</li><li>let inc = x -> succ x in inc 41</li><li>[1,2,3]</li><li>let rec fact = n -> if (iszero n) 1 (mult n (fact (pred n))) in fact 5</li>
      </ul>
    </section>
    <section class="full-span" aria-label="Result Log">
      <div class="bar bar-results">
        <label for="output" class="label-small mt-aligned">Result / Log</label>
        <div id="outputTabs" class="inline-tabs"></div>
        <div class="inline small max-lines-wrap">
          <label for="maxLinesInput">Max Lines</label>
          <input id="maxLinesInput" type="number" min="100" max="200000" step="100" value="4000" title="Maximum lines retained per log tab" />
        </div>
        <div id="searchBox" class="search-box inline push-right">
          <input id="searchInput" type="text" placeholder="Search" class="search-input" />
          <button class="secondary tiny" id="searchPrev" type="button">Prev</button>
          <button class="secondary tiny" id="searchNext" type="button">Next</button>
          <button class="secondary tiny" id="searchClear" type="button">Clear</button>
        </div>
      </div>
      <div id="filters"></div>
      <div id="outputPanes"></div>
    </section>
  </main>
  <footer>Lambda Calculus Interpreter UI • <span id="health">checking...</span></footer>
  <div id="searchFloat" aria-hidden="true"><span class="count" id="searchCount">0/0</span> <button id="sfPrev" type="button" class="secondary">Prev</button> <button id="sfNext" type="button" class="secondary">Next</button> <button id="sfClear" type="button" class="secondary" title="Clear (Esc)">✕</button></div>
  <!-- Scroll navigation links -->
  <button id="scrollBottomBtn" type="button" title="Go to bottom" aria-label="Scroll to bottom" class="secondary">▼</button>
  <button id="scrollTopBtn" type="button" title="Go to top" aria-label="Scroll to top" class="secondary">▲</button>
  <script>
    // ---- Cache busting & cache clearing ----
    (function(){
      // Attempt to clear Service Worker registrations & caches (if any were previously installed)
      if('serviceWorker' in navigator){
        navigator.serviceWorker.getRegistrations().then(rs=> rs.forEach(r=> r.unregister().catch(()=>{}))).catch(()=>{});
      }
      if('caches' in window){
        caches.keys().then(keys=> keys.forEach(k=> caches.delete(k).catch(()=>{}))).catch(()=>{});
      }
      // Add a cache-busting token to URL strings
      window.__cacheBust = function(u){ try { const t = Date.now().toString(36)+Math.random().toString(36).slice(2); return u + (u.includes('?')?'&':'?') + '_='+ t; } catch { return u; } };
    })();
    // ---- API helpers ----
    async function evalExpr(expr){
      const r = await fetch(__cacheBust(`/api/eval?expr=${encodeURIComponent(expr)}`), {cache:'no-store'});
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }
    async function loadFile(p){
      const r = await fetch(__cacheBust('/api/load'),{method:'POST',headers:{'Content-Type':'application/json','Cache-Control':'no-cache','Pragma':'no-cache'},body:JSON.stringify({path:p}),cache:'no-store'});
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }

    // ---- Elements ----
    // ---- Multi-Input Tabs ----
    const inputTabsHost = document.getElementById('inputTabs');
    const inputEditorsHost = document.getElementById('inputEditors');
    let inputTabs = []; // {id,name,el,taEl,history:[],histIndex:number}
    let activeInput = null; // tab object
    let exprEl = null; // alias to active textarea for legacy code
    function createInputTab(name){
      const id = 'in_'+Date.now().toString(36)+Math.random().toString(36).slice(2,7);
      const tabEl = document.createElement('div');
      tabEl.className='tab';
      tabEl.textContent = name;
      tabEl.dataset.tabId = id;
      // add close except first
      if(inputTabs.length>0){
        const close = document.createElement('span');
        close.textContent='×';
        close.className='close';
        close.title='Close input tab';
        close.addEventListener('click', (e)=>{ e.stopPropagation(); closeInputTab(id); });
        tabEl.appendChild(close);
      }
      tabEl.addEventListener('click', ()=> activateInputTab(id));
      // Insert before add button if exists
      if(typeof addInputBtnRef === 'undefined' || !addInputBtnRef || !addInputBtnRef.parentNode){
        inputTabsHost.appendChild(tabEl);
      } else {
        inputTabsHost.insertBefore(tabEl, addInputBtnRef);
      }
  const ta = document.createElement('textarea');
  ta.className='input-pane';
  ta.rows=8;
      ta.placeholder=':help or succ 41 or let add = x,y -> x + y in add 2 3';
      ta.dataset.tabId = id;
  // hidden until activated
      // Event listeners for continuation + history + submit
      ta.addEventListener('input', updateContinuationHint);
      ta.addEventListener('keyup', updateContinuationHint);
      ta.addEventListener('keydown', e=>{ if(e.key==='Enter' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); doEval(); }});
      ta.addEventListener('keydown', handleHistoryNav);
      inputEditorsHost.appendChild(ta);
      const tabObj = {id,name,el:tabEl,taEl:ta,history:[],histIndex:0};
      inputTabs.push(tabObj);
      loadHistory(tabObj);
      // If first tab, activate immediately
      if(inputTabs.length===1){ activateInputTab(id); }
      return tabObj;
    }
    function activateInputTab(id){
      const tab = inputTabs.find(t=> t.id===id) || null;
      if(!tab) return;
      inputTabs.forEach(t=>{
        const isActive = t===tab;
        t.el.classList.toggle('active', isActive);
  t.taEl.classList.toggle('active', isActive);
      });
      activeInput = tab; exprEl = tab.taEl; exprEl.focus();
      updateContinuationHint();
    }
    function closeInputTab(id){
      if(inputTabs.length===1) return; // keep at least one
      const idx = inputTabs.findIndex(t=> t.id===id);
      if(idx<0) return;
      const tab = inputTabs[idx];
      tab.el.remove(); tab.taEl.remove();
      inputTabs.splice(idx,1);
      if(activeInput && activeInput.id===id){ const newIdx = Math.max(0, idx-1); activateInputTab(inputTabs[newIdx].id); }
    }
    // Add + button for inputs
    const addInputBtnRef = document.createElement('button');
    addInputBtnRef.type='button'; addInputBtnRef.textContent='+'; addInputBtnRef.className='secondary'; addInputBtnRef.style.fontSize='.65rem'; addInputBtnRef.title='New input tab';
    addInputBtnRef.addEventListener('click', ()=>{ createInputTab('Input '+(inputTabs.length+1)); });
    inputTabsHost.appendChild(addInputBtnRef);
    // Initialize from hidden fallback textarea content (if any)
    (function initFirstInput(){
      const orig = document.getElementById('expr');
      const first = createInputTab('Input 1');
      if(orig && orig.value){ first.taEl.value = orig.value; }
      if(orig) orig.remove();
    })();
    // Output tab infrastructure
    const outputTabsEl = document.getElementById('outputTabs');
    const outputPanesEl = document.getElementById('outputPanes');
    let tabs = []; // {id,name,preEl,logs:[]}
    let activeTab = null;
  // Early search state (needed because activateTab() calls clearSearch during initial tab creation)
  let searchHits = [];
  let searchIndex = -1;
  // Predeclare search UI element refs (assigned later) to avoid TDZ errors when updateSearchFloat runs early
  let searchInput, searchPrev, searchNext, searchClear, searchFloat, sfPrev, sfNext, sfClear, searchCount;
    function createTab(name){
      const id = 'tab_'+Date.now().toString(36)+Math.random().toString(36).slice(2,7);
      const pre = document.createElement('pre');
      pre.className='output-pane';
      pre.setAttribute('aria-live','polite');
      pre.dataset.tabId = id;
      outputPanesEl.appendChild(pre);
      const tabEl = document.createElement('div');
      tabEl.className='tab';
      tabEl.textContent = name;
      tabEl.dataset.tabId = id;
      if(tabs.length>0){
        const close = document.createElement('span');
        close.textContent='×';
        close.className='close';
        close.title='Close tab';
        close.addEventListener('click', (e)=>{ e.stopPropagation(); closeTab(id); });
        tabEl.appendChild(close);
      }
      tabEl.addEventListener('click', ()=> activateTab(id));
      // If addTabBtnRef not yet created (initial tab), just append.
      if(typeof addTabBtnRef === 'undefined' || !addTabBtnRef || !addTabBtnRef.parentNode){
        outputTabsEl.appendChild(tabEl);
      } else {
        outputTabsEl.insertBefore(tabEl, addTabBtnRef);
      }
      const tabObj = {id, name, el:tabEl, preEl:pre};
      tabs.push(tabObj);
      activateTab(id);
      return tabObj;
    }
    function activateTab(id){
      tabs.forEach(t=>{
        t.el.classList.toggle('active', t.id===id);
        t.preEl.classList.toggle('active', t.id===id);
      });
      activeTab = tabs.find(t=>t.id===id) || null;
      // Reapply filters & clear search context for new active tab
      clearSearch();
      applyLineFilters();
    }
    function closeTab(id){
      if(tabs.length===1) return; // keep at least one
      const idx = tabs.findIndex(t=>t.id===id);
      if(idx<0) return;
      const tab = tabs[idx];
      tab.el.remove();
      tab.preEl.remove();
      tabs.splice(idx,1);
      if(activeTab && activeTab.id===id){
        const newIdx = Math.max(0, idx-1);
        activateTab(tabs[newIdx].id);
      }
    }
    // Add + button
    const addTabBtnRef = document.createElement('button');
    addTabBtnRef.id='addTabBtn';
    addTabBtnRef.type='button';
    addTabBtnRef.className='secondary';
    addTabBtnRef.textContent='+';
    addTabBtnRef.title='New output tab';
    addTabBtnRef.addEventListener('click', ()=>{
      createTab('Session '+(tabs.length+1));
    });
    outputTabsEl.appendChild(addTabBtnRef);
    // Initialize first tab
    createTab('Session 1');
    function getOutEl(){ return activeTab? activeTab.preEl : null; }
    function clearActiveOutput(){ const o=getOutEl(); if(o) o.textContent=''; }
    // Backwards compatibility variable referencing current output element
    function currentOutEl(){ return getOutEl(); }
    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');
  const clearInputBtn = document.getElementById('clearInputBtn');
    const streamToggle = document.getElementById('streamToggle');
    const wsToggle = document.getElementById('wsToggle');
  const loadBtn = document.getElementById('loadBtn');
  const localLoadBtn = document.getElementById('localLoadBtn');
  const localFileInput = document.getElementById('localFile');
    const filePathEl = document.getElementById('filePath');
    const fileStatus = document.getElementById('fileStatus');
    const fileProgress = document.getElementById('fileProgress');
    const fileProgressBar = document.getElementById('fileProgressBar');
  // Search elements
  // Assign previously declared search UI refs
  searchInput = document.getElementById('searchInput');
  searchPrev = document.getElementById('searchPrev');
  searchNext = document.getElementById('searchNext');
  searchClear = document.getElementById('searchClear');
  // Floating nav elements
  searchFloat = document.getElementById('searchFloat');
  sfPrev = document.getElementById('sfPrev');
  sfNext = document.getElementById('sfNext');
  sfClear = document.getElementById('sfClear');
  searchCount = document.getElementById('searchCount');

    // ---- Log classification & append (with cap) ----
    const maxLinesInput = document.getElementById('maxLinesInput');
    let maxLogLines = parseInt(maxLinesInput?.value,10) || 4000;
    if(maxLinesInput){
      maxLinesInput.addEventListener('change', ()=>{
        const v = parseInt(maxLinesInput.value,10);
        if(!isNaN(v) && v>0){
          maxLogLines = v;
          // Trim existing panes immediately
          tabs.forEach(t=>{
            const el = t.preEl; if(!el) return;
            while(el.childNodes.length > maxLogLines){ el.removeChild(el.firstChild); }
          });
        }
      });
    }
    function classify(line){
      const s = line.trimStart();
      if(s.startsWith('PROGRESS::')) return 'log-progress';
      if(s.startsWith('Error:')) return 'log-error';
      if(s.startsWith('#')) return 'log-comment';
      if(s.startsWith('Norm:')) return 'log-norm';
      if(s.startsWith('->')) return 'log-result';
      if(s.startsWith('Step')) return 'log-step';
      if(s.startsWith('Time:')) return 'log-time';
      if(s.startsWith('Name:')) return 'log-name';
      if(s.startsWith('Eval:')) return 'log-eval';
      if(s.startsWith('Macro')) return 'log-macro';
      if(s.startsWith('Test:')) {
        return s.includes("passed") ? 'log-alpha-pass' : s.includes("failed") ? 'log-alpha-fail' : 'log-alpha';
      }
      if(s.startsWith('Processing:')) return 'log-processing';
      if(s.startsWith(':')) return 'log-command';
      if(s.includes('Loading')) return 'log-loading';
      if(s.includes('<<')) return 'log-fileline';
      if(s.includes('>>')) return 'log-fileresult';
      return '';
    }
    function append(text){
      const outEl = currentOutEl();
      if(!outEl) return;
      const cls = classify(text);
      // If no explicit classification (other than maybe result/etc) and line has an inline '#', split & color comment.
      if(!text.trimStart().startsWith('#') && text.includes('#')){
        const hashIdx = text.indexOf('#');
        if(hashIdx > 0){
          const before = text.slice(0, hashIdx).replace(/\s+$/,'');
          const comment = text.slice(hashIdx); // include '#'
          const container = document.createElement('span');
          if(cls) container.className = cls; // preserve any existing class (e.g., log-result)
          const beforeNode = document.createTextNode(before + ' ');
          const commentSpan = document.createElement('span');
          commentSpan.className = 'log-comment';
          commentSpan.textContent = comment;
          container.appendChild(beforeNode);
          container.appendChild(commentSpan);
          container.appendChild(document.createTextNode('\n'));
          if(isFilteredSpan(container)) container.classList.add('hidden-log');
          outEl.appendChild(container);
        } else {
          const span = document.createElement('span');
          if(cls) span.className = cls;
          span.textContent = text + '\n';
          if(isFilteredSpan(span)) span.classList.add('hidden-log');
          outEl.appendChild(span);
        }
      } else {
        const span = document.createElement('span');
        if(cls) span.className = cls;
        span.textContent = text + '\n';
        if(isFilteredSpan(span)) span.classList.add('hidden-log');
        outEl.appendChild(span);
      }
      // Cap total lines by counting spans (one per line now)
      if(outEl.childNodes.length > maxLogLines){
        while(outEl.childNodes.length > maxLogLines){ outEl.removeChild(outEl.firstChild); }
      }
      outEl.scrollTop = outEl.scrollHeight;
    }
    // ---- Scroll navigation buttons ----
    const scrollTopBtn = document.getElementById('scrollTopBtn');
    const scrollBottomBtn = document.getElementById('scrollBottomBtn');
    function scrollToTop(){ window.scrollTo({top:0, behavior:'smooth'}); }
    function scrollToBottom(){ window.scrollTo({top:document.documentElement.scrollHeight, behavior:'smooth'}); }
    scrollTopBtn.addEventListener('click', scrollToTop);
    scrollBottomBtn.addEventListener('click', scrollToBottom);
    function updateScrollNav(){
      const y = window.scrollY || document.documentElement.scrollTop;
      const max = document.documentElement.scrollHeight - window.innerHeight;
      // Hide top button if near top, bottom button if near bottom
      scrollTopBtn.style.display = y > 40 ? 'inline-block' : 'none';
      scrollBottomBtn.style.display = (max - y) > 40 ? 'inline-block' : 'none';
    }
    window.addEventListener('scroll', updateScrollNav, {passive:true});
    window.addEventListener('resize', updateScrollNav);
    updateScrollNav();
    // Append a user-entered input line (" > expr # comment") with inline comment highlighting
    function appendUserInputLine(raw){
      const outEl = currentOutEl();
      if(!outEl) return;
      // Don't color lines that are pure comments (handled by append) or commands starting with ':'
      if(!raw || raw.trimStart().startsWith('#')){ append(raw); return; }
      const container = document.createElement('span');
      // Split on first unescaped '#'
      const idx = raw.indexOf('#');
      if(idx >= 0){
        const before = raw.slice(0, idx).replace(/\s+$/,'');
        const comment = raw.slice(idx); // include '#'
        container.textContent = '> ' + before + ' ';
        const commentSpan = document.createElement('span');
        commentSpan.className = 'log-comment';
        commentSpan.textContent = comment;
        container.appendChild(commentSpan);
        container.appendChild(document.createTextNode('\n'));
      } else {
        container.textContent = '> ' + raw + '\n';
      }
      outEl.appendChild(container);
      if(outEl.childNodes.length > maxLogLines){
        while(outEl.childNodes.length > maxLogLines){ outEl.removeChild(outEl.firstChild); }
      }
      outEl.scrollTop = outEl.scrollHeight;
    }

    // ---- Streaming (SSE / WebSocket) ----
    let es=null, ws=null; let streaming=false, useWS=false;
    function handleProgress(pct){
      fileProgress.style.display='block';
      fileProgressBar.style.width=pct+'%';
      if(pct>=100) setTimeout(()=>{ fileProgress.style.display='none'; fileProgressBar.style.width='0%'; },1200);
    }
    function ensureStream(){
      if(!streaming) return;
      if(useWS){
        if(ws && ws.readyState===WebSocket.OPEN) return;
        if(ws) { try{ ws.close(); }catch{} ws=null; }
  ws = new WebSocket(__cacheBust((location.protocol==='https:'?'wss':'ws')+'://'+location.host+'/ws'));
        ws.onmessage = ev => {
          const d = ev.data;
            if(typeof d==='string'){
              if(d.startsWith('PROGRESS::')) handleProgress(parseInt(d.split('::')[1]||'0',10)); else append(d);
            }
        };
        ws.onclose = ()=>{ if(streaming && useWS) setTimeout(ensureStream, 1200); };
        ws.onerror = ()=>{ try{ ws.close(); }catch{} if(streaming && useWS) setTimeout(ensureStream,1200); };
      } else {
        if(es) return;
  es = new EventSource(__cacheBust('/api/stream'));
        es.onmessage = e => {
          if(e.data && e.data!=='.'){
            if(e.data.startsWith('PROGRESS::')) handleProgress(parseInt(e.data.split('::')[1]||'0',10)); else append(e.data);
          }
        };
        es.onerror = ()=>{ es.close(); es=null; if(streaming && !useWS) setTimeout(ensureStream,1500); };
      }
    }
    streamToggle.addEventListener('click',()=>{
      streaming = !streaming;
      streamToggle.dataset.on = streaming ? '1':'0';
      streamToggle.textContent = 'Streaming: ' + (streaming?'On':'Off');
      if(streaming){ ensureStream(); append('[streaming enabled via '+(useWS?'WebSocket':'SSE')+']'); }
      else { if(es){ es.close(); es=null; } if(ws){ ws.close(); ws=null; } append('[streaming disabled]'); }
    });
    wsToggle.addEventListener('click',()=>{
      useWS = !useWS;
      wsToggle.dataset.on = useWS ? '1':'0';
      wsToggle.textContent = 'WS: ' + (useWS?'On':'Off');
      if(streaming){ if(es){ es.close(); es=null; } if(ws){ try{ ws.close(); }catch{} ws=null; } ensureStream(); append('[switched to '+(useWS?'WebSocket':'SSE')+']'); }
    });

    // ---- Evaluation ----
    async function doEval(){
      // Split into raw lines, then merge lines ending with an unescaped backslash (\\) as continuations
      const rawLines = exprEl.value.split(/\r?\n/);
      const merged = [];
      let buffer = '';
      for(let i=0;i<rawLines.length;i++){
        let line = rawLines[i];
        const continued = /(^|[^\\])\\$/.test(line); // backslash at end not escaped by another backslash
        if(continued){
          line = line.replace(/\\$/,'');
          buffer += line;
          continue; // accumulate
        } else {
          buffer += line;
          const finalLine = buffer.trim();
          if(finalLine.length) merged.push(finalLine);
          buffer='';
        }
      }
      if(buffer.trim().length){ merged.push(buffer.trim()); }
      const lines = merged.filter(l=>l.length>0);
      if(lines.length === 0) return;
      runBtn.disabled = true;
      try {
        for(const raw of lines) {
          const res = await evalExpr(raw);
          appendUserInputLine(raw);
          if(!streaming){
            if(Array.isArray(res.logs) && res.logs.length) res.logs.forEach(l=>append(l));
            const primary = res.output || res.normalized || '(no output)';
            const logsArray = Array.isArray(res.logs) ? res.logs : [];
            const hasResultLine = logsArray.some(l=> l.startsWith('-> '));
            // Only append primary / normalized if not already represented in logs
            if(!hasResultLine && (!logsArray.includes(primary))) append(primary);
            let appendedNorm = false;
            if(res.normalized && res.normalized !== primary){
              const alreadyLogged = logsArray.some(l=> l.trim() === res.normalized.trim() || l.trim() === ('Norm: '+res.normalized).trim());
              if(!alreadyLogged){ append('Norm: ' + res.normalized); appendedNorm = true; }
            }
            if(appendedNorm) append('');
          } else {
            // streaming: only final outputs (logs already streamed)
            const primary = res.output || res.normalized || '(no output)';
            append(primary);
            let appendedNorm = false;
            if(res.normalized && res.normalized !== primary){ append(res.normalized); appendedNorm = true; }
            if(appendedNorm) append('');
          }
        }
      } catch(e){ append(`ERR: ${e.message}`); }
      finally { runBtn.disabled=false; }
  // --- History: push each evaluated line (after successful attempt or error) ---
  try { lines.forEach(l=> pushHistory(l)); } catch { /* ignore */ }
    }

    // ---- Continuation hint (live) ----
    function updateContinuationHint(){
      const v = exprEl.value;
      const lines = v.split(/\r?\n/);
      const last = lines[lines.length-1];
      const active = /(^|[^\\])\\$/.test(last || '');
      document.getElementById('contHint').classList.toggle('active', active);
    }
  updateContinuationHint();
  runBtn.addEventListener('click', doEval);
    // --- Search ---
  // (searchHits/searchIndex declared earlier to satisfy tab activation sequencing)
    function clearSearch(){
      searchHits.forEach(el=> el.classList.remove('search-hit','search-current'));
      searchHits=[]; searchIndex=-1; updateSearchFloat();
    }
    function performSearch(){
      clearSearch();
      const term = searchInput.value.trim();
      if(!term){ updateSearchFloat(); return; }
      let rx;
      try { rx = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),'i'); } catch { return; }
  const outEl = currentOutEl();
  if(outEl) outEl.querySelectorAll('span').forEach(s=>{ if(rx.test(s.textContent)){ s.classList.add('search-hit'); searchHits.push(s); } });
      if(searchHits.length){ searchIndex=0; focusSearch(); }
      updateSearchFloat();
    }
    function focusSearch(){
      searchHits.forEach(el=> el.classList.remove('search-current'));
      if(searchIndex>=0 && searchIndex<searchHits.length){
        const el = searchHits[searchIndex];
        el.classList.add('search-current');
        el.scrollIntoView({block:'center'});
      }
      updateSearchFloat();
    }
    function updateSearchFloat(){
      if(!searchFloat) return;
      const termActive = !!(searchInput && searchInput.value.trim().length);
      if(termActive){
        searchFloat.style.display='flex';
        if(searchHits.length){
          searchCount.textContent = (searchIndex>=0? (searchIndex+1):0) + '/' + searchHits.length;
        } else {
          searchCount.textContent = '0/0';
        }
        searchFloat.setAttribute('aria-hidden','false');
      } else {
        searchFloat.style.display='none';
        searchFloat.setAttribute('aria-hidden','true');
      }
    }
    searchInput?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ performSearch(); } });
    function nextHit(){ if(!searchHits.length) performSearch(); else { searchIndex=(searchIndex+1)%searchHits.length; focusSearch(); } }
    function prevHit(){ if(!searchHits.length) performSearch(); else { searchIndex=(searchIndex-1+searchHits.length)%searchHits.length; focusSearch(); } }
    searchNext?.addEventListener('click', nextHit);
    searchPrev?.addEventListener('click', prevHit);
    searchClear?.addEventListener('click',()=>{ searchInput.value=''; clearSearch(); });
    sfNext?.addEventListener('click', nextHit);
    sfPrev?.addEventListener('click', prevHit);
    sfClear?.addEventListener('click',()=>{ searchInput.value=''; clearSearch(); });
    // Keyboard shortcuts: / focus, F3/Enter next, Shift+F3 previous, n/N for next/prev when not in input, Esc clears
    document.addEventListener('keydown', e=>{
      const active = document.activeElement;
      const inEditable = active && (active.tagName==='INPUT' || active.tagName==='TEXTAREA');
      if(e.key==='/' && !inEditable){ e.preventDefault(); searchInput.focus(); }
      else if(e.key==='F3'){ e.preventDefault(); if(e.shiftKey) prevHit(); else nextHit(); }
      else if(e.key==='Enter' && active===searchInput){ e.preventDefault(); nextHit(); }
      else if((e.key==='n' || e.key==='N') && !inEditable){ e.preventDefault(); e.key==='n'? nextHit(): prevHit(); }
      else if(e.key==='Escape'){ if(searchHits.length){ clearSearch(); } }
    });
    // Placeholder hint update
    if(searchInput) searchInput.placeholder = 'Search (/ F3 n/N)';
    // Add search highlight styles dynamically
    (function(){ const style=document.createElement('style'); style.textContent='.search-hit{background:#1f2a33; border-radius:3px;} .search-current{outline:1px solid var(--accent);}'; document.head.appendChild(style); })();
    // --- Simple Filters (Macro, Test, Time, Step, Processing) ---
    const FILTER_CONFIG = [
      {label:'Macro', classes:['log-macro']},
      {label:'Test', classes:['log-alpha','log-alpha-pass','log-alpha-fail']},
      {label:'Time', classes:['log-time']},
      {label:'Step', classes:['log-step']},
      {label:'Eval', classes:['log-eval']},
      {label:'Norm', classes:['log-norm']},
      {label:'Name', classes:['log-name']},
      {label:'Processing', classes:['log-processing']}
    ];
    let disabledGroups = new Set(); // start with all enabled
    // Determine if a span should be hidden based on ANY of its classes
    function isFilteredSpan(el){
      for(const g of FILTER_CONFIG){
        if(disabledGroups.has(g.label)){
          // If element has any class belonging to this disabled group -> hide
            for(const cls of g.classes){ if(el.classList.contains(cls)) return true; }
        }
      }
      return false;
    }
    function renderFilters(){
      const host=document.getElementById('filters'); if(!host) return; host.innerHTML='';
      FILTER_CONFIG.forEach(g=>{
        const id='f_'+g.label.toLowerCase();
        const lab=document.createElement('label');
        const cb=document.createElement('input'); cb.type='checkbox'; cb.id=id; cb.checked=!disabledGroups.has(g.label);
        cb.addEventListener('change',()=>{ if(cb.checked) disabledGroups.delete(g.label); else disabledGroups.add(g.label); applyLineFilters(); });
        lab.appendChild(cb); lab.appendChild(document.createTextNode(g.label)); host.appendChild(lab);
      });
    }
    function applyLineFilters(){
  const outEl = currentOutEl();
  if(!outEl) return;
  outEl.querySelectorAll('span').forEach(s=>{
        if(isFilteredSpan(s)) s.classList.add('hidden-log'); else s.classList.remove('hidden-log');
      });
    }
    renderFilters();
    // --- History navigation (Up/Down at boundaries) ---
    // Per-tab history helpers
    const HISTORY_KEY_PREFIX = 'lambdaHistoryTab_';
    function loadHistory(tab){
      try { const k = HISTORY_KEY_PREFIX+tab.id; const arr = JSON.parse(localStorage.getItem(k)||'[]'); if(Array.isArray(arr)) { tab.history = arr; tab.histIndex = arr.length; } } catch { }
    }
    function saveHistory(tab){ try { localStorage.setItem(HISTORY_KEY_PREFIX+tab.id, JSON.stringify(tab.history.slice(-400))); } catch { }
    }
    function pushHistory(entry){
      if(!activeInput) return;
      if(!entry || !entry.trim()) return;
      if(activeInput.history[activeInput.history.length-1] === entry) return;
      activeInput.history.push(entry);
      activeInput.histIndex = activeInput.history.length;
      saveHistory(activeInput);
    }
    function handleHistoryNav(e){
      if(!activeInput) return;
      const ta = activeInput.taEl;
      if(e.key === 'ArrowUp' && ta.selectionStart===0 && ta.selectionEnd===0){
        if(activeInput.histIndex > 0){ activeInput.histIndex--; ta.value = activeInput.history[activeInput.histIndex] || ''; updateContinuationHint(); e.preventDefault(); }
      } else if(e.key === 'ArrowDown' && ta.selectionStart===ta.value.length && ta.selectionEnd===ta.value.length){
        if(activeInput.histIndex < activeInput.history.length-1){ activeInput.histIndex++; ta.value = activeInput.history[activeInput.histIndex] || ''; updateContinuationHint(); e.preventDefault(); }
        else if(activeInput.histIndex === activeInput.history.length-1){ activeInput.histIndex = activeInput.history.length; ta.value=''; updateContinuationHint(); e.preventDefault(); }
      }
    }
  clearBtn.addEventListener('click', ()=>{ clearActiveOutput(); });
  clearInputBtn.addEventListener('click', ()=>{ if(exprEl){ exprEl.value=''; updateContinuationHint(); exprEl.focus(); } });
    loadBtn.addEventListener('click', async ()=>{
      const p = filePathEl.value.trim(); if(!p) return;
      fileStatus.textContent='Loading...';
      if(streaming){ fileProgress.style.display='block'; fileProgressBar.style.width='0%'; }
      try {
        const r = await loadFile(p);
        fileStatus.textContent = 'Loaded: ' + r.message;
        if(!streaming && r.logs && Array.isArray(r.logs) && r.logs.length){ r.logs.forEach(l=>append(l)); append(''); }
      } catch(e){ fileStatus.textContent = 'Error: ' + e.message; }
    });
    // ---- Local file loading (.lambda) ----
    localLoadBtn?.addEventListener('click', ()=> localFileInput?.click());
    localFileInput?.addEventListener('change', ()=>{
      const f = localFileInput.files?.[0];
      if(!f) return;
      loadLocalLambdaFile(f);
      // reset input so selecting same file again re-triggers
      localFileInput.value='';
    });
    async function loadLocalLambdaFile(file){
      fileStatus.textContent = `Local: ${file.name} (reading...)`;
      try {
        const text = await file.text();
        const rawLines = text.split(/\r?\n/);
        // Simple filtering: keep lines, preserve blank lines for counting but skip evaluating blanks/comments
        const toEval = rawLines.map(l=>l.trim()).filter(l=> l.length && !l.startsWith('#'));
        if(!toEval.length){ fileStatus.textContent = `Local: ${file.name} (no expressions found)`; return; }
        append(`[local load start: ${file.name} expressions=${toEval.length}]`);
        // Show progress bar even if not streaming for user feedback
        fileProgress.style.display='block'; fileProgressBar.style.width='0%';
        for(let i=0;i<toEval.length;i++){
          const expr = toEval[i];
          try {
            const res = await evalExpr(expr);
            appendUserInputLine(expr);
            if(!streaming){
              if(Array.isArray(res.logs) && res.logs.length) res.logs.forEach(l=>append(l));
              const primary = res.output || res.normalized || '(no output)';
              const logsArray = Array.isArray(res.logs)? res.logs:[];
              const hasResultLine = logsArray.some(l=> l.startsWith('-> '));
              if(!hasResultLine && (!logsArray.includes(primary))) append(primary);
              let appendedNorm = false;
              if(res.normalized && res.normalized !== primary){
                const alreadyLogged = logsArray.some(l=> l.trim() === res.normalized.trim() || l.trim() === ('Norm: '+res.normalized).trim());
                if(!alreadyLogged){ append('Norm: ' + res.normalized); appendedNorm = true; }
              }
              if(appendedNorm) append('');
            } else {
              const primary = res.output || res.normalized || '(no output)';
              append(primary);
              let appendedNorm = false;
              if(res.normalized && res.normalized !== primary){ append(res.normalized); appendedNorm = true; }
              if(appendedNorm) append('');
            }
          } catch(err){
            append(`ERR: ${err.message}`);
          }
          const pct = Math.round(((i+1)/toEval.length)*100);
          fileProgressBar.style.width = pct + '%';
        }
        setTimeout(()=>{ fileProgress.style.display='none'; fileProgressBar.style.width='0%'; }, 900);
        fileStatus.textContent = `Local: ${file.name} loaded (${toEval.length} expressions)`;
        append(`[local load done: ${file.name}]`);
      } catch(e){
        fileStatus.textContent = `Local load error: ${e.message}`;
      }
    }

    // ---- Health + auto-init ----
  fetch(__cacheBust('/api/health'), {cache:'no-store'}).then(r=>r.ok?document.getElementById('health').textContent='ready':null).catch(()=>{});
  if(location.hash.includes('stream')) streamToggle.click();

  // ---- Theme handling ----
  (function(){
    const sel = document.getElementById('themeSel');
    const key='lambdaTheme';
    function apply(t){ document.body.setAttribute('data-theme', t); try{ localStorage.setItem(key,t);}catch{} }
    const saved = (function(){ try{return localStorage.getItem(key);}catch{return null;} })();
    if(saved && sel.querySelector(`option[value="${saved}"]`)){ sel.value=saved; apply(saved); }
    sel.addEventListener('change', ()=> apply(sel.value));
  })();
  </script>
</body>
</html>
