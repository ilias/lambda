<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lambda Calculus Interpreter UI</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0d1117; --panel:#161b22; --border:#30363d; --accent:#58a6ff; --text:#c9d1d9; --bad:#ff6b6b; --good:#3fb950; }
    body { font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; background:var(--bg); color:var(--text); margin:0; }
    header { padding:1rem 1.5rem; background:var(--panel); border-bottom:1px solid var(--border); }
  main { max-width:1400px; margin:0 auto; padding:1.25rem; display:grid; gap:1rem; grid-template-columns: 1fr 1fr; }
    section { background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:1rem 1.25rem; display:flex; flex-direction:column; }
    h1 { margin:0; font-size:1.25rem; }
    textarea, input[type=text] { background:#0f141a; color:var(--text); border:1px solid var(--border); border-radius:6px; padding:.6rem .7rem; font-family:ui-monospace,Consolas,monospace; font-size:.95rem; resize:vertical; }
    textarea:focus, input:focus { outline:1px solid var(--accent); }
    button { cursor:pointer; border:1px solid var(--accent); background:var(--accent); color:#fff; border-radius:6px; padding:.55rem .9rem; font-size:.9rem; font-weight:600; display:inline-flex; gap:.4rem; align-items:center; }
    button.secondary { background:transparent; color:var(--accent); }
    button:disabled { opacity:.5; cursor:default; }
    pre { background:#0f141a; border:1px solid var(--border); border-radius:6px; padding:.75rem; overflow:auto; font-size:.85rem; line-height:1.3; }
    code { font-family:ui-monospace,Consolas,monospace; }
    footer { text-align:center; padding:1rem; font-size:.75rem; opacity:.7; }
    .actions { display:flex; gap:.5rem; flex-wrap:wrap; margin-top:.5rem; }
    label { font-size:.75rem; font-weight:600; text-transform:uppercase; letter-spacing:.06em; margin-bottom:.25rem; opacity:.85; }
    .small { font-size:.7rem; opacity:.7; }
    .split { display:flex; gap:.75rem; }
    .status { font-size:.75rem; letter-spacing:.05em; text-transform:uppercase; font-weight:600; }
    .bad { color:var(--bad); }
    .good { color:var(--good); }
  .full-span { grid-column:1 / -1; }
  #output { width:100%; max-width:100%; box-sizing:border-box; white-space:pre-wrap; word-break:break-word; overflow-wrap:anywhere; }
  .cont-hint { font-size:.65rem; letter-spacing:.05em; text-transform:uppercase; margin-top:.35rem; color:#e3b341; display:none; font-weight:600; }
  .cont-hint.active { display:block; }
  @media (max-width: 960px) { main { grid-template-columns:1fr; } #output { width:100%; } }
    /* Log color classes */
    .log-error{color:#ff6b6b;}
    .log-comment{color:#e3b341;}
    .log-result{color:var(--good);}
    .log-step{color:#e3b341;}
    .log-time{color:#58a6ff;}
    .log-name{color:#58a6ff;}
    .log-eval{color:#d2a8ff;}
    .log-macro{color:#58a6ff;}
    .log-test{color:#d2a8ff;}
    .log-test-pass{color:var(--good);}
    .log-test-fail{color:#ff6b6b;}
    .log-command{color:#ff7b72;}
    .log-loading{color:#76e3ea;}
    .log-fileline{color:#8b949e;}
    .log-fileresult{color:var(--good);}
    .log-progress{color:#58a6ff; opacity:.7;}
  .log-processing{color:#8b949e;}
  /* Simple filters */
  #filters { display:flex; flex-wrap:wrap; gap:.5rem; margin:.4rem 0 .3rem; }
  #filters label { font-size:.55rem; letter-spacing:.08em; text-transform:uppercase; font-weight:600; display:flex; gap:.25rem; align-items:center; background:#0f141a; padding:.25rem .45rem; border:1px solid var(--border); border-radius:4px; cursor:pointer; }
  #filters input { margin:0; }
  .hidden-log { display:none !important; }
  </style>
</head>
<body>
  <header><h1>Lambda Calculus Interpreter</h1></header>
  <main>
    <section id="repl">
      <label for="expr">Expression / Commands</label>
      <textarea id="expr" rows="8" placeholder=":help or succ 41 or let add = x,y -> x + y in add 2 3"></textarea>
  <div id="contHint" class="cont-hint" aria-live="polite">Continuation: line will join with next</div>
      <div class="actions">
        <button id="runBtn">Evaluate (Ctrl+Enter)</button>
        <button class="secondary" id="clearBtn" type="button">Clear Output</button>
  <button class="secondary" id="clearInputBtn" type="button">Clear Input</button>
        <button class="secondary" id="loadStdBtn" type="button">Reload stdlib</button>
        <button class="secondary" id="streamToggle" type="button" data-on="0">Streaming: Off</button>
        <button class="secondary" id="wsToggle" type="button" data-on="0">WS: Off</button>
      </div>
  <div class="small">Multiple expressions separated by semicolons are processed sequentially. Each line is evaluated independently.</div>
    </section>
    <section>
      <label for="filePath">Load .lambda File</label>
      <div class="split">
        <input type="text" id="filePath" placeholder="path e.g. stdlib.lambda" />
        <button id="loadBtn" type="button">Load</button>
      </div>
      <div id="fileStatus" class="status" style="margin-top:.5rem;">Idle</div>
      <div id="fileProgress" style="margin-top:.4rem;height:6px;background:#222;border:1px solid var(--border);border-radius:4px;overflow:hidden;display:none;">
        <div id="fileProgressBar" style="height:100%;width:0;background:var(--accent);transition:width .25s;"></div>
      </div>
      <hr style="margin:1rem 0; border:0; border-top:1px solid var(--border);" />
      <h3 style="margin-top:0;">Quick Examples</h3>
      <ul style="margin:.25rem 0 0 1.1rem; padding:0; font-size:.8rem; line-height:1.4;">
        <li>succ 5</li><li>let inc = x -> succ x in inc 41</li><li>[1,2,3]</li><li>let rec fact = n -> if (iszero n) 1 (mult n (fact (pred n))) in fact 5</li>
      </ul>
    </section>
    <section class="full-span" aria-label="Result Log">
      <div style="display:flex; flex-wrap:wrap; gap:.75rem; align-items:flex-end; justify-content:space-between;">
        <label for="output" style="font-size:.75rem;font-weight:600;text-transform:uppercase;letter-spacing:.06em;opacity:.85;">Result / Log</label>
        <div id="searchBox" style="display:flex; gap:.4rem; align-items:center; font-size:.65rem;">
          <input id="searchInput" type="text" placeholder="Search" style="width:140px; font-size:.65rem; padding:.4rem .5rem;" />
          <button class="secondary" id="searchPrev" type="button" style="font-size:.6rem; padding:.35rem .5rem;">Prev</button>
          <button class="secondary" id="searchNext" type="button" style="font-size:.6rem; padding:.35rem .5rem;">Next</button>
          <button class="secondary" id="searchClear" type="button" style="font-size:.6rem; padding:.35rem .5rem;">Clear</button>
        </div>
      </div>
  <div id="filters"></div>
      <pre id="output" aria-live="polite"></pre>
    </section>
  </main>
  <footer>Lambda Calculus Interpreter UI â€¢ <span id="health">checking...</span></footer>
  <script>
    // ---- API helpers ----
    async function evalExpr(expr){
      const r = await fetch(`/api/eval?expr=${encodeURIComponent(expr)}`);
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }
    async function loadFile(p){
      const r = await fetch('/api/load',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({path:p})});
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }

    // ---- Elements ----
    const exprEl = document.getElementById('expr');
    const outEl = document.getElementById('output');
    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');
  const clearInputBtn = document.getElementById('clearInputBtn');
    const loadStdBtn = document.getElementById('loadStdBtn');
    const streamToggle = document.getElementById('streamToggle');
    const wsToggle = document.getElementById('wsToggle');
    const loadBtn = document.getElementById('loadBtn');
    const filePathEl = document.getElementById('filePath');
    const fileStatus = document.getElementById('fileStatus');
    const fileProgress = document.getElementById('fileProgress');
    const fileProgressBar = document.getElementById('fileProgressBar');
  // Search elements
  const searchInput = document.getElementById('searchInput');
  const searchPrev = document.getElementById('searchPrev');
  const searchNext = document.getElementById('searchNext');
  const searchClear = document.getElementById('searchClear');

    // ---- Log classification & append (with cap) ----
    const MAX_LOG_LINES = 4000;
    function classify(line){
      if(line.startsWith('PROGRESS::')) return 'log-progress';
      if(line.startsWith('Error:')) return 'log-error';
      if(line.startsWith('#')) return 'log-comment';
      if(line.startsWith('->')) return 'log-result';
      if(line.startsWith('Step')) return 'log-step';
      if(line.startsWith('Time:')) return 'log-time';
      if(line.startsWith('Name:')) return 'log-name';
      if(line.startsWith('Eval:')) return 'log-eval';
      if(line.startsWith('Macro')) return 'log-macro';
      if(line.startsWith('Test: passed')) return 'log-test-pass';
      if(line.startsWith('Test: failed')) return 'log-test-fail';
      if(line.startsWith('Test:')) return 'log-test';
  if(line.startsWith('Processing:')) return 'log-processing';
      if(line.startsWith(':')) return 'log-command';
      if(line.includes('Loading')) return 'log-loading';
      if(line.includes('<<')) return 'log-fileline';
      if(line.includes('>>')) return 'log-fileresult';
      return '';
    }
    function append(text){
      const cls = classify(text);
      const span = document.createElement('span');
      if(cls) span.className = cls;
      span.textContent = text;
  // Apply simple filter visibility
  if(cls && isFilteredClass(cls)) span.classList.add('hidden-log');
      outEl.appendChild(span);
      outEl.appendChild(document.createTextNode('\n'));
      const maxNodes = MAX_LOG_LINES * 2;
      if(outEl.childNodes.length > maxNodes){
        while(outEl.childNodes.length > maxNodes){ outEl.removeChild(outEl.firstChild); }
      }
      outEl.scrollTop = outEl.scrollHeight;
    }

    // ---- Streaming (SSE / WebSocket) ----
    let es=null, ws=null; let streaming=false, useWS=false;
    function handleProgress(pct){
      fileProgress.style.display='block';
      fileProgressBar.style.width=pct+'%';
      if(pct>=100) setTimeout(()=>{ fileProgress.style.display='none'; fileProgressBar.style.width='0%'; },1200);
    }
    function ensureStream(){
      if(!streaming) return;
      if(useWS){
        if(ws && ws.readyState===WebSocket.OPEN) return;
        if(ws) { try{ ws.close(); }catch{} ws=null; }
        ws = new WebSocket((location.protocol==='https:'?'wss':'ws')+'://'+location.host+'/ws');
        ws.onmessage = ev => {
          const d = ev.data;
            if(typeof d==='string'){
              if(d.startsWith('PROGRESS::')) handleProgress(parseInt(d.split('::')[1]||'0',10)); else append(d);
            }
        };
        ws.onclose = ()=>{ if(streaming && useWS) setTimeout(ensureStream, 1200); };
        ws.onerror = ()=>{ try{ ws.close(); }catch{} if(streaming && useWS) setTimeout(ensureStream,1200); };
      } else {
        if(es) return;
        es = new EventSource('/api/stream');
        es.onmessage = e => {
          if(e.data && e.data!=='.'){
            if(e.data.startsWith('PROGRESS::')) handleProgress(parseInt(e.data.split('::')[1]||'0',10)); else append(e.data);
          }
        };
        es.onerror = ()=>{ es.close(); es=null; if(streaming && !useWS) setTimeout(ensureStream,1500); };
      }
    }
    streamToggle.addEventListener('click',()=>{
      streaming = !streaming;
      streamToggle.dataset.on = streaming ? '1':'0';
      streamToggle.textContent = 'Streaming: ' + (streaming?'On':'Off');
      if(streaming){ ensureStream(); append('[streaming enabled via '+(useWS?'WebSocket':'SSE')+']'); }
      else { if(es){ es.close(); es=null; } if(ws){ ws.close(); ws=null; } append('[streaming disabled]'); }
    });
    wsToggle.addEventListener('click',()=>{
      useWS = !useWS;
      wsToggle.dataset.on = useWS ? '1':'0';
      wsToggle.textContent = 'WS: ' + (useWS?'On':'Off');
      if(streaming){ if(es){ es.close(); es=null; } if(ws){ try{ ws.close(); }catch{} ws=null; } ensureStream(); append('[switched to '+(useWS?'WebSocket':'SSE')+']'); }
    });

    // ---- Evaluation ----
    async function doEval(){
      // Split into raw lines, then merge lines ending with an unescaped backslash (\\) as continuations
      const rawLines = exprEl.value.split(/\r?\n/);
      const merged = [];
      let buffer = '';
      for(let i=0;i<rawLines.length;i++){
        let line = rawLines[i];
        const continued = /(^|[^\\])\\$/.test(line); // backslash at end not escaped by another backslash
        if(continued){
          line = line.replace(/\\$/,'');
          buffer += line;
          continue; // accumulate
        } else {
          buffer += line;
          const finalLine = buffer.trim();
          if(finalLine.length) merged.push(finalLine);
          buffer='';
        }
      }
      if(buffer.trim().length){ merged.push(buffer.trim()); }
      const lines = merged.filter(l=>l.length>0);
      if(lines.length === 0) return;
      runBtn.disabled = true;
      try {
        for(const raw of lines) {
          const res = await evalExpr(raw);
          append(`> ${raw}`);
          if(!streaming){
            if(Array.isArray(res.logs) && res.logs.length) res.logs.forEach(l=>append(l));
            const primary = res.output || res.normalized || '(no output)';
            const logsArray = Array.isArray(res.logs) ? res.logs : [];
            const hasResultLine = logsArray.some(l=> l.startsWith('-> '));
            // Only append primary / normalized if not already represented in logs
            if(!hasResultLine && (!logsArray.includes(primary))) append(primary);
            if(res.normalized && res.normalized !== primary && !logsArray.includes(res.normalized) && !logsArray.some(l=> l.trim() === res.normalized.trim())) {
              append(res.normalized);
            }
          } else {
            // streaming: only final outputs (logs already streamed)
            const primary = res.output || res.normalized || '(no output)';
            append(primary);
            if(res.normalized && res.normalized !== primary) append(res.normalized);
          }
          append('');
        }
      } catch(e){ append(`ERR: ${e.message}`); }
      finally { runBtn.disabled=false; }
  // --- History: push each evaluated line (after successful attempt or error) ---
  try { lines.forEach(l=> pushHistory(l)); } catch { /* ignore */ }
    }

    // ---- Continuation hint (live) ----
    function updateContinuationHint(){
      const v = exprEl.value;
      const lines = v.split(/\r?\n/);
      const last = lines[lines.length-1];
      const active = /(^|[^\\])\\$/.test(last || '');
      document.getElementById('contHint').classList.toggle('active', active);
    }
    exprEl.addEventListener('input', updateContinuationHint);
    exprEl.addEventListener('keyup', updateContinuationHint);
    updateContinuationHint();

    runBtn.addEventListener('click', doEval);
    exprEl.addEventListener('keydown', e=>{ if(e.key==='Enter' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); doEval(); }});
    // --- Search ---
    let searchHits = [];
    let searchIndex = -1;
    function clearSearch(){
      searchHits.forEach(el=> el.classList.remove('search-hit','search-current'));
      searchHits=[]; searchIndex=-1;
    }
    function performSearch(){
      clearSearch();
      const term = searchInput.value.trim();
      if(!term) return;
      let rx;
      try { rx = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),'i'); } catch { return; }
      outEl.querySelectorAll('span').forEach(s=>{ if(rx.test(s.textContent)){ s.classList.add('search-hit'); searchHits.push(s); } });
      if(searchHits.length){ searchIndex=0; focusSearch(); }
    }
    function focusSearch(){
      searchHits.forEach(el=> el.classList.remove('search-current'));
      if(searchIndex>=0 && searchIndex<searchHits.length){
        const el = searchHits[searchIndex];
        el.classList.add('search-current');
        el.scrollIntoView({block:'center'});
      }
    }
    searchInput?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ performSearch(); } });
    searchNext?.addEventListener('click',()=>{ if(!searchHits.length) performSearch(); else { searchIndex=(searchIndex+1)%searchHits.length; focusSearch(); } });
    searchPrev?.addEventListener('click',()=>{ if(!searchHits.length) performSearch(); else { searchIndex=(searchIndex-1+searchHits.length)%searchHits.length; focusSearch(); } });
    searchClear?.addEventListener('click',()=>{ searchInput.value=''; clearSearch(); });
    // Add search highlight styles dynamically
    (function(){ const style=document.createElement('style'); style.textContent='.search-hit{background:#1f2a33; border-radius:3px;} .search-current{outline:1px solid var(--accent);}'; document.head.appendChild(style); })();
    // --- Simple Filters (Macro, Test, Time, Step, Processing) ---
    const FILTER_CONFIG = [
      {label:'Macro', classes:['log-macro']},
      {label:'Test', classes:['log-test','log-test-pass','log-test-fail']},
      {label:'Time', classes:['log-time']},
      {label:'Step', classes:['log-step']},
      {label:'Processing', classes:['log-processing']}
    ];
    let disabledGroups = new Set(); // start with all enabled
    function isFilteredClass(cls){
      for(const g of FILTER_CONFIG){ if(g.classes.includes(cls)) return disabledGroups.has(g.label); }
      return false;
    }
    function renderFilters(){
      const host=document.getElementById('filters'); if(!host) return; host.innerHTML='';
      FILTER_CONFIG.forEach(g=>{
        const id='f_'+g.label.toLowerCase();
        const lab=document.createElement('label');
        const cb=document.createElement('input'); cb.type='checkbox'; cb.id=id; cb.checked=!disabledGroups.has(g.label);
        cb.addEventListener('change',()=>{ if(cb.checked) disabledGroups.delete(g.label); else disabledGroups.add(g.label); applyLineFilters(); });
        lab.appendChild(cb); lab.appendChild(document.createTextNode(g.label)); host.appendChild(lab);
      });
    }
    function applyLineFilters(){
      outEl.querySelectorAll('span').forEach(s=>{
        const c=s.className; if(!c) return;
        if(isFilteredClass(c)) s.classList.add('hidden-log'); else s.classList.remove('hidden-log');
      });
    }
    renderFilters();
    // --- History navigation (Up/Down at boundaries) ---
    const HISTORY_KEY = 'lambdaHistory';
    let history = [];
    let histIndex = 0;
    function loadHistory(){
      try { history = JSON.parse(localStorage.getItem(HISTORY_KEY)||'[]'); if(!Array.isArray(history)) history=[]; } catch { history=[]; }
      histIndex = history.length;
    }
    function saveHistory(){ try { localStorage.setItem(HISTORY_KEY, JSON.stringify(history.slice(-500))); } catch { }
    }
    function pushHistory(entry){
      if(!entry || !entry.trim()) return;
      if(history[history.length-1] === entry) return; // avoid consecutive duplicate
      history.push(entry);
      histIndex = history.length;
      saveHistory();
    }
    loadHistory();
    exprEl.addEventListener('keydown', e=>{
      if(e.key === 'ArrowUp' && exprEl.selectionStart===0 && exprEl.selectionEnd===0){
        if(histIndex > 0){ histIndex--; exprEl.value = history[histIndex]; updateContinuationHint(); e.preventDefault(); }
      } else if(e.key === 'ArrowDown' && exprEl.selectionStart===exprEl.value.length && exprEl.selectionEnd===exprEl.value.length){
        if(histIndex < history.length-1){ histIndex++; exprEl.value = history[histIndex]; updateContinuationHint(); e.preventDefault(); }
        else if(histIndex === history.length-1){ histIndex = history.length; exprEl.value=''; updateContinuationHint(); e.preventDefault(); }
      }
    });
    clearBtn.addEventListener('click', ()=>{ outEl.textContent=''; });
  clearInputBtn.addEventListener('click', ()=>{ exprEl.value=''; updateContinuationHint(); exprEl.focus(); });
    loadStdBtn.addEventListener('click', ()=>{ filePathEl.value='stdlib.lambda'; loadBtn.click(); });
    loadBtn.addEventListener('click', async ()=>{
      const p = filePathEl.value.trim(); if(!p) return;
      fileStatus.textContent='Loading...';
      if(streaming){ fileProgress.style.display='block'; fileProgressBar.style.width='0%'; }
      try {
        const r = await loadFile(p);
        fileStatus.textContent = 'Loaded: ' + r.message;
        if(!streaming && r.logs && Array.isArray(r.logs) && r.logs.length){ r.logs.forEach(l=>append(l)); append(''); }
      } catch(e){ fileStatus.textContent = 'Error: ' + e.message; }
    });

    // ---- Health + auto-init ----
    fetch('/api/health').then(r=>r.ok?document.getElementById('health').textContent='ready':null).catch(()=>{});
    if(location.hash.includes('stream')) streamToggle.click();
  </script>
</body>
</html>
