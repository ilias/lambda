# ============================================================================
# Lambda Calculus Environment Export
# Generated: 2025-08-07 01:29:00
# Definitions: 236, Infix Operators: 16, Macros: 22
# ============================================================================

# =============================================================================
# INFIX OPERATORS
# =============================================================================

:infix . 9 right
:infix ^ 8 right
:infix * 7 left
:infix / 7 left
:infix % 7 left
:infix - 6 left
:infix + 6 left
:infix < 5 left
:infix <= 5 left
:infix > 5 left
:infix >= 5 left
:infix != 4 left
:infix == 4 left
:infix && 3 left
:infix || 2 left
:infix |> 1 left

# =============================================================================
# MACRO DEFINITIONS
# =============================================================================

:macro (apply_n $f $n $x) => times $n $f $x
:macro (apply_twice $f $x) => $f ($f $x)
:macro (assert $condition $value) => if $condition $value error
:macro (between $x $low $high) => and (geq $x $low) (leq $x $high)
:macro (compose $f $g $x) => $f ($g $x)
:macro (cube $x) => mult $x (mult $x $x)
:macro (dec $x) => pred $x
:macro (empty? $list) => isnil $list
:macro (first $list) => head $list
:macro (for $var at $list do $body) => map (λ$var.$body) $list
:macro (iff $p then $then else $else) => if $p $then $else
:macro (inc $x) => succ $x
:macro (letbind $var $val $expr) => (λ$var.$expr) $val
:macro (max2 $a $b) => if (geq $a $b) $a $b
:macro (min2 $a $b) => if (leq $a $b) $a $b
:macro (nand $a $b) => not (and $a $b)
:macro (nor $a $b) => not (or $a $b)
:macro (rest $list) => tail $list
:macro (square $x) => mult $x $x
:macro (test $expr $expected) => eq $expr $expected
:macro (unless $cond $expr) => if $cond I $expr
:macro (when $cond $expr) => if $cond $expr I

# =============================================================================
# VARIABLE DEFINITIONS
# =============================================================================

# Simple definitions and constants
unlines = intercalate (λf.λz.f 10 (0 f z))
unwords = intercalate (λf.λz.f 32 (0 f z))

# Function definitions
- = λm.λn.n pred m
!= = λm.λn.not (eq m n)
* = λm.λn.λf.m (n f)
/ = λm.λn.first (DIV_ITER 0 m n)
&& = λp.λq.p q false
% = λm.λn.second (DIV_ITER 0 m n)
+ = λm.λn.λf.λx.m f (n f x)
< = λm.λn.and (leq m n) (not (eq m n))
<= = λm.λn.iszero (minus m n)
== = λm.λn.and (leq m n) (leq n m)
> = λm.λn.not (leq m n)
>= = λm.λn.not (lt m n)
|| = [true]
abs = λn.n
ackermann = λp.p (λa.λq.a (q a 1)) succ
all = λp.λl.foldr (λx.λacc.and (p x) acc) true l
and = λp.λq.p q false
any = λp.λl.foldr (λx.λacc.or (p x) acc) false l
append = [cons]
apply = 1
B = λx.λy.λz.x (y z)
benchmark = λn.λf.λx.times n (λ_placeholder1.f x) x
bindState = λm.λf.λs.f (first (m s)) (second (m s))
bluebird = λx.λy.λz.x (y z)
break = λp.λl.foldl (λacc.λx.if (p x) acc (pair (cons x (first acc)) (second acc))) (pair [] l) l
C = λx.λy.λz.x z y
cardinal = λx.λy.λz.x z y
compose = λx.λy.λz.x (y z)
concat = λll.foldr append [] ll
cons = λx.λxs.λf.λz.f x (xs f z)
const = λx.λy.x
countdown = λn.Y (λf.λk.if (iszero k) ([0]) (cons k (f (pred k)))) n
countdownY = λn.Y (λf.λk.if (== k 0) ([0]) (cons k (f (- k 1)))) n
curry = λf.λx.λy.f (pair x y)
delay = λx.λf.f x
difference = λl1.λl2.filter (λx.notElem x l2) l1
div = λm.λn.first (DIV_ITER 0 m n)
double = λn.plus n n
drop = [tail]
either = λf.λg.λe.if (isLeft e) (f (fromLeft e)) (g (fromRight e))
elem = λx.λl.any (eq x) l
enumFrom = λstart.λn.map (plus start) (range n)
enumFromTo = λstart.λend.map (plus start) (range (succ (minus end start)))
eq = λm.λn.and (leq m n) (leq n m)
eqBool = λx.λy.x y (not y)
even = λn.eq (mod n 2) zero
fact = λn.second (FACT_ITER_HELPER n)
FACT_ITER_HELPER = λn.n (λp.pair (succ (first p)) (mult (succ (first p)) (second p))) (pair 0 1)
false = 0
fib = λn.first (FIB_ITER_HELPER n)
FIB_ITER_HELPER = λn.n (λp.pair (second p) (plus (first p) (second p))) (pair 0 1)
filter = λf.λl.l (λx.λrest.if (f x) (cons x rest) rest) []
find = λp.λl.foldl (λacc.λx.if (and (isnil acc) (p x)) x acc) [] l
first = λp.p (λx.λy.x)
flip = λx.λy.λz.x z y
foldl = λf.λz.λl.l (λx.λacc.f acc x) z
foldr = λf.λz.λl.l f z
force = λthunk.thunk I
fromJust = λp.p 0
fromLeft = λp.p 0
fromMaybe = λdef.λm.if (isNothing m) def (fromJust m)
fromRight = λp.p 0
GCD_STEP = λp.if (gt (first p) (second p)) (pair (minus (first p) (second p)) (second p)) (pair (first p) (minus (second p) (first p)))
gcd1 = λm.λn.if (or (iszero m) (iszero n)) (if (iszero m) n m) (first (WHILE (λp.neq (first p) (second p)) GCD_STEP (pair m n)))
geq = λm.λn.not (lt m n)
getChar = λl.l (λx.λxs.x) []
getLine = λl.filter (neq 10) l
getState = λs.pair s s
gt = λm.λn.not (leq m n)
half = λn.div n 2
head = λl.l (λx.λxs.x) []
I = λx.x
id = λx.x
if = λp.λa.λb.p a b
init = λl.reverse (tail (reverse l))
intercalate = λsep.λl.if (isnil l) [] (if (isnil (tail l)) (head l) (foldr (λx.λacc.if (isnil acc) x (append x (cons sep acc))) [] l))
intersect = λl1.λl2.filter (λx.elem x l2) l1
iota = λn.Y (λf.λk.if (eq k n) [] (cons k (f (succ k)))) 0
isalnum = λc.or (isalpha c) (isdigit c)
isalpha = λc.or (islower c) (isupper c)
isdigit = λc.and (geq c 48) (leq c 57)
isJust = λm.not (isNothing m)
isLeaf = λt.and (isnil (treeLeft t)) (isnil (treeRight t))
isLeft = λe.not (first e)
islower = λc.and (geq c 97) (leq c 122)
isnil = λl.l (λx.λxs.false) true
isNothing = λl.l (λx.λxs.false) true
isone = λn.eq n 1
ispositive = λn.not (iszero n)
isRight = λp.p (λx.λy.x)
isspace = λc.or (eq c space) (or (eq c tab) (eq c newline))
isSubset = λl1.λl2.all (λx.elem x l2) l1
isSuperset = λl1.λl2.isSubset l2 l1
istwo = λn.eq n 2
isupper = λc.and (geq c 65) (leq c 90)
iszero = λn.n (λx.false) true
iterate = λf.[f]
just = λx.pair true x
K = λx.λy.x
kestrel = λx.λy.x
last = λl.head (reverse l)
lcm = λa.λb.if (or (iszero a) (iszero b)) 0 (div (mult a b) (gcd a b))
leaf = λv.pair v (pair [] [])
left = λx.pair false x
length = λl.foldr (λx.λacc.succ acc) zero l
leq = λm.λn.iszero (minus m n)
lines = λl.filter (λw.not (isnil w)) (break (eq newline) l)
lt = λm.λn.and (leq m n) (not (eq m n))
map = λf.λl.l (λx.λrest.cons (f x) rest) []
max = λm.λn.if (geq m n) m n
maximum = λl.foldr (λx.λacc.if (gt x acc) x acc) zero l
maybe = λdef.λf.λm.if (isNothing m) def (f (fromJust m))
maybeMap = λf.λm.if (isNothing m) nothing (just (f (fromJust m)))
memoize = λf.f
min = λm.λn.if (leq m n) m n
minimum = λl.foldr (λx.λacc.if (lt x acc) x acc) (head l) (tail l)
minus = λm.λn.n pred m
mockingbird = λx.x x
mod = λm.λn.second (DIV_ITER 0 m n)
mult = λm.λn.λf.m (n f)
neq = λm.λn.not (eq m n)
newline = 10
nil = 0
node = λv.λl.λr.pair v (pair l r)
not = λp.p false true
notElem = λx.λl.not (elem x l)
nothing = 0
nth = λn.λl.head (drop n l)
nub = λl.foldl (λacc.λx.if (elem x acc) acc (cons x acc)) [] l
odd = λn.not (even n)
omega = λx.x x
on = λop.λf.λx.λy.op (f x) (f y)
or = [true]
pair = λx.λy.λf.f x y
partial = λf.λx.λy.f x y
partial2 = λf.λx.λy.λz.f x y z
partition = λp.λl.pair (filter p l) (filter (λx.not (p x)) l)
plus = λm.λn.λf.λx.m f (n f x)
pred = λn.λf.λx.n (λg.λh.h (g f)) (λu.x) (λu.u)
primes = λn.filter isPrime (enumFromTo 2 n)
product = λl.foldr mult 1 l
putChar = λc.cons c
putState = λs.λ_placeholder1.pair [] s
putStr = [cons]
quadruple = λn.plus (double n) (double n)
range = λn.Y (λf.λk.if (eq k n) [] (cons k (f (succ k)))) 0
rangeY = λn.Y (λf.λk.if (== k n) [] (cons k (f (+ k 1)))) 0
repeat = λn.λx.n (λacc.cons x acc) []
replicate = λn.λx.n (λacc.cons x acc) []
returnState = λx.λs.pair x s
reverse = λl.foldl (λacc.λx.cons x acc) [] l
reverseY = λl.Y (λf.λl.λacc.if (isnil l) acc (f (tail l) (cons (head l) acc))) l []
right = λx.pair true x
runState = 1
S = λx.λy.λz.x z (y z)
safediv = λa.λb.if (iszero b) nothing (just (div a b))
safehead = λl.if (isnil l) nothing (just (head l))
safeInit = λl.if (isnil l) [] (reverse (tail (reverse l)))
safeMaximum = λl.if (isnil l) nothing (just (maximum l))
safeMinimum = λl.if (isnil l) nothing (just (minimum l))
safenth = λn.λl.if (gt n (pred (length l))) nothing (just (nth n l))
safetail = λl.if (isnil l) nothing (just (tail l))
scanl = λf.λz.λl.reverse (foldl (λacc.λx.cons (f (head acc) x) acc) ([z]) l)
scanr = λf.λz.λl.foldr (λx.λacc.cons (f x (head acc)) acc) ([z]) l
second = λp.p 0
space = 32
splitAt = λn.λl.pair (take n l) (drop n l)
sqrt = λn.if (iszero n) zero (if (eq n 1) 1 (SQRT_ITER n (half (plus n 1)) 20))
SQRT_CONVERGED = λn.λx.leq (abs (minus (mult x x) n)) 1
SQRT_NEWTON_STEP = λn.λx.half (plus x (div n x))
square = λn.mult n n
starling = λx.λy.λz.x z (y z)
succ = λn.λf.λx.f (n f x)
sum = λl.foldr plus zero l
swap = λp.λf.p (λx.λy.f y x)
tab = 9
tail = λl.first (l (λx.λp.pair (second p) (cons x (second p))) (pair [] []))
take = λn.λl.n (λf.λprev.if (isnil prev) [] (cons (head prev) (f (tail prev)))) (λx.[]) l
thrush = λx.λf.f x
times = λn.λf.n f I
tolower = λc.if (isupper c) (plus c 32) c
toupper = λc.if (islower c) (minus c 32) c
trace = 0
treeDepth = λt.if (isnil t) 0 (succ (max (treeDepth (treeLeft t)) (treeDepth (treeRight t))))
treeLeft = λt.first (second t)
treeRight = λt.second (second t)
treeSize = λt.if (isnil t) 0 (succ (plus (treeSize (treeLeft t)) (treeSize (treeRight t))))
treeValue = λp.p (λx.λy.x)
triple = λn.plus n (plus n n)
true = λx.λy.x
uncurry = λf.λp.f (first p) (second p)
union = λl1.λl2.append l1 (filter (λx.notElem x l1) l2)
unique = λl.foldl (λacc.λx.if (elem x acc) acc (cons x acc)) [] l
unless = λp.λf.λx.if p x (f x)
unzip = λl.pair (map first l) (map second l)
warbler = [x]
when = λp.λf.λx.if p (f x) x
words = λl.filter (λw.not (isnil w)) (break isspace l)
xor = [not q]
zero = 0

# Complex expressions
^ = <thunk:(λf.λb.λn.if (iszero n) 1 (mult b (f b (pred n)))) (Y (λf.λb.λn.if (iszero n) 1 (mult b (f b (pred n)))))>
allY = <thunk:(λf.λp.λl.if (isnil l) true (and (p (head l)) (f p (tail l)))) (Y (λf.λp.λl.if (isnil l) true (and (p (head l)) (f p (tail l)))))>
anyY = <thunk:(λf.λp.λl.if (isnil l) false (or (p (head l)) (f p (tail l)))) (Y (λf.λp.λl.if (isnil l) false (or (p (head l)) (f p (tail l)))))>
DIV_ITER = <thunk:(λf.λq.λm.λn.if (lt m n) (pair q m) (f (succ q) (minus m n) n)) (Y (λf.λq.λm.λn.if (lt m n) (pair q m) (f (succ q) (minus m n) n)))>
divByZero = <thunk:(λx.x) (Y (λx.x))>
error = <thunk:(λx.x) (Y (λx.x))>
exp = <thunk:(λf.λb.λn.if (iszero n) 1 (mult b (f b (pred n)))) (Y (λf.λb.λn.if (iszero n) 1 (mult b (f b (pred n)))))>
expY = <thunk:(λf.λb.λn.if (== n 0) 1 (* b (f b (- n 1)))) (Y (λf.λb.λn.if (== n 0) 1 (* b (f b (- n 1)))))>
factRec = <thunk:(λf.λn.if (iszero n) 1 (mult n (f (pred n)))) (Y (λf.λn.if (iszero n) 1 (mult n (f (pred n)))))>
factY = <thunk:(λf.λn.if (== n 0) 1 (* n (f (- n 1)))) (Y (λf.λn.if (== n 0) 1 (* n (f (- n 1)))))>
fibRec = <thunk:(λf.λn.if (iszero n) 1 (plus (f (pred n)) (f (pred (pred n))))) (Y (λf.λn.if (iszero n) 1 (plus (f (pred n)) (f (pred (pred n))))))>
fibY = <thunk:(λf.λn.if (== n 0) 1 (+ (f (- n 1)) (f (- n 2)))) (Y (λf.λn.if (== n 0) 1 (+ (f (- n 1)) (f (- n 2)))))>
filterY = <thunk:(λf.λp.λl.if (isnil l) [] (if (p (head l)) (cons (head l) (f p (tail l))) (f p (tail l)))) (Y (λf.λp.λl.if (isnil l) [] (if (p (head l)) (cons (head l) (f p (tail l))) (f p (tail l)))))>
findY = <thunk:(λf.λp.λl.if (isnil l) [] (if (p (head l)) (head l) (f p (tail l)))) (Y (λf.λp.λl.if (isnil l) [] (if (p (head l)) (head l) (f p (tail l)))))>
gcd = <thunk:(λg.λa.λb.if (iszero b) a (g b (mod a b))) (Y (λg.λa.λb.if (iszero b) a (g b (mod a b))))>
gcdY = <thunk:(λf.λa.λb.if (== b 0) a (f b (% a b))) (Y (λf.λa.λb.if (== b 0) a (f b (% a b))))>
indexError = <thunk:(λx.x) (Y (λx.x))>
inOrder = <thunk:(λf.λt.if (isnil t) [] (append (f (treeLeft t)) (cons (treeValue t) (f (treeRight t))))) (Y (λf.λt.if (isnil t) [] (append (f (treeLeft t)) (cons (treeValue t) (f (treeRight t))))))>
isPrime = <thunk:(λf.λn.(λiter.if (lt n 2) false (iter 2)) (Y (λiter.λi.if (gt (mult i i) n) true (if (eq (mod n i) 0) false (iter (succ i)))))) (Y (λf.λn.(λiter.if (lt n 2) false (iter 2)) (Y (λiter.λi.if (gt (mult i i) n) true (if (eq (mod n i) 0) false (iter (succ i)))))))>
lcmY = <thunk:(λf.λa.λb.if (|| (== a 0) (== b 0)) 0 (/ (* a b) (gcdY a b))) (Y (λf.λa.λb.if (|| (== a 0) (== b 0)) 0 (/ (* a b) (gcdY a b))))>
lengthY = <thunk:(λf.λl.if (isnil l) 0 (+ 1 (f (tail l)))) (Y (λf.λl.if (isnil l) 0 (+ 1 (f (tail l)))))>
mapY = <thunk:(λf.λg.λl.if (isnil l) [] (cons (g (head l)) (f g (tail l)))) (Y (λf.λg.λl.if (isnil l) [] (cons (g (head l)) (f g (tail l)))))>
postOrder = <thunk:(λf.λt.if (isnil t) [] (append (f (treeLeft t)) (append (f (treeRight t)) ([treeValue t])))) (Y (λf.λt.if (isnil t) [] (append (f (treeLeft t)) (append (f (treeRight t)) ([treeValue t])))))>
preOrder = <thunk:(λf.λt.if (isnil t) [] (cons (treeValue t) (append (f (treeLeft t)) (f (treeRight t))))) (Y (λf.λt.if (isnil t) [] (cons (treeValue t) (append (f (treeLeft t)) (f (treeRight t))))))>
productY = <thunk:(λf.λl.if (isnil l) 1 (* (head l) (f (tail l)))) (Y (λf.λl.if (isnil l) 1 (* (head l) (f (tail l)))))>
SQRT_ITER = <thunk:(λf.λn.λx.λiterations.if (or (SQRT_CONVERGED n x) (iszero iterations)) x (f n (SQRT_NEWTON_STEP n x) (pred iterations))) (Y (λf.λn.λx.λiterations.if (or (SQRT_CONVERGED n x) (iszero iterations)) x (f n (SQRT_NEWTON_STEP n x) (pred iterations))))>
sumUptoRec = <thunk:(λf.λn.if (iszero n) 0 (plus n (f (pred n)))) (Y (λf.λn.if (iszero n) 0 (plus n (f (pred n)))))>
sumUptoY = <thunk:(λf.λn.if (== n 0) 0 (+ n (f (- n 1)))) (Y (λf.λn.if (== n 0) 0 (+ n (f (- n 1)))))>
sumY = <thunk:(λf.λl.if (isnil l) 0 (+ (head l) (f (tail l)))) (Y (λf.λl.if (isnil l) 0 (+ (head l) (f (tail l)))))>
typeError = <thunk:(λx.x) (Y (λx.x))>
undefined = <thunk:(λx.x) (Y (λx.x))>
WHILE = <thunk:(λloop.λcond.λbody.λstate.if (cond state) (loop cond body (body state)) state) (Y (λloop.λcond.λbody.λstate.if (cond state) (loop cond body (body state)) state))>
zip = <thunk:(λzip.λl1.λl2.if (or (isnil l1) (isnil l2)) [] (cons (pair (head l1) (head l2)) (zip (tail l1) (tail l2)))) (Y (λzip.λl1.λl2.if (or (isnil l1) (isnil l2)) [] (cons (pair (head l1) (head l2)) (zip (tail l1) (tail l2)))))>
zipWith = <thunk:(λzipWith.λf.λl1.λl2.if (or (isnil l1) (isnil l2)) [] (cons (f (head l1) (head l2)) (zipWith f (tail l1) (tail l2)))) (Y (λzipWith.λf.λl1.λl2.if (or (isnil l1) (isnil l2)) [] (cons (f (head l1) (head l2)) (zipWith f (tail l1) (tail l2)))))>

# =============================================================================
# END OF EXPORT
# =============================================================================
# To load this environment, use: :load ilias.lambda
# Note: This will add to your current environment. Use :clear first for a clean state.
