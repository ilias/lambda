# ============================================================================
# Lambda Calculus Interpreter & stdlib.lambda Comprehensive Test Suite
# ============================================================================
# This file is designed to be loaded with :load tests.lambda
# It covers core features, numerals, booleans, lists, combinators, and more.
# Each test prints a result or checks an expected value.

# --- Boolean Logic ---
true 1 0                # expect 1
false 1 0               # expect 0
not true                # expect false
not false               # expect true
and true true           # expect true
and true false          # expect false
or true false           # expect true
xor true true           # expect false
if true 42 99           # expect 42
if false 42 99          # expect 99
eqBool true true        # expect true
eqBool true false       # expect false

# --- Church Numerals ---
zero (λx.1) 0           # expect 0
succ (succ zero)        # expect 2
plus 2 3                # expect 5
mult 3 4                # expect 12
pred 3                  # expect 2
minus 5 2               # expect 3
iszero 0                # expect true
iszero 1                # expect false
exp 2 3                 # expect 8


# --- Division and Modulo ---
div 7 2                  # expect 3
mod 7 2                  # expect 1


# --- Comparisons ---
leq 2 3                  # expect true
leq 3 2                  # expect false
eq 4 4                   # expect true
eq 4 5                   # expect false
gt 5 2                   # expect true
lt 2 5                   # expect true
neq 2 2                  # expect false
neq 2 3                  # expect true


# --- Numeric Operations ---
max 3 7                  # expect 7
min 3 7                  # expect 3
even 4                   # expect true
odd 5                    # expect true
square 6                 # expect 36
double 8                 # expect 16
half 9                   # expect 4
pow 2 5                  # expect 32


# --- List Operations ---
nil                              # expect nil
isnil nil                        # expect true
isnil (cons 1 nil)               # expect false
cons 1 (cons 2 (cons 3 nil))     # expect [1,2,3]
head (cons 1 (cons 2 (cons 3 nil)))          # expect 1
tail (cons 1 (cons 2 (cons 3 nil)))          # expect [2,3]
length (cons 1 (cons 2 (cons 3 nil)))        # expect 3
reverse (cons 1 (cons 2 (cons 3 nil)))       # expect [3,2,1]
append (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil)) # expect [1,2,3,4,5]
map succ (cons 1 (cons 2 (cons 3 nil)))      # expect [2,3,4]
filter even (cons 1 (cons 2 (cons 3 (cons 4 nil)))) # expect [2,4]
foldr plus 0 (cons 1 (cons 2 (cons 3 nil)))  # expect 6
foldl plus 0 (cons 1 (cons 2 (cons 3 nil)))  # expect 6


# --- Advanced List Operations ---
range 5                  # expect [0,1,2,3,4]
countdown 3              # expect [3,2,1,0]
zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil)) # expect [(1,4),(2,5)]
concat (cons (cons 1 (cons 2 (cons 3 nil))) (cons (cons 4 nil) nil)) # expect [1,2,3,4]


# --- Combinators and Utilities ---
K 42 99                  # expect 42
I 77                     # expect 77
S (K succ) (K 3) 0       # expect succ 0 = 1
B succ succ 1            # expect succ (succ 1) = 2
C minus 5 2              # expect minus 2 5 = 3


# --- Recursion and Advanced Functions ---
fact 5                   # expect 120
fib 7                    # expect 13
gcd 18 24                # expect 6
lcm 6 8                  # expect 24


# --- Infix Operators ---
2 + 3                    # expect 5
7 - 4                    # expect 3
3 * 4                    # expect 12
9 / 2                    # expect 4
9 % 4                    # expect 1
2 ^ 4                    # expect 16
true && false            # expect false
false || true            # expect true
5 == 5                   # expect true
5 != 4                   # expect true
2 < 3                    # expect true
2 <= 2                   # expect true
4 > 3                    # expect true
4 >= 4                   # expect true

# --- Maybe/Optional Type ---
just 42                        # expect just 42
nothing                        # expect nil
isJust (just 1)                # expect true
isNothing nothing              # expect true
fromJust (just 7)              # expect 7
fromMaybe 99 (just 5)          # expect 5
fromMaybe 99 nothing           # expect 99
maybe 0 succ (just 3)          # expect 4
maybe 0 succ nothing           # expect 0

# --- Either Type ---
left 1                         # expect left 1
right 2                        # expect right 2
isLeft (left 5)                # expect true
isRight (right 6)              # expect true
either succ pred (left 10)     # expect 11
either succ pred (right 10)    # expect 9

# --- Tree Data Structure ---
leaf 7                         # expect (7, (nil, nil))
node 1 (leaf 2) (leaf 3)       # expect (1, ((2, (nil, nil)), (3, (nil, nil))))
treeValue (leaf 8)             # expect 8
treeLeft (node 1 (leaf 2) (leaf 3))  # expect (2, (nil, nil))
treeRight (node 1 (leaf 2) (leaf 3)) # expect (3, (nil, nil))
isLeaf (leaf 9)                # expect true
isLeaf (node 1 (leaf 2) (leaf 3))    # expect false

# --- zipWith, scanl, scanr, find, partition, splitAt ---
zipWith plus (cons 1 (cons 2 nil)) (cons 10 (cons 20 nil)) # expect [11,22]
scanl plus 0 (cons 1 (cons 2 (cons 3 nil))) # expect [0,1,3,6]
scanr plus 0 (cons 1 (cons 2 (cons 3 nil))) # expect [6,5,3,0]
find (eq 2) (cons 1 (cons 2 (cons 3 nil)))  # expect 2
partition even (cons 1 (cons 2 (cons 3 (cons 4 nil)))) # expect ([2,4],[1,3])
splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil)))) # expect ([1,2],[3,4])

# --- Edge Cases and Safe Functions ---
safeMinimum nil                 # expect nothing
safeMaximum nil                 # expect nothing
safeMinimum (cons 3 (cons 1 (cons 2 nil))) # expect just 1
safeMaximum (cons 3 (cons 1 (cons 2 nil))) # expect just 3
clamp 2 4 1                    # expect 2
clamp 2 4 3                    # expect 3
clamp 2 4 5                    # expect 4

# --- Miscellaneous ---
compose succ succ 1             # expect 3
flip minus 2 5                  # expect 3
on plus succ 2 3                # expect 7
apply succ 4                    # expect 5
partial plus 2 3                # expect 5
partial2 plus 2 3 4             # expect 9
memoize succ 10                 # expect 11
id2 123                         # expect 123
const2 7 8                      # expect 7

# --- Additional List Operations ---
take 3 (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil))))) # expect [1,2,3]
drop 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))  # expect [3,4]
nth 2 (cons 10 (cons 20 (cons 30 (cons 40 nil)))) # expect 30
any (λx.gt x 3) (cons 1 (cons 2 (cons 5 nil)))   # expect true
all even (cons 2 (cons 4 (cons 6 nil)))          # expect true
all even (cons 2 (cons 3 (cons 6 nil)))          # expect false
sum (cons 1 (cons 2 (cons 3 (cons 4 nil))))      # expect 10
product (cons 2 (cons 3 (cons 4 nil)))           # expect 24
maximum (cons 1 (cons 5 (cons 3 (cons 2 nil))))  # expect 5
minimum (cons 4 (cons 1 (cons 3 (cons 2 nil))))  # expect 1

# --- Advanced List Utilities ---
elem 3 (cons 1 (cons 2 (cons 3 nil)))            # expect true
elem 5 (cons 1 (cons 2 (cons 3 nil)))            # expect false
notElem 5 (cons 1 (cons 2 (cons 3 nil)))         # expect true
nub (cons 1 (cons 2 (cons 1 (cons 3 (cons 2 nil))))) # expect [1,2,3]
unique (cons 1 (cons 2 (cons 1 (cons 3 nil))))   # expect [1,2,3]
last (cons 1 (cons 2 (cons 3 nil)))              # expect 3
init (cons 1 (cons 2 (cons 3 nil)))              # expect [1,2]
safeInit nil                                      # expect nil
safeInit (cons 1 nil)                            # expect nil

# --- Enumeration and Range Functions ---
enumFromTo 3 7                                   # expect [3,4,5,6,7]
enumFrom 5 4                                     # expect [5,6,7,8]
iota 4                                           # expect [0,1,2,3]
replicate 3 7                                    # expect [7,7,7]
repeat 3 9                                       # expect [9,9,9]

# --- Iteration and Application ---
iterate succ 5 0                                 # expect 5
times 3 succ 0                                   # expect 3
when true succ 5                                 # expect 6
when false succ 5                                # expect 5
unless true succ 5                               # expect 5
unless false succ 5                              # expect 6
cond true 42 99                                  # expect 42

# --- Pair Operations ---
pair 1 2                                      # expect (1,2)
first (pair 10 20)                            # expect 10
second (pair 10 20)                           # expect 20
swap (pair 1 2)                               # expect pair that when applied to f gives f 2 1

# --- Advanced Numeric Functions ---
abs 5                                         # expect 5 (Church numerals are non-negative)
sqrt 16                                       # expect approximately 4
sqrt 25                                       # expect 5
isPrime 7                                     # expect true
isPrime 8                                     # expect false
isPrime 2                                     # expect true
isPrime 1                                     # expect false
primes 10                                     # expect [2,3,5,7]

# --- String/Character Operations (treating numbers as char codes) ---
# Note: These are simplified for demo purposes
words (cons 104 (cons 101 (cons 108 (cons 108 (cons 111 nil))))) # expect simplified word list
unwords (cons (cons 104 (cons 105 nil)) (cons (cons 121 (cons 111 nil)) nil)) # expect joined with spaces

# --- Set Operations on Lists ---
union (cons 1 (cons 2 nil)) (cons 2 (cons 3 nil))  # expect [1,2,3]
intersect (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 3 (cons 4 nil))) # expect [2,3]
difference (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 4 nil))         # expect [1,3]
isSubset (cons 1 (cons 2 nil)) (cons 1 (cons 2 (cons 3 nil)))           # expect true
isSuperset (cons 1 (cons 2 (cons 3 nil))) (cons 1 (cons 2 nil))         # expect true

# --- Advanced Combinators ---
omega I                                       # expect I (omega applied to identity)
mockingbird I                                 # expect I
thrush 5 succ                                 # expect 6
cardinal minus 3 10                           # expect 7
bluebird succ pred 5                          # expect 5
kestrel 42 99                                 # expect 42
warbler plus 3                                # expect 6
starling (K succ) (K 2) 0                     # expect 2

# --- Curry and Uncurry Functions ---
curry3 (λt.plus (first t) (plus (first (second t)) (second (second t)))) 1 2 3  # expect 6
uncurry plus (pair 7 3)                       # expect 10
uncurry3 (λx y z.plus x (plus y z)) (pair 1 (pair 2 3))  # expect 6

# --- More Maybe/Optional Operations ---
maybeMap succ (just 5)                        # expect just 6
maybeMap succ nothing                         # expect nothing

# --- State Monad (simplified) ---
runState (returnState 42) 0                   # expect (42, 0)
runState getState 123                         # expect (123, 123)

# --- Advanced Tree Operations ---
treeSize (leaf 1)                             # expect 1
treeSize nil                                  # expect 0
treeDepth (leaf 1)                            # expect 1
treeDepth nil                                 # expect 0
inOrder (leaf 5)                              # expect [5]
preOrder (leaf 5)                             # expect [5]
postOrder (leaf 5)                            # expect [5]

# --- Edge Cases and Error Conditions ---
div 5 0                                       # expect 0 (division by zero returns 0)
mod 5 0                                       # expect 0 (modulo by zero returns 0)
head nil                                      # expect nil
tail nil                                      # expect nil
pred 0                                        # expect 0 (predecessor of 0 is 0)
minus 3 5                                     # expect 0 (Church arithmetic doesn't go negative)

# --- Complex Expressions ---
map (λx.mult x x) (range 5)                   # expect [0,1,4,9,16]
filter (λx.eq (mod x 3) 0) (range 10)         # expect [0,3,6,9]
foldr max 0 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil))))) # expect 9
foldl min 999 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil))))) # expect 1

# --- Recursive Function Tests ---
factRec 4                                     # expect 24
fibRec 6                                      # expect 8
sumUptoRec 5                                  # expect 15

# --- Performance and Stress Tests ---
length (range 50)                             # expect 50
sum (range 10)                                # expect 45
fact 6                                        # expect 720
fib 10                                        # expect 55

# --- test Y combinator ---
factY 4                                       # expect 24
fibY 6                                        # expect 8
sumUptoY 5                                    # expect 15
expY 2 5                                      # expect 32
rangeY 10                                     # expect [0,1,2,3,4,5,6,7,8,9]
countdownY 5                                  # expect [5,4,3,2,1,0]
gcdY 48 18                                    # expect 6
lcmY 12 15                                    # expect 60
mapY succ (range 5)                           # expect [1,2,3,4,5]
filterY (λx.eq (mod x 2) 0) (range 10)        # expect [0,2,4,6,8]
lengthY (range 50)                            # expect 50
reverseY (range 5)                            # expect [4,3,2,1,0]
sumY (range 5)                                # expect 10
productY (tail (range 7))                     # expect 720 - tail to avoid 0
anyY (λx.gt x 3) (range 5)                    # expect true
allY (λx.leq x 5) (range 5)                   # expect true
findY (λx.eq x 3) (range 5)                   # expect 3

[1, 2, 3]                                     # expect [1,2,3]
[1, 3 .. 6]                                   # expect [1,3,4,5,6]
[1, 2, 3, [4..7], [11 .. 8]]                  # expect [1,2,3,[4,5,6,7],[11,10,9,8]]

mapY (ackermann 2) [2..10]                    # expect [7, 9, 11, 13, 15, 17, 19, 21, 23]

# --- Let and Let Rec Examples ---
let x = 5 in x + 2                            # expect 7
let x = 1, y = 2 in x + y                     # expect 3
let a = 10, b = 20, c = 30 in a + b + c       # expect 60
let x = 2, y = 3 in x * (y + 1)               # expect 8
let rec fact = \n. if (eq n 0) 1 (mult n (fact (pred n))) in fact 5   # expect 120
let rec fib = \n. if (leq n 1) n (plus (fib (pred n)) (fib (minus n 2))) in fib 6   # expect 8
let rec sumTo = \n. if (eq n 0) 0 (plus n (sumTo (pred n))) in sumTo 4   # expect 10

# --- Pipeline Operator (|>) Chaining Tests ---
5 |> succ                   # expect 6
5 |> square                 # expect 25
5 |> square |> succ         # expect 26
5 |> succ |> square         # expect 36
1 |> succ |> succ |> succ   # expect 4
(5 |> square) |> succ       # expect 26
5 |> (square |> succ)       # expect 26
2 |> succ |> square |> pred # expect 8

# --- Arrow Function Syntax Tests ---
(x -> x + 1) 5                       # expect 6 (simple arrow function)
(x -> succ x) 4                      # expect 5 (arrow function with stdlib)
(x, y -> x + y) 3 2                  # expect 5 (multi-parameter arrow function)
(x, y -> mult x y) 4 3               # expect 12 (multiplication with arrow syntax)
(x -> x * x) 6                       # expect 36 (arrow function with multiplication)
(x, y, z -> x + y + z) 1 2 3         # expect 6 (three parameter arrow function)
let f = x -> x + 1 in f 10           # expect 11 (arrow function in let binding)
let add = x, y -> x + y in add 7 8   # expect 15 (multi-param arrow in let)
let add = x -> y -> x + y in \
let mult2 = x -> x * 2 in \
let div2 = x -> x / 2 in \
    (add 5 3) |> mult2 |> div2       # expect 8 (div2 of (mult2 of (add 5 3)))
let add = x, y -> x + y in \
let mult2 = x -> x * 2 in \
let div2 = x -> x / 2 in \
    (add 5 3) |> mult2 |> div2       # expect 8 (div2 of (mult2 of (add 5 3)))
3 |> (x -> x + 1) |> (y -> y * 2)    # expect 8 (arrow function with pipeline)
(x -> y -> x + y) 5 3                # expect 8 (curried arrow functions)
(f -> x -> f (f x)) succ 0           # expect 2 (higher-order arrow function)
map (x -> x + 1) [1, 2, 3]           # expect [2, 3, 4] (arrow function with map)
filter (x -> x > 2) [1, 2, 3, 4, 5]  # expect [3, 4, 5] (arrow function with filter)
x -> x + 1 + 2                       # should parse as x -> (x + 1 + 2), not (x -> x + 1) + 2


# --- Infix Composition Operator (.) Tests ---
inc = x -> x + 1
double = x -> x * 2
square = x -> x * x
inc . double . 3           # expect 7   (inc (double 3) = 1 + (2*3) = 7)
double . inc . 3           # expect 8   (double (inc 3) = 2*(3+1) = 8)
square . inc . 4           # expect 25  (square (inc 4) = (4+1)^2 = 25)
inc . double . square . 2  # expect 9   (inc (double (square 2)) = inc (double 4) = inc 8 = 9)
double . inc . square . 2  # expect 10  (double (inc (square 2)) = double (inc 4) = double 5 = 10)
inc . double . 3 |> square # expect 49  (square (inc (double 3)) = square 7 = 49)


# --- Advanced Multi-Feature Tests ---
foldr plus 0 (filter (λx.gt x 2) \
                     (map (λx.mult x x) (range 5)))           # expect 29 (sum of squares > 2)
let double = x -> x * 2 in \
    (map double [1,2,3,4]) |> (filter (x -> x > 4))           # expect [6,8]
let rec sumEvens = \xs. \
    if (isnil xs) 0 \
       (if (even (head xs)) \
           (plus (head xs) (sumEvens (tail xs))) \
           (sumEvens (tail xs))) in sumEvens [1,2,3,4,5,6]    # expect 12
(maybeMap (x -> x * x) (just 7)) |> (maybe 0 (x -> x + 1))    # expect 50
let tree = node 1 (leaf 2) (node 3 (leaf 4) (leaf 5)) in \
    foldr plus 0 (inOrder tree)                               # expect 15
map (x -> map (y -> x * y) [1,2,3]) [4,5]                     # expect [[4,8,12],[5,10,15]]
let add3 = x -> y -> z -> x + y + z in \
    (add3 1 2) |> (f -> f 3)                                  # expect 6
find (x -> x % 6 == 0) (map (x -> x + 1) [1,3,5,7,8])         # expect 6
foldl mult 1 (map (pair -> plus (first pair) (second pair)) \
                  (zip [1,2,3] [4,5,6]))                      # expect 315 (5*7*9)
let f = x -> x * 3 in \
    (map f (filter (x -> x > 2) (range 7))) |> (foldl plus 0) # expect 54


# Example Church-encoded Maybe

just = λx.λj.λn. j x
nothing = λj.λn. n
bind = λm.λf. m f nothing

bind (just 3) (λx. just (x + 1))    # yields just 4
bind nothing (λx. just (x + 1))     # yields nothing



# --- Lambda Placeholder (Underscore) Examples ---
# Each '_' in a lambda is treated as a unique, ignored parameter.

# Single placeholder: ignores its argument
(\_ . 42) 123                # expect 42
(\_ _ . 99) 1 2              # expect 99
(\x _ . x) 7 8               # expect 7
(\_ y . y) 5 6               # expect 6
(_ , _ -> 0) 10 20           # expect 0
(x, _ -> x) 42 99            # expect 42
let f = \_ . 123 in f 456    # expect 123
let g = \_ _ . 1 in g 2 3    # expect 1
let h = \_ y . y in h 0 9    # expect 9




# --- Macro System Tests ---
# Testing the macro definition and expansion capabilities

# Basic letbind macro test (already defined in previous tests)
:macro (letbind $var $val $expr) => ((λ$var.$expr) $val)
(letbind x 42 (plus x 10))                              # expect 52
(letbind y 5 (mult y y))                                # expect 25
(letbind z 3 (exp 2 z))                                 # expect 8

# Simple replacement macro
:macro (double $x) => (plus $x $x)
(double 7)                                              # expect 14
(double (succ 4))                                       # expect 10

# Macro with multiple parameters
:macro (triple $x) => (plus $x (plus $x $x))
(triple 8)                                              # expect 24

# Conditional macro (when construct)
:macro (when $cond $expr) => (if $cond $expr I)
(when true (succ 10))                                   # expect 11
(when false (succ 10))                                  # expect I (identity function)

# Unless macro (opposite of when)
:macro (unless $cond $expr) => (if $cond I $expr)
(unless false (succ 20))                               # expect 21
(unless true (succ 20))                                # expect I (identity function)

# syntax for loop macro   - already defined in stdlib
for x at [1..10] do (succ x)                           # expect [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
for x at [1..10] do (square x)                         # expect [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
for x at [1..10] do (div x 2)                          # expect [0, 1, 1, 2, 2, 3, 3, 4, 4, 5]
for x at [1..10] do (mod x 2)                          # expect [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]

# Swap macro for pairs
:macro (swappair $p) => (pair (second $p) (first $p))
(swappair (pair 1 2))                                   # expect (2, 1)

# List construction macro
:macro (list3 $a $b $c) => (cons $a (cons $b (cons $c nil)))
(list3 1 2 3)                                          # expect [1,2,3]

# Math operation macros
:macro (square $x) => (mult $x $x)
(square 6)                                              # expect 36
(square (plus 3 2))                                     # expect 25

:macro (cube $x) => (mult $x (mult $x $x))
(cube 3)                                                # expect 27

# Comparison macro
:macro (between $x $low $high) => (and (geq $x $low) (leq $x $high))
(between 5 3 7)                                        # expect true
(between 2 3 7)                                        # expect false
(between 8 3 7)                                        # expect false

# Increment/decrement macros
:macro (inc $x) => (succ $x)
:macro (dec $x) => (pred $x)
(inc 10)                                                # expect 11
(dec 10)                                                # expect 9

# Nested macro usage
(inc (square 4))                                        # expect 17 (16 + 1)
(square (inc 4))                                        # expect 25 (5^2)

# Complex expression macro
:macro (quadratic $a $b $c $x) => (plus (mult $a (square $x)) (plus (mult $b $x) $c))
(quadratic 2 3 1 4)                                     # expect 45 (2*16 + 3*4 + 1 = 32 + 12 + 1)

# Factorial approximation using macros
:macro (fact2 $n) => (if (iszero $n) 1 (mult $n (fact2 (pred $n))))
# Note: This won't work due to recursive macro limitation, but tests macro parsing

# List operation macros
:macro (head2 $list) => (head $list)
:macro (tail2 $list) => (tail $list)
:macro (isempty2 $list) => (isnil $list)
(head2 (cons 1 (cons 2 nil)))                          # expect 1
(tail2 (cons 1 (cons 2 nil)))                          # expect [2]
(isempty2 nil)                                          # expect true
(isempty2 (cons 1 nil))                                 # expect false

# Conditional assignment macro
:macro (ifelse $cond $then $else) => (if $cond $then $else)
(ifelse true 100 200)                                  # expect 100
(ifelse false 100 200)                                 # expect 200

# Function composition macro
:macro (compose2 $f $g $x) => ($f ($g $x))
(compose2 succ double 5)                               # expect 11 (succ (double 5) = succ 10)

# Advanced letbind variations
:macro (let2 $var $val $expr) => ((λ$var.$expr) $val)
(let2 a 7 (plus a 3))                                  # expect 10

# Multiple variable binding (simulated)
:macro (let3 $var1 $val1 $var2 $val2 $expr) => ((λ$var1.(λ$var2.$expr) $val2) $val1)
(let3 x 5 y 3 (plus x y))                              # expect 8

# Boolean operation macros
:macro (nand $a $b) => (not (and $a $b))
:macro (nor $a $b) => (not (or $a $b))
(nand true true)                                        # expect false
(nand true false)                                       # expect true
(nor false false)                                       # expect true
(nor true false)                                        # expect false

# Min/max macros
:macro (min2 $a $b) => (if (leq $a $b) $a $b)
:macro (max2 $a $b) => (if (geq $a $b) $a $b)
(min2 5 3)                                              # expect 3
(max2 5 3)                                              # expect 5

# Absolute value macro (for Church numerals, always positive)
:macro (abs2 $x) => $x
(abs2 5)                                                # expect 5

# Power of 2 macro
:macro (pow2 $x) => (mult $x $x)
(pow2 4)                                                # expect 16

# List length macro using existing functions
:macro (len $list) => (length $list)
(len (cons 1 (cons 2 (cons 3 nil))))                   # expect 3

# First and second element macros
:macro (first2 $list) => (head $list)
:macro (second2 $list) => (head (tail $list))
(first2 (cons 10 (cons 20 (cons 30 nil))))             # expect 10
(second2 (cons 10 (cons 20 (cons 30 nil))))            # expect 20

# Range macro using existing function
:macro (range2 $n) => (range $n)
(range2 4)                                              # expect [0,1,2,3]

# Map operation macro
:macro (map2 $f $list) => (map $f $list)
(map2 succ (cons 1 (cons 2 (cons 3 nil))))             # expect [2,3,4]

# Filter operation macro
:macro (filter2 $pred $list) => (filter $pred $list)
(filter2 even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) # expect [2,4]

# Fold operation macro
:macro (sum2 $list) => (foldr plus 0 $list)
(sum2 (cons 1 (cons 2 (cons 3 nil))))                  # expect 6

# Complex nested macro test
:macro (process $x) => (inc (square (dec $x)))
(process 5)                                             # expect 17 (inc (square (dec 5)) = inc (square 4) = inc 16)

# Macro with conditional logic
:macro (sign $x) => (if (iszero $x) 0 1)
(sign 0)                                                # expect 0
(sign 5)                                                # expect 1

# Testing macro with lambda expressions in parameters
(letbind f (λx.plus x 1) (f 10))                       # expect 11

# Testing macro variable scoping
:macro (scope_test $x $y) => (letbind $x $y (plus $x 1))
(scope_test a 15)                                       # expect 16

# Multiple macro definitions with same structure
:macro (add_one $x) => (plus $x 1)
:macro (add_two $x) => (plus $x 2)  
:macro (add_three $x) => (plus $x 3)
(add_one 10)                                            # expect 11
(add_two 10)                                            # expect 12
(add_three 10)                                          # expect 13

# Macro parameter reuse
:macro (duplicate $x) => (pair $x $x)
(duplicate 7)                                           # expect (7, 7)

# Complex expression with multiple macro calls
(add_one (square (add_two 3)))                         # expect 26 (add_one (square 5) = add_one 25)

# Testing macro expansion order
:macro (outer $x) => (inner (plus $x 1))
:macro (inner $y) => (mult $y 2)
(outer 4)                                               # expect 10 (inner (plus 4 1) = inner 5 = mult 5 2)

# Macro with complex lambda body
:macro (apply_twice $f $x) => ($f ($f $x))
(apply_twice succ 0)                                    # expect 2
(apply_twice (λx.mult x 2) 3)                          # expect 12

# Edge case: macro with no parameters
:macro (forty_two) => 42
(forty_two)                                             # expect 42

# Testing macro name collision avoidance
:macro (test_macro $x) => (plus $x 100)
(test_macro 5)                                          # expect 105

# Macro with Church numeral operations
:macro (church_add $m $n) => (plus $m $n)
:macro (church_mult $m $n) => (mult $m $n)
(church_add 3 4)                                        # expect 7
(church_mult 3 4)                                       # expect 12

# Final complex test combining multiple features
:macro (complex_calc $a $b $c) => (letbind x (plus $a $b) (letbind y (mult x $c) (square y)))
(complex_calc 2 3 4)                                    # expect 400 (let x = 2+3=5, let y = 5*4=20, square 20 = 400)

# --- End of Test Suite ---
# Review the output for each test variable above.
# To run: :load stdlib.lambda, then :load tests.lambda

