# -----------------------------------------------
# Complex Combinator Tests (SKIBC and composition)
# -----------------------------------------------

# 1) S, K, I basic derived identities
alphaEq ((S K K) 7) 7                         # S K K == I
alphaEq ((S K I) 42) 42                       # S K I == identity on value

# 2) K discards second argument
alphaEq (K 5 99) 5
alphaEq (K (plus 2 3) 0) 5

# 3) B is composition: B f g x = f (g x)
alphaEq (B succ square 3) (succ (square 3))
alphaEq (B succ square 3) ((succ o square) 3)

# 4) C flips arguments: C f x y = f y x
alphaEq (C minus 3 10) (minus 10 3)
alphaEq (C pair 1 2) (pair 2 1)

# 5) Composition operator o associates right and matches B
alphaEq ((succ o square) 4) (succ (square 4))
alphaEq (((plus 1) o (mult 2)) 3) (plus 1 (mult 2 3))

# 6) S distributes application: S f g x = f x (g x)
# Use numeric functions to avoid variable capture concerns
alphaEq (S plus square 3) (plus 3 (square 3))
alphaEq (S mult succ 4) (mult 4 (succ 4))

# 7) B/C with lists and pairs
alphaEq (B head (cons 1) [2,3]) 1            # head (cons 1 [2,3])
alphaEq (B tail (cons 9) [8,7]) [8,7]        # tail (cons 9 [8,7]) = [8,7]

# 8) SK expression equivalences
alphaEq ((S plus (K 3)) 4) 7
alphaEq ((S (K succ) I) 4) 5

# =========================================================================
# Structural Equality Test Suite (auto-converted from tests.lambda)
# Each prior test:  expr  # expect VALUE  ==>  alphaEq expr VALUE
# Loads stdlib.lambda first; then load this file: :load struct-tests.lambda
# NOTE:
#   - Some descriptive expectations (e.g., words/unwords textual forms) kept as comments
#   - Ambiguous expectations were converted where a reasonable canonical form exists
# =========================================================================

# Structural / wildcard macro tests (auto added)
# Expect head (cons 1 (cons 2 nil)) => 1
:macro (head (cons $h $t)) => $h
:macro (head nil) => nil
alphaEq (head (cons 1 (cons 2 nil))) 1
alphaEq (head nil) nil

# ---------------------------------------------------------------------------
# Extended Structural Macro Pattern Tests
# ---------------------------------------------------------------------------

# Swap arguments of a binary application using nested structural pattern
:macro (swapArgs ($f $a $b)) => ($f $b $a)
alphaEq (swapArgs (plus 2 5)) (plus 5 2)

# Drop the second list element: (cons x (cons _ rest)) -> (cons x rest)
:macro (dropSecond (cons $x (cons _ $rest))) => (cons $x $rest)
# Fallback: single element list remains unchanged
:macro (dropSecond (cons $x nil)) => (cons $x nil)
alphaEq (dropSecond [1,2,3,4]) [1,3,4]
alphaEq (dropSecond [9]) [9]            # no match (pattern length mismatch) stays same

# Specific structural match should win over generic variable match
:macro (spec (cons 1 $t)) => 1
:macro (spec $x) => 0
alphaEq (spec (cons 1 nil)) 1
alphaEq (spec 42) 0

# Arity-sensitive structural match (function with exactly two args)
:macro (arity2 ($f $x $y)) => 2
:macro (arity2 $z) => 0
alphaEq (arity2 (plus 1 2)) 2
alphaEq (arity2 (plus 1 2 3)) 0   # chain has 3 args so pattern length mismatch

# Wildcard inside structural pattern ignored
:macro (ignoreMiddle (triple $a _ $c)) => (pair $a $c)
# Define triple constructor via previously defined macro if absent; fallback pure lambda
triple = λx y z.cons x (cons y (cons z nil))
alphaEq (ignoreMiddle (triple 7 8 9)) (pair 7 9)

# Nested capture reuse: (wrap (plus 0 x)) => x (tests nested structural + existing macro (plus 0 x)->x)
:macro (wrap (plus 0 $x)) => $x
alphaEq (wrap (plus 0 11)) 11

# Composition style structural rewrite: (apply2 f a b) => (f a b) using pattern spine
:macro (apply2 $f $a $b) => ($f $a $b)
alphaEq (apply2 mult 3 4) 12

# Additional macro coverage (specificity + rest + wildcard + int literal pattern)
:macro (specNum 5) => 1
:macro (specNum $x) => 0
alphaEq (specNum 5) 1
alphaEq (specNum 6) 0

# Structural pattern + integer literal vs rest fallback ordering
:macro (prio (cons 0 $t)) => 0
:macro (prio $xs...) => $xs
alphaEq (prio (cons 0 nil)) 0
alphaEq (prio 1 2 3) [1,2,3]

# Wildcard with rest capture (ignored first element) – ensures wildcard neutrality in specificity
:macro (skipFirst _ $xs...) => $xs
alphaEq (skipFirst 9 1 2 3) [1,2,3]

# Structural nesting depth precedence: deeper literal inside structure wins
:macro (deep (cons (cons 1 $x) $t)) => 1
:macro (deep $any) => 0
alphaEq (deep (cons (cons 1 nil) nil)) 1
alphaEq (deep (cons (cons 2 nil) nil)) 0

# Wrap integer literal under plus chain (tests associative neutrality not implemented but pattern anchoring works)
:macro (zeroHead (plus 0 $x)) => $x
alphaEq (zeroHead (plus 0 (plus 0 3))) (plus 0 3)

# Ensure wildcard does not bind (paired with variable capturing same position alternative)
:macro (wtest _ 7) => 1
:macro (wtest $a $b) => 0
alphaEq (wtest 5 7) 1
alphaEq (wtest 5 8) 0


# Wildcard pattern: ignore middle argument
:macro (pick3 $a _ $c) => (pair $a $c)
alphaEq (pick3 1 99 2) (pair 1 2)

# Nested application pattern: (addZero x) => x when first arg is plus 0 x pattern
:macro (plus 0 $x) => $x
alphaEq (plus 0 5) 5

# --- Boolean Logic ---
alphaEq (true 1 0) 1
alphaEq (false 1 0) 0
alphaEq (not true) false
alphaEq (not false) true
alphaEq (and true true) true
alphaEq (and true false) false
alphaEq (or true false) true
alphaEq (xor true true) false
alphaEq (if true 42 99) 42
alphaEq (if false 42 99) 99
alphaEq (eqBool true true) true
alphaEq (eqBool true false) false

# --- Church Numerals ---
alphaEq (zero (λx.1) 0) 0
alphaEq (succ (succ zero)) 2
alphaEq (plus 2 3) 5
alphaEq (mult 3 4) 12
alphaEq (pred 3) 2
alphaEq (minus 5 2) 3
alphaEq (iszero 0) true
alphaEq (iszero 1) false
alphaEq (exp 2 3) 8


# --- Division and Modulo ---
alphaEq (div 7 2) 3
alphaEq (mod 7 2) 1

# --- Comparisons ---
alphaEq (leq 2 3) true
alphaEq (leq 3 2) false
alphaEq (eq 4 4) true
alphaEq (eq 4 5) false
alphaEq (gt 5 2) true
alphaEq (lt 2 5) true
alphaEq (neq 2 2) false
alphaEq (neq 2 3) true

# --- Numeric Operations ---
alphaEq (max 3 7) 7
alphaEq (min 3 7) 3
alphaEq (even 4) true
alphaEq (odd 5) true
alphaEq (square 6) 36
alphaEq (double 8) 16
alphaEq (half 9) 4
alphaEq (pow 2 5) 32

# --- List Operations ---
alphaEq nil nil
alphaEq (isnil nil) true
alphaEq (isnil (cons 1 nil)) false
alphaEq (cons 1 (cons 2 (cons 3 nil))) [1,2,3]
alphaEq (head (cons 1 (cons 2 (cons 3 nil)))) 1
alphaEq (tail (cons 1 (cons 2 (cons 3 nil)))) [2,3]
alphaEq (length (cons 1 (cons 2 (cons 3 nil)))) 3
alphaEq (reverse (cons 1 (cons 2 (cons 3 nil)))) [3,2,1]
alphaEq (append (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil))) [1,2,3,4,5]
alphaEq (map succ (cons 1 (cons 2 (cons 3 nil)))) [2,3,4]
alphaEq (filter even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) [2,4]
alphaEq (foldr plus 0 (cons 1 (cons 2 (cons 3 nil)))) 6
alphaEq (foldl plus 0 (cons 1 (cons 2 (cons 3 nil)))) 6

# --- Advanced List Operations ---
alphaEq (range 5) [0,1,2,3,4]
alphaEq (countdown 3) [3,2,1,0]
alphaEq (zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil))) (zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil)))  # structural tuple pairs may need dedicated eq; kept identity
alphaEq (concat (cons (cons 1 (cons 2 (cons 3 nil))) (cons (cons 4 nil) nil))) [1,2,3,4]

# --- Combinators and Utilities ---
alphaEq (K 42 99) 42
alphaEq (I 77) 77
alphaEq (S (K succ) (K 3) 0) 4
alphaEq (B succ succ 1) 3
alphaEq (C minus 5 2) 0

# --- Recursion and Advanced Functions ---
alphaEq (fact 5) 120
alphaEq (fib 7) 13
alphaEq (gcd 18 24) 6
alphaEq (lcm 6 8) 24

# --- Infix Operators ---
alphaEq (2 + 3) 5
alphaEq (7 - 4) 3
alphaEq (3 * 4) 12
alphaEq (9 / 2) 4
alphaEq (9 % 4) 1
alphaEq (2 ^ 4) 16
alphaEq (true && false) false
alphaEq (false || true) true
alphaEq (5 == 5) true
alphaEq (5 != 4) true
alphaEq (2 < 3) true
alphaEq (2 <= 2) true
alphaEq (4 > 3) true
alphaEq (4 >= 4) true

# --- Maybe/Optional Type ---
alphaEq (just 42) (just 42)
 
# --- Increment / Decrement Sugar ---
# Ensure prefix and postfix ++ / -- behave as succ / pred
alphaEq (++ 0) 1
alphaEq (0 ++) 1
alphaEq (++ 1) 2
alphaEq (1 ++) 2
alphaEq (-- 2) 1
alphaEq (2 --) 1
alphaEq (-- (succ 2)) 2  # (-- 3) == 2
alphaEq ((succ 2) --) 2  # (3 --) == 2

alphaEq nothing nil
alphaEq (isJust (just 1)) true
alphaEq (isNothing (just 1)) false
alphaEq (isNothing nothing) true
alphaEq (fromJust (just 7)) 7
alphaEq (fromMaybe 99 (just 5)) 5
alphaEq (fromMaybe 99 nothing) 99
alphaEq (maybe 0 succ (just 3)) 4
alphaEq (maybe 0 succ nothing) 0

# --- Either Type ---
alphaEq (left 1) (left 1)
alphaEq (right 2) (right 2)
alphaEq (isLeft (left 5)) true
alphaEq (isRight (right 6)) true
alphaEq (either succ pred (left 10)) 11
alphaEq (either succ pred (right 10)) 9

# --- Tree Data Structure ---
alphaEq (leaf 7) (leaf 7)
alphaEq (node 1 (leaf 2) (leaf 3)) (node 1 (leaf 2) (leaf 3))
alphaEq (treeValue (leaf 8)) 8
alphaEq (treeLeft (node 1 (leaf 2) (leaf 3))) (leaf 2)
alphaEq (treeRight (node 1 (leaf 2) (leaf 3))) (leaf 3)
alphaEq (isLeaf (leaf 9)) true
alphaEq (isLeaf (node 1 (leaf 2) (leaf 3))) false

# --- zipWith, scan*, find, partition, splitAt ---
alphaEq (zipWith plus (cons 1 (cons 2 nil)) (cons 10 (cons 20 nil))) [11,22]
alphaEq (scanl plus 0 (cons 1 (cons 2 (cons 3 nil)))) [0,1,3,6]
alphaEq (scanr plus 0 (cons 1 (cons 2 (cons 3 nil)))) [6,5,3,0]
alphaEq (find (eq 2) (cons 1 (cons 2 (cons 3 nil)))) 2
alphaEq (partition even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) (partition even (cons 1 (cons 2 (cons 3 (cons 4 nil)))))  # complex tuple result; identity check
alphaEq (splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))) (splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil)))))

# --- Edge Cases and Safe Functions ---
alphaEq (safeMinimum nil) nothing
alphaEq (safeMaximum nil) nothing
alphaEq (safeMinimum (cons 3 (cons 1 (cons 2 nil)))) (just 1)
alphaEq (safeMaximum (cons 3 (cons 1 (cons 2 nil)))) (just 3)
alphaEq (clamp 2 4 1) 2
alphaEq (clamp 2 4 3) 3
alphaEq (clamp 2 4 5) 4

# --- Miscellaneous ---
alphaEq (compose succ succ 1) 3
alphaEq (flip minus 2 5) 3
alphaEq (on plus succ 2 3) 7
alphaEq (apply succ 4) 5
alphaEq ((partial plus 2) 3) 5  # (partial f a) returns unary function; apply to one arg
alphaEq ((partial2 plus 2 3) 4) 9
alphaEq (memoize succ 10) 11
alphaEq (id2 123) 123
alphaEq (const2 7 8) 7

# --- Additional List Operations ---
alphaEq (take 3 (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))) [1,2,3]
alphaEq (drop 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))) [3,4]
alphaEq (nth 2 (cons 10 (cons 20 (cons 30 (cons 40 nil))))) 30
alphaEq (any (λx.gt x 3) (cons 1 (cons 2 (cons 5 nil)))) true
alphaEq (all even (cons 2 (cons 4 (cons 6 nil)))) true
alphaEq (all even (cons 2 (cons 3 (cons 6 nil)))) false
alphaEq (sum (cons 1 (cons 2 (cons 3 (cons 4 nil))))) 10
alphaEq (product (cons 2 (cons 3 (cons 4 nil)))) 24
alphaEq (maximum (cons 1 (cons 5 (cons 3 (cons 2 nil))))) 5
alphaEq (minimum (cons 4 (cons 1 (cons 3 (cons 2 nil))))) 1

# --- Advanced List Utilities ---
alphaEq (elem 3 (cons 1 (cons 2 (cons 3 nil)))) true
alphaEq (elem 5 (cons 1 (cons 2 (cons 3 nil)))) false
alphaEq (notElem 5 (cons 1 (cons 2 (cons 3 nil)))) true
alphaEq (nub (cons 1 (cons 2 (cons 1 (cons 3 (cons 2 nil)))))) [3, 2, 1]
alphaEq (unique (cons 1 (cons 2 (cons 1 (cons 3 nil))))) [3, 2, 1]
alphaEq (last (cons 1 (cons 2 (cons 3 nil)))) 3
alphaEq (init (cons 1 (cons 2 (cons 3 nil)))) [1,2]
alphaEq (safeInit nil) nil
alphaEq (safeInit (cons 1 nil)) nil
alphaEq (safeDiv 10 2) (just 5)
alphaEq (safeDiv 10 0) nothing
alphaEq (safeInitMaybe nil) nothing
alphaEq (safeInitMaybe (cons 1 nil)) nothing
alphaEq (safeInitMaybe (cons 1 (cons 2 nil))) (just [1])
alphaEq (safeInit (cons 1 (cons 2 nil))) [1]
alphaEq (safeInitMaybe (cons 1 (cons 2 (cons 3 nil)))) (just [1,2])
alphaEq (safeDiv 10 2) (safediv 10 2)

# --- Enumeration and Range Functions ---
alphaEq (enumFromTo 3 7) [3,4,5,6,7]
alphaEq (enumFrom 5 4) [5,6,7,8]
alphaEq (iota 4) [0,1,2,3]
alphaEq (replicate 3 7) [7,7,7]
alphaEq (repeat 3 9) [9,9,9]

# --- Iteration and Application ---
alphaEq (iterate succ 5 0) 5
alphaEq (times 3 (succ 1)) 8
alphaEq (when true succ 5) 6
alphaEq (when false succ 5) 5
alphaEq (unless true succ 5) 5
alphaEq (unless false succ 5) 6
alphaEq (cond true 42 99) 42

# --- Pair Operations ---
alphaEq (pair 1 2) (pair 1 2)
alphaEq (first (pair 10 20)) 10
alphaEq (second (pair 10 20)) 20
alphaEq (swap (pair 1 2)) (pair 2 1)

# --- Advanced Numeric Functions ---
alphaEq (abs 5) 5
alphaEq (sqrt 16) 4
alphaEq (sqrt 25) 5
alphaEq (isPrime 7) true
alphaEq (isPrime 8) false
alphaEq (isPrime 2) true
alphaEq (isPrime 1) false
alphaEq (primes 10) [2,3,5,7]

# --- String/Character Operations ---
# words / unwords expectations left descriptive due to encoding specifics
# words (cons 104 (cons 101 (cons 108 (cons 108 (cons 111 nil)))))
# unwords (cons (cons 104 (cons 105 nil)) (cons (cons 121 (cons 111 nil)) nil))

# --- Set Operations on Lists ---
alphaEq (union (cons 1 (cons 2 nil)) (cons 2 (cons 3 nil))) [1,2,3]
alphaEq (intersect (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 3 (cons 4 nil)))) [2,3]
alphaEq (difference (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 4 nil))) [1,3]
alphaEq (isSubset (cons 1 (cons 2 nil)) (cons 1 (cons 2 (cons 3 nil)))) true
alphaEq (isSuperset (cons 1 (cons 2 (cons 3 nil))) (cons 1 (cons 2 nil))) true

# --- Advanced Combinators ---
alphaEq (omega I) I
alphaEq (mockingbird I) I
alphaEq (thrush 5 succ) 6
alphaEq (cardinal minus 3 10) 7
alphaEq (bluebird succ pred 5) 5
alphaEq (kestrel 42 99) 42
alphaEq (warbler plus 3) 6
alphaEq (starling (K succ) (K 2) 0) 3

# --- Curry and Uncurry Functions ---
alphaEq (curry3 (λt.plus (first t) (plus (first (second t)) (second (second t)))) 1 2 3) 6
alphaEq (uncurry plus (pair 7 3)) 10
alphaEq (uncurry3 (λx y z.plus x (plus y z)) (pair 1 (pair 2 3))) 6

# --- More Maybe Operations ---
alphaEq (maybeMap succ (just 5)) (just 6)
alphaEq (maybeMap succ nothing) nothing

# --- Maybe Monadic / Applicative Helpers (new 2025-09) ---
alphaEq (maybeBind (just 3) (λx.just (plus x 1))) (just 4)

# -----------------------------------------------------------------------------
# Capture-avoidance, Strategy Cross-Checks, and Binder Mode Tests
# -----------------------------------------------------------------------------

# Capture-avoidance: ensure inner binder does not capture free variable
alphaEq ((λx. λy. x) z) (λy. z)           # different names, no collision
alphaEq ((λx. λy. x) y) (λt. y)           # collision case requires alpha-conversion

# Binder mode (De Bruijn) correctness for the same reductions
:binder debruijn on
alphaEq ((λx. λy. x) z) (λy. z)
alphaEq ((λx. λy. x) y) (λt. y)
:binder debruijn off
alphaEq ((λx. λy. x) z) (λy. z)

# Strategy cross-checks: conditionals must short-circuit consistently
:strategy cbv
alphaEq (if true 1 (omega)) 1
:strategy need
alphaEq (if true 1 (omega)) 1
:strategy cbv
alphaEq ((λx. plus x 1) 5) 6
:strategy need
alphaEq ((λx. plus x 1) 5) 6

# --- Quasiquote / Unquote (initial) ---
# Quasiquote is a macro-only quoting form; after expansion, qq(expr) becomes expr.
alphaEq (qq (plus 1 2)) 3
alphaEq (` (mult 2 3)) 6
# Unquote binds to the following expression; use parentheses to keep atomic
alphaEq (qq (plus ~( (succ 1) ) 3)) 5
alphaEq (qq ((λx.plus x 1) ~ 2)) 3
alphaEq (maybeBind nothing (λx.just (plus x 1))) nothing
alphaEq (maybeAp (just succ) (just 4)) (just 5)
alphaEq (maybeAp nothing (just 4)) nothing
alphaEq (maybeMap2 plus (just 2) (just 3)) (just 5)
alphaEq (maybeMap2 plus (just 2) nothing) nothing

# --- Either Monadic / Applicative Helpers ---
alphaEq (eitherBind (right 3) (λx.right (plus x 1))) (right 4)
alphaEq (eitherBind (left  1) (λx.right (plus x 1))) (left 1)
alphaEq (eitherAp (right succ) (right 4)) (right 5)
alphaEq (eitherAp (left  9) (right 4)) (left 9)
alphaEq (eitherMap (λx.plus x 1) (right 4)) (right 5)
alphaEq (eitherMapLeft (λx.plus x 1) (left 4)) (left 5)
alphaEq (eitherMap2 plus (right 2) (right 3)) (right 5)

# --- Show Helper Head Character Checks ---
# 't'=116, 'f'=102, 'J'=74, 'N'=78, 'L'=76, 'R'=82
alphaEq (head (showBool true)) 116
alphaEq (head (showBool false)) 102
alphaEq (head (showMaybe (λx.[120]) (just 42))) 74
alphaEq (head (showMaybe (λx.[120]) nothing)) 78
alphaEq (head (showEither (λx.[120]) (λx.[121]) (left 99))) 76
alphaEq (head (showEither (λx.[120]) (λx.[121]) (right 99))) 82

# --- State Monad (simplified) ---
alphaEq (runState (returnState 42) 0) (runState (returnState 42) 0)
alphaEq (runState getState 123) (runState getState 123)

# --- Advanced Tree Operations ---
alphaEq (treeSize (leaf 1)) 1
alphaEq (treeSize nil) 0
alphaEq (treeDepth (leaf 1)) 1
alphaEq (treeDepth nil) 0
alphaEq (inOrder (leaf 5)) [5]
alphaEq (preOrder (leaf 5)) [5]
alphaEq (postOrder (leaf 5)) [5]

# --- Edge Cases and Error Conditions ---
alphaEq (div 5 0) 0
alphaEq (mod 5 0) 0
alphaEq (head nil) nil
alphaEq (tail nil) nil
alphaEq (pred 0) 0
alphaEq (minus 3 5) 0

# --- Complex Expressions ---
alphaEq (map (λx.mult x x) (range 5)) [0,1,4,9,16]
alphaEq (filter (λx.eq (mod x 3) 0) (range 10)) [0,3,6,9]
alphaEq (foldr max 0 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil)))))) 9
alphaEq (foldl min 999 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil)))))) 1

# --- Recursive Function Tests ---
alphaEq (factRec 4) 24
alphaEq (fibRec 6) 8
alphaEq (sumUptoRec 5) 15

# --- Performance / Stress (sanity) ---
alphaEq (length (range 50)) 50
alphaEq (sum (range 10)) 45
alphaEq (fact 6) 720
alphaEq (fib 10) 55

# --- Y combinator derived functions ---
alphaEq (factY 4) 24
alphaEq (fibY 6) 8
alphaEq (sumUptoY 5) 15
alphaEq (expY 2 5) 32
alphaEq (rangeY 10) [0,1,2,3,4,5,6,7,8,9]
alphaEq (countdownY 5) [5,4,3,2,1,0]
alphaEq (gcdY 48 18) 6
alphaEq (lcmY 12 15) 60
alphaEq (mapY succ (range 5)) [1,2,3,4,5]
alphaEq (filterY (λx.eq (mod x 2) 0) (range 10)) [0,2,4,6,8]
alphaEq (lengthY (range 50)) 50
alphaEq (reverseY (range 5)) [4,3,2,1,0]

# --- Print Helper (side-effecting) ---
# Ensure print returns its argument unchanged (label and no-label forms) and composes in pipeline
alphaEq (print 5) 5
alphaEq (print "msg" 7) 7
alphaEq (print "n" 4 |> succ) 5

# --- Trace / Tap Helpers (new 2025-09) ---
# trace label x  => returns x (prints label & value)
# traceVal x     => returns x (prints value)
# traceSilent l x=> returns x (no print)
# tap / tapv pipeline macros expand to trace / traceVal respectively
fY = Y (λf.λn.if (n <= 2) 1 ((n - 1 |> trace "fy1" |> f) + (n - 2 |> trace "fy2" |> f)))
alphaEq (fY 5) 5
alphaEq (fY 10) 55
alphaEq (fY 15) 610
alphaEq (map (\x.fY x) [1..10]) [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
alphaEq (trace "fib" 10) 10
alphaEq (traceVal 42) 42
alphaEq (traceSilent "nope" 99) 99
alphaEq (5 |> tap "k") 5
alphaEq (5 |> tapv) 5
# Pipeline preservation of value through tracing
alphaEq (5 |> tap "pre" |> succ) 6
alphaEq (5 |> tapv |> succ) 6
alphaEq ((succ 4) |> tap "s" |> tapv |> succ) 6
alphaEq (let x = 3 in x |> tap "x" |> tapv |> square) 9
alphaEq ( (trace "lbl" (succ 1)) |> succ ) 3
alphaEq ( (traceVal (succ 2)) |> succ ) 4
alphaEq ( (traceSilent "hidden" (succ 3)) |> succ ) 5

# --- Lazy Trace Delay Variants (new) ---
alphaEq (traceDelay "lz1" (delay (succ 4))) 5
alphaEq (traceDelayVal (delay (succ 5))) 6
alphaEq (5 |> tapd "d" |> succ) 6
alphaEq (5 |> tapdv |> succ) 6

alphaEq (sumY (range 5)) 10
alphaEq (productY (tail (range 7))) 720
alphaEq (anyY (λx.gt x 3) (range 5)) true
alphaEq (allY (λx.leq x 5) (range 5)) true
alphaEq (findY (λx.eq x 3) (range 5)) 3

alphaEq [1,2,3] [1,2,3]
alphaEq [1,3 .. 6] [1,3,5]
alphaEq [1,2,3,[4..7],[11 .. 8]] [1,2,3,[4,5,6,7],[11,10,9,8]]

alphaEq (mapY (ackermann 2) [2..10]) [7,9,11,13,15,17,19,21,23]

# --- Let and Let Rec Examples ---
alphaEq (let x = 5 in x + 2) 7
alphaEq (let x = 1, y = 2 in x + y) 3
alphaEq (let a = 10, b = 20, c = 30 in a + b + c) 60
alphaEq (let x = 2, y = 3 in x * (y + 1)) 8
alphaEq (let rec fact = \n. if (eq n 0) 1 (mult n (fact (pred n))) in fact 5) 120
alphaEq (let rec fib = \n. if (leq n 1) n (plus (fib (pred n)) (fib (minus n 2))) in fib 6) 8
alphaEq (let rec sumTo = \n. if (eq n 0) 0 (plus n (sumTo (pred n))) in sumTo 4) 10

# --- Macro Expansion inside let / let rec (iff) ---
# Ensure iff macro expands inside non-recursive let binding
alphaEq (let f = n -> (iff (iszero n) then 1 else (succ n)) in f 0) 1
alphaEq (let f = n -> (iff (iszero n) then 1 else (succ n)) in f 5) 6

# Ensure iff macro expands inside recursive let binding (with and without outer parens)
alphaEq (let rec fact = n -> (iff (iszero n) then 1 else (mult n (fact (pred n)))) in fact 4) 24
alphaEq (let rec fact = n -> iff (iszero n) then 1 else (mult n (fact (pred n))) in fact 4) 24

# Macro inside later binding referencing earlier binding value
alphaEq (let a = 1 in let b = (iff (eq a 1) then 2 else 3) in a + b) 3

# --- Macro Expansion inside let / let rec (when / unless) ---
# Non-recursive let with when
alphaEq (let add1IfZero = n -> (when (iszero n) succ n) in add1IfZero 0) 1
alphaEq (let add1IfZero = n -> (when (iszero n) succ n) in add1IfZero 5) 5

# Non-recursive let with unless
alphaEq (let add1UnlessZero = n -> (unless (iszero n) succ n) in add1UnlessZero 0) 0
alphaEq (let add1UnlessZero = n -> (unless (iszero n) succ n) in add1UnlessZero 5) 6

# Multi-binding referencing earlier binding
alphaEq (let x = 0 in let y = (when (iszero x) succ 5) in y) 6
alphaEq (let x = 0 in let y = (unless (iszero x) succ 5) in y) 5

# Recursive let using when inside body
alphaEq (let rec countdown = n -> (when (gt n 0) pred n) in countdown 3) 2
alphaEq (let rec countdown = n -> (when (gt n 0) pred n) in countdown 0) 0

# Recursive let using unless inside body
alphaEq (let rec upIfLess5 = n -> (unless (geq n 5) succ n) in upIfLess5 3) 4
alphaEq (let rec upIfLess5 = n -> (unless (geq n 5) succ n) in upIfLess5 5) 5

# --- Pipeline Operator (|>) ---
alphaEq (5 |> succ) 6
alphaEq (5 |> square) 25
alphaEq (5 |> square |> succ) 26
alphaEq (5 |> succ |> square) 36
alphaEq (1 |> succ |> succ |> succ) 4
alphaEq ((5 |> square) |> succ) 26
alphaEq (5 |> (square |> succ)) 125
alphaEq (2 |> succ |> square |> pred) 8

# --- Arrow Function Syntax ---
alphaEq ((x -> x + 1) 5) 6
alphaEq ((x -> succ x) 4) 5
alphaEq ((x, y -> x + y) 3 2) 5
alphaEq ((x, y -> mult x y) 4 3) 12
alphaEq ((x -> x * x) 6) 36
alphaEq ((x, y, z -> x + y + z) 1 2 3) 6
alphaEq (let f = x -> x + 1 in f 10) 11
alphaEq (let add = x, y -> x + y in add 7 8) 15
alphaEq (let add = x -> y -> x + y in let mult2 = x -> x * 2 in let div2 = x -> x / 2 in (add 5 3) |> mult2 |> div2) 8
alphaEq (let add = x, y -> x + y in let mult2 = x -> x * 2 in let div2 = x -> x / 2 in (add 5 3) |> mult2 |> div2) 8
alphaEq (3 |> (x -> x + 1) |> (y -> y * 2)) 8
alphaEq ((x -> y -> x + y) 5 3) 8
alphaEq ((f -> x -> f (f x)) succ 0) 2
alphaEq (map (x -> x + 1) [1,2,3]) [2,3,4]
alphaEq (filter (x -> x > 2) [1,2,3,4,5]) [3,4,5]
# Parsing sanity (expression form) - cannot structural test without full desugaring; skip

# --- Composition Operator (∘) & Chaining (.) ---
inc = x -> x + 1
double2 = x -> x * 2   # renamed from 'double' to avoid shadowing stdlib/native name
square = x -> x * x

# True function composition via ∘
alphaEq ((inc ∘ double2) 3) 7              # inc(double2 3)
alphaEq ((double2 ∘ inc) 3) 8              # double2(inc 3)
alphaEq ((square ∘ inc) 4) 25              # square(inc 4)
alphaEq (((inc ∘ double2) ∘ square) 2) 9   # nested left assoc
alphaEq (((double2 ∘ inc) ∘ square) 2) 10
alphaEq ((inc ∘ double2) 3 |> square) 49   # pipeline after composition

# Associativity: (f∘g)∘h == f∘(g∘h)
alphaEq (((inc ∘ double2) ∘ square) 2) ((inc ∘ (double2 ∘ square)) 2)

# Identity interaction (I from stdlib assumed)
alphaEq ((inc ∘ I) 5) (inc 5)

# Dot '.' chaining sugar (application only, not composition)
alphaEq (inc . 3) 4              # (inc 3)
alphaEq (succ . 5) 6             # (succ 5)
alphaEq (inc . double2 . 3) (inc (double2 3))   # demonstrates old-style now different semantics

# --- Application operator ($) tests ---
alphaEq (succ (pred 5)) (succ $ pred 5)
alphaEq (succ (pred (succ 4))) (succ $ pred $ succ 4)
alphaEq (map (λx.mult x x) (filter (λx.gt x 2) (range 6))) (map (λx.mult x x) $ filter (λx.gt x 2) $ range 6)

# Macro with $ usage
:macro (m $x) => succ $x
alphaEq (m 4) 5

# --- Advanced Multi-Feature Tests ---
alphaEq (foldr plus 0 (filter (λx.gt x 2) (map (λx.mult x x) (range 5)))) 29
alphaEq (let double2 = x -> x * 2 in (map double2 [1,2,3,4]) |> (filter (x -> x > 4))) [6,8]
alphaEq (let rec sumEvens = \xs. if (isnil xs) 0 (if (even (head xs)) (plus (head xs) (sumEvens (tail xs))) (sumEvens (tail xs))) in sumEvens [1,2,3,4,5,6]) 12
alphaEq ((maybeMap (x -> x * x) (just 7)) |> (maybe 0 (x -> x + 1))) 50
alphaEq (let tree = node 1 (leaf 2) (node 3 (leaf 4) (leaf 5)) in foldr plus 0 (inOrder tree)) 15
alphaEq (map (x -> map (y -> x * y) [1,2,3]) [4,5]) [[4,8,12],[5,10,15]]
alphaEq (let add3 = x -> y -> z -> x + y + z in (add3 1 2) |> (f -> f 3)) 6
alphaEq (find (x -> x % 6 == 0) (map (x -> x + 1) [1,3,5,7,8])) 6
alphaEq (foldl mult 1 (map (pair -> plus (first pair) (second pair)) (zip [1,2,3] [4,5,6]))) 315
alphaEq (let f = x -> x * 3 in (map f (filter (x -> x > 2) (range 7))) |> (foldl plus 0)) 54

# Maybe monad tests using stdlib encoding (pair-based)
bind = λm f. if (isNothing m) nothing (f (fromJust m))
alphaEq (bind (just 3) (λx. just (x + 1))) (just 4)
alphaEq (bind nothing (λx. just (x + 1))) nothing

# Lambda placeholder examples
alphaEq ((\_ . 42) 123) 42
alphaEq ((\_ _ . 99) 1 2) 99
alphaEq ((\x _ . x) 7 8) 7
alphaEq ((\_ y . y) 5 6) 6
alphaEq ((_ , _ -> 0) 10 20) 0
alphaEq ((x, _ -> x) 42 99) 42
alphaEq (let f = \_ . 123 in f 456) 123
alphaEq (let g = \_ _ . 1 in g 2 3) 1
alphaEq (let h = \_ y . y in h 0 9) 9

# --- def function definition sugar ---
def inc2 x = x + 1
def add2 x y = x + y
def const42 = 42
alphaEq (inc2 5) 6
alphaEq (add2 3 4) 7
alphaEq const42 42
alphaEq (let z = 10 in add2 (inc2 z) const42) 53

# Macro System Tests
:macro (letbind $var $val $expr) => ((λ$var.$expr) $val)
alphaEq ((letbind x 42 (plus x 10))) 52
alphaEq ((letbind y 5 (mult y y))) 25
alphaEq ((letbind z 3 (exp 2 z))) 8
:macro (dup $x) => (plus $x $x)  # renamed from (double $x)
alphaEq ((dup 7)) 14
alphaEq ((dup (succ 4))) 10
:macro (triple $x) => (plus $x (plus $x $x))
alphaEq ((triple 8)) 24
:macro (when $cond $expr) => (if $cond $expr I)
alphaEq ((when true (succ 10))) 11
alphaEq ((when false (succ 10))) I
:macro (unless $cond $expr) => (if $cond I $expr)
alphaEq ((unless false (succ 20))) 21
alphaEq ((unless true (succ 20))) I
for x at [1..10] do (succ x)  # retains list output
for x at [1..10] do (square x)
for x at [1..10] do (div x 2)
for x at [1..10] do (mod x 2)
alphaEq (iff false then 42 else 9) 9
alphaEq (iff true then 42 else 9) 42
:macro (swappair $p) => (pair (second $p) (first $p))
alphaEq ((swappair (pair 1 2))) (pair 2 1)
:macro (list3 $a $b $c) => (cons $a (cons $b (cons $c nil)))
alphaEq ((list3 1 2 3)) [1,2,3]
:macro (square $x) => (mult $x $x)
alphaEq ((square 6)) 36
alphaEq ((square (plus 3 2))) 25
:macro (cube $x) => (mult $x (mult $x $x))
alphaEq ((cube 3)) 27
:macro (between $x $low $high) => (and (geq $x $low) (leq $x $high))
alphaEq ((between 5 3 7)) true
alphaEq ((between 2 3 7)) false
alphaEq ((between 8 3 7)) false
:macro (inc $x) => (succ $x)
:macro (dec $x) => (pred $x)
alphaEq ((inc 10)) 11
alphaEq ((dec 10)) 9
alphaEq ((inc (square 4))) 17
alphaEq ((square (inc 4))) 25
:macro (quadratic $a $b $c $x) => (plus (mult $a (square $x)) (plus (mult $b $x) $c))
alphaEq ((quadratic 2 3 1 4)) 45
:macro (fact2 $n) => (if (iszero $n) 1 (mult $n (fact2 (pred $n))))  # not structurally testable (recursive macro) left as definition

# Additional macro capability tests already at end of original file (kept as-is or identity comparisons)

# ============================================================================
# Extended Coverage: Advanced Macro / Variadic / Guards / Ordering / Lazy / Church Lists
# ============================================================================

# --- Advanced Macro System (Arity & Ordering) ---
:macro (arityDemo) => 0
:macro (arityDemo $a) => 1
:macro (arityDemo $a $b) => 2
alphaEq (arityDemo) 0
alphaEq (arityDemo 42) 1
alphaEq (arityDemo 7 8) 2

# --- Variadic Macros ---
:macro (listify $xs...) => $xs
alphaEq (listify) nil
alphaEq (listify 1) [1]
alphaEq (listify 1 2 3) [1,2,3]

# Variadic with fixed prefix
:macro (sumall $x $rest...) => (foldl plus $x $rest)
alphaEq (sumall 5) 5
alphaEq (sumall 1 2 3 4) 10

# --- Guarded Macros & Recency ---
:macro (choose $x) when false => 0
:macro (choose $x) => $x
alphaEq (choose 9) 9

:macro (choose2 $x) => $x
:macro (choose2 $x) when true => 42
alphaEq (choose2 7) 42

# Guard depending on variable (literal false only fails)
:macro (guardVar $flag $x) => 0
:macro (guardVar $flag $x) when $flag => $x
alphaEq (guardVar true 7) 7
alphaEq (guardVar false 7) 0

# Higher arity precedence
:macro (pref $x $y) => (mult $x $y)
:macro (pref $x) => (succ $x)
alphaEq (pref 3 4) 12
alphaEq (pref 5) 6

# Recency (shadowing)
:macro (shadow $x) => (plus $x 1)
:macro (shadow $x) => (plus $x 2)
alphaEq (shadow 3) 5

# Exact match vs rest capture precedence
:macro (mix $a $b) => (plus $a $b)
:macro (mix $a $rest...) => (foldl plus $a $rest)
alphaEq (mix 2 3) 5
alphaEq (mix 2 3 4 5) 14

# --- Pair Equality Helper (uses stdlib pairEq) ---
alphaEq (pairEq eq eq (pair 1 2) (pair 1 2)) true

# --- Church List Round Trip ---
# Build a Church-encoded list and fold it with cons/nil to a concrete list
alphaEq (((λf.λz.f 1 (f 2 (f 3 z))) (λh.λt.cons h t)) nil) [1,2,3]

# --- Lazy Evaluation (ensure unused branch not evaluated) ---
# Ω (diverges if forced) = (λx.x x) (λx.x x); use built inline
alphaEq (if true 1 ((λx.x x) (λx.x x))) 1

# --- Variadic / Utility Macro Extensions ---
:macro (duplicate $x) => (pair $x $x)
alphaEq (duplicate 7) (pair 7 7)

# Complex nested macro example for process style (inc (square (dec x)))
:macro (dec2 $x) => (pred $x)
:macro (process2 $x) => (inc (square (dec2 $x)))
alphaEq (process2 5) 17

# Macro composition ordering (outer/inner)
:macro (outer $x) => (inner (plus $x 1))
:macro (inner $y) => (mult $y 2)
alphaEq (outer 4) 10

# Apply twice (higher-order macro)
:macro (apply_twice $f $x) => ($f ($f $x))
alphaEq (apply_twice succ 0) 2
alphaEq (apply_twice (λx.mult x 2) 3) 12

# Composition macro reuse with new 'dup' macro already defined earlier
:macro (compose2b $f $g $x) => ($f ($g $x))
alphaEq (compose2b succ dup 5) 11

# Final complex macro calculation (mirrors complex_calc)
:macro (complex_calc $a $b $c) => (letbind x (plus $a $b) (letbind y (mult x $c) (square y)))
alphaEq (complex_calc 2 3 4) 400

# Note: Eta-equivalence not tested (λx.f x vs f) – current equality is alpha only.

# ============================================================================
# Essential Additional Core Law Tests
# ============================================================================

# Alpha-equivalence (binder renaming) & capture avoidance
alphaEq (λx.λy.x) (λa.λb.a)
alphaEq ((λx.λy.x) 1) (λz.1)
alphaEq (λx.λx.λx.x) (λa.λb.λc.c)  # inner shadowing
alphaEq ((λx.λx.λx.x) 1 2 3) ((λa.λb.λc.c) 1 2 3) # inner shadowing with application

# Combinator Laws
alphaEq ((S K K) 5) 5
alphaEq ((S K I) 7) 7

# Arithmetic Identity Laws
alphaEq (plus 7 0) 7
alphaEq (plus 0 9) 9
alphaEq (mult 9 1) 9
alphaEq (mult 9 0) 0
alphaEq (minus 5 0) 5

# List Functor Identity
alphaEq (map I [1,2,3]) [1,2,3]

# Lazy Evaluation (false branch)
alphaEq (if false ((λx.x x) (λx.x x)) 2) 2

# Nested Pair Equality using pairEq
# alphaEq (pairEq eq eq (pair (pair 1 2) (pair 3 4)) (pair (pair 1 2) (pair 3 4))) true

# ============================================================================
# Additional Positive Law / Property Tests (no negatives)
# ============================================================================

# Maybe Functor Laws
alphaEq (maybeMap I (just 5)) (just 5)                     # identity
alphaEq (maybeMap (λx.mult x x) (maybeMap succ (just 3))) (just 16)   # composition exemplar

# Either usage (Right-biased behavior already covered)
alphaEq (either succ succ (left 5)) 6
alphaEq (either succ succ (right 5)) 6

# Append associativity
alphaEq (append (append [1] [2]) [3]) (append [1] (append [2] [3]))

# Reverse distributes over append: reverse (xs ++ ys) = reverse ys ++ reverse xs
alphaEq (reverse (append [1,2] [3,4,5])) (append (reverse [3,4,5]) (reverse [1,2]))

# Map length invariant
alphaEq (length (map succ [1,2,3,4])) (length [1,2,3,4])

# Sum via fold equivalence
alphaEq (sum [1,2,3,4]) (foldl plus 0 [1,2,3,4])

# Maybe bind laws (using bind defined above)
alphaEq (bind (just 5) (λx.just (plus x 1))) (just 6)      # left identity exemplar
alphaEq (bind (just 7) just) (just 7)                     # right identity exemplar

# Tree: size equals length of inorder traversal
alphaEq (treeSize (node 1 (leaf 2) (leaf 3))) (length (inOrder (node 1 (leaf 2) (leaf 3))))

# test multiple commands in a single line
plus 1 3; mult 2 4; minus 5 1; fib 10
plus 4 3; :macro (aa $a) => (plus $a $a); aa 4
plus 4 3; :macro (bb $a) => (plus $a $a); bb 4; :macro (cc $b) => (mult $b $b); cc 5 # define and call macros


# test different ways to define and use fibonacci
alphaEq (let rec fib2 = n -> if (n <= 2) 1 ((n - 1 |> fib2) + (n - 2 |> fib2)) in fib2 10) 55
alphaEq (let rec fib3 = n -> if (n <= 2) 1 (fib3(n - 1) + fib3(n - 2)) in fib3 10) 55
fib4 = n -> if (n <= 2) 1 ((n - 1 |> fib4) + (n - 2 |> fib4))
fib5 = n -> if (n <= 2) 1 (fib5(n - 1) + fib5(n - 2))
alphaEq (fib4 10) 55
alphaEq (fib5 10) 55
fib6 = Y (\f.\n. if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n)))))
alphaEq (fib6 10) 55
fib7 = Y (\f. \n. if (n <= 2) 1 ((f (n - 1)) + (f (n - 2))))
alphaEq (fib7 10) 55
fib8 = n -> if (n <= 2) 1 ((fib8 . -- n) + (fib8 . -- . -- n))
alphaEq (fib8 10) 55
fib9 = n -> if (n <= 2) 1 ((fib9 $ -- n) + (fib9 $ -- $ -- n))
alphaEq (fib9 10) 55

# ============================================================================
# Added Extended Coverage (new)
# Focus: WHILE combinator, gcd1, ackermann small cases, State monad sequencing,
# structural equality helper families, safe* functions, ASCII predicates,
# unzip, listEq/maybeEq/eitherEq negative cases, tolower/toupper, list unzip.
# ============================================================================

# WHILE loop basic countdown (should reach 0)
alphaEq (WHILE (λn.gt n 0) pred 5) 0

# gcd1 (WHILE-based) correctness vs known value
alphaEq (gcd1 48 18) 6

# Ackermann small direct values (pattern observed: ackermann 2 n = 2n + 3)
alphaEq (ackermann 2 2) 7
alphaEq (ackermann 2 3) 9

# State monad: putState and bindState sequencing
alphaEq (runState (putState 99) 42) (pair nil 99)

# Construct a composite state computation: double state, then increment value & state
doubleThenInc = bindState (λs.pair (mult s 2) (mult s 2)) (λres. λs.pair (succ res) (succ s))
alphaEq (runState doubleThenInc 3) (pair 7 7)

# Structural equality helpers (listEq / maybeEq / eitherEq)
alphaEq (listEq eq [1,2,3] [1,2,3]) true
alphaEq (listEq eq [1,2,3] [1,2]) false
alphaEq (maybeEq eq (just 5) (just 5)) true
alphaEq (maybeEq eq (just 5) nothing) false
alphaEq (eitherEq eq eq (left 3) (left 3)) true
alphaEq (eitherEq eq eq (left 3) (right 3)) false

# Safe head/tail/nth/div operations
alphaEq (safehead [1,2,3]) (just 1)
alphaEq (safehead nil) nothing
alphaEq (safetail [1,2,3]) (just [2,3])
alphaEq (safetail nil) nothing
alphaEq (safenth 1 [10,20,30]) (just 20)
alphaEq (safenth 5 [10]) nothing
alphaEq (safeDiv 12 3) (just 4)
alphaEq (safeDiv 12 0) nothing

# ASCII predicates and case conversion
alphaEq (isdigit 48) true
alphaEq (isdigit 65) false
alphaEq (isalpha 65) true
alphaEq (isalpha 48) false
alphaEq (isspace 32) true
alphaEq (isspace 65) false
alphaEq (toupper 97) 65
alphaEq (toupper 33) 33
alphaEq (tolower 65) 97
alphaEq (tolower 48) 48

# unzip (zip round trip)
alphaEq (unzip (zip [1,2] [3,4])) (pair [1,2] [3,4])

# listEq nested usage example (list of lists)
alphaEq (listEq (listEq eq) [[1,2],[3]] [[1,2],[3]]) true
alphaEq (listEq (listEq eq) [[1,2],[3]] [[1,2],[4]]) false

# Additional numeric predicate & helper coverage
alphaEq (isone 1) true
alphaEq (isone 2) false
alphaEq (istwo 2) true
alphaEq (istwo 3) false
alphaEq (ispositive 0) false
alphaEq (ispositive 3) true
alphaEq (triple 4) 12
alphaEq (quadruple 3) 12

# GCD / LCM edge cases with zero
alphaEq (gcd 0 7) 7
alphaEq (gcd 9 0) 9
alphaEq (gcd1 0 7) 7
alphaEq (lcm 0 5) 0

# ============================================================================
# Added Coverage (Sets 3,4,5,7,8,9,10,11,12)
# ============================================================================

# 3. Numeric edge / arithmetic laws
alphaEq (pred 1) 0
alphaEq (minus 2 5) 0          # floor at zero
alphaEq (iszero (minus 10 10)) true
alphaEq (mult 3 (plus 2 4)) (plus (mult 3 2) (mult 3 4))    # distributive exemplar
alphaEq (plus (plus 1 2) 3) (plus 1 (plus 2 3))             # associativity exemplar

# 4. List algebraic laws
alphaEq (append [1,2,3] nil) [1,2,3]
alphaEq (append nil [1,2,3]) [1,2,3]
alphaEq (reverse (reverse [1,2,3])) [1,2,3]
alphaEq (map succ (map succ [1,2,3])) (map (λx.succ (succ x)) [1,2,3])  # fusion exemplar
alphaEq (length (append [1,2] [3,4,5])) (plus (length [1,2]) (length [3,4,5]))
alphaEq (foldr plus 0 [1,2,3,4]) (foldl plus 0 [1,2,3,4])

# 5. Maybe / Either additional laws
alphaEq (maybe 0 I (just 5)) 5
alphaEq (maybe 0 I nothing) 0
alphaEq (either I I (right 7)) 7
alphaEq (either I I (left  7)) 7

# 7. WHILE combinator equivalence with recursive countdown
alphaEq (WHILE (λn.gt n 0) pred 5) 0
alphaEq (let rec cd = n -> if (gt n 0) (cd (pred n)) 0 in (pair (WHILE (λn.gt n 0) pred 5) (cd 5))) (pair 0 0)
alphaEq (WHILE (λn.leq n 16) (mult 2) 1) 32

# 8. Range edge cases
alphaEq [10,8 .. 4] [10,8,6,4]
alphaEq [-3 .. -1] [-3,-2,-1]

# 9. Composition vs application sanity
# Composition uses ∘ ; '.' is chaining.
alphaEq ((succ ∘ pred) 6) (succ (pred 6))
alphaEq ((succ ∘ pred) (succ 5)) (succ (pred (succ 5)))
alphaEq (succ $ pred $ succ 5) (succ (pred (succ 5)))

# 10. Placeholder underscore captures (additional)
alphaEq ((_ -> 1) 99) 1
alphaEq ((_,_ -> 0) 1 2) 0
alphaEq ((_,_,_ -> 1) 1 2 3) 1

# 11. Macro system deeper edges
:macro (restTest $xs...) => $xs
alphaEq (restTest) nil
alphaEq (restTest 1 2) [1,2]
:macro (wprec _ 0) => 1
:macro (wprec $a $b) => 0
alphaEq (wprec 9 0) 1
alphaEq (wprec 9 1) 0
:macro (litOr 3) => 1
:macro (litOr $x) => 0
alphaEq (litOr 3) 1
alphaEq (litOr 4) 0

# 12. Alpha equivalence harder cases (only genuine alpha equalities)
alphaEq (λx.λy.x) (λa.λb.a)
alphaEq (λx.λx.x) (λa.λa.a)
alphaEq ((λx.λy.y) 1) (λb.b)

# ============================================================================
# Targeted Additional Coverage (negative literal pattern, lazy branch, rest zero-arity,
# negative ranges, composition/$ precedence, guard ordering)
# ============================================================================

# Lazy branch avoidance (Ω not evaluated)
K = λx.λy.x            # ensure K is defined (if already in stdlib this is harmless shadowing)
omega = (λx.x x) (λx.x x)
alphaEq (K 1 omega) 1
alphaEq (if true 1 omega) 1

# Rest zero-arity confirmation (already have restTest earlier; add another distinct)
:macro (gather $xs...) => $xs
alphaEq (gather) nil
alphaEq (gather 4 5) [4,5]

# Negative & descending ranges
alphaEq [-5 .. -3] [-5,-4,-3]
alphaEq [5,3 .. -1] [5,3,1,-1]

# Composition / application precedence interplay
alphaEq ((succ ∘ pred) (succ 5)) (succ (pred (succ 5)))
alphaEq ((succ ∘ (pred ∘ succ)) 5) (succ (pred (succ 5)))

# Guard ordering (guard false skipped, fallback chosen; guard true variant wins when present)
:macro (gtest2 $x) when false => 0
:macro (gtest2 $x) => 1
alphaEq (gtest2 42) 1
:macro (gtest3 $x) => 0
:macro (gtest3 $x) when true => 2
alphaEq (gtest3 7) 2
alphaEq (lcm 6 0) 0

# Structural equality negative variants
alphaEq (listEq eq [1,2] [2,1]) false
alphaEq (pairEq eq eq (pair 1 2) (pair 1 3)) false
alphaEq (maybeEq eq (just 5) (just 6)) false
alphaEq (eitherEq eq eq (right 2) (right 3)) false

# Benchmark & lazy helpers
alphaEq (benchmark 5 succ 1) 2
alphaEq (force (delay 42)) 42

# ASCII classification extended
alphaEq (isupper 65) true
alphaEq (isupper 97) false
alphaEq (islower 97) true
alphaEq (islower 65) false
alphaEq (isalnum 65) true
alphaEq (isalnum 33) false
alphaEq (toupper 65) 65
alphaEq (tolower 97) 97

# State monad laws (left/right identity exemplars)
alphaEq (runState (bindState (returnState 5) (λx.returnState (succ x))) 0) (pair 6 0)
alphaEq (runState (bindState (returnState 5) returnState) 0) (pair 5 0)
mState = λs.pair 1 (succ s)
alphaEq (runState (bindState mState returnState) 0) (runState mState 0)

# --- Additional Macro & Helper Coverage (supplemental) ---
alphaEq (nand true true) false
alphaEq (nand true false) true
alphaEq (nor false false) true
alphaEq (nor true false) false
alphaEq (apply_n succ 3 4) 7
alphaEq (min2 3 5) 3
alphaEq (max2 3 5) 5
alphaEq (empty? nil) true
alphaEq (empty? [1]) false
alphaEq (rest [1,2,3]) [2,3]

# Structural test macros wrappers
alphaEq (testList [1,2] [1,2]) true
alphaEq (testPair (pair 1 2) (pair 1 2)) true
alphaEq (testMaybe (just 9) (just 9)) true
alphaEq (testEither (right 4) (right 4)) true

# Negative with wrappers
alphaEq (testList [1,2] [2,1]) false
alphaEq (testPair (pair 1 2) (pair 2 1)) false
alphaEq (testMaybe (just 9) (just 8)) false
alphaEq (testEither (left 4) (right 4)) false

# WHILE with immediately false condition returns initial state
alphaEq (WHILE (λn.lt n 0) succ 5) 5

# safeInit vs safeInitMaybe distinction
alphaEq (safeInit [1,2]) [1]
alphaEq (safeInitMaybe [1,2]) (just [1])

# Single-element safe min/max
alphaEq (safeMinimum [7]) (just 7)
alphaEq (safeMaximum [7]) (just 7)

# Nested pair equality positive
alphaEq (pairEq (pairEq eq eq) (pairEq eq eq) (pair (pair 1 2) (pair 3 4)) (pair (pair 1 2) (pair 3 4))) true

# isspace tab/newline
alphaEq (isspace 9) true
alphaEq (isspace 10) true

# ============================================================================
# Additional Proposed Coverage (Edge Cases & Remaining Gaps)
# - Church numeral recognition in integer literal macro patterns
# - Negative alphaEq cases (non-equivalent lambda structures)
# - Guard expression (non-literal true) vs literal-false skip
# - Rest vs fixed arity precedence (when both could match arity >= 2)
# - Range singletons & mixed step termination
# - Composition chaining depth
# - Integer literal macro pattern precedence over earlier generic (inverse order)
# ============================================================================

# Church numeral structural match for integer literal pattern (3)
:macro (litChurch 3) => 1
:macro (litChurch $x) => 0
alphaEq (litChurch 3) 1
alphaEq (litChurch (succ (succ (succ zero)))) 1   # structural Church numeral 3
alphaEq (litChurch 2) 0

# Inverse order: generic first, then literal should still prefer literal (specificity)
:macro (invSpec $x) => 0
:macro (invSpec 7) => 1
alphaEq (invSpec 7) 1
alphaEq (invSpec 6) 0

# (Removed prior negative alphaEq mismatch cases to reduce log noise)

# Guard expression that evaluates to non-literal true succeeds
:macro (gexpr $x) when (iszero 0) => 1
:macro (gexpr $x) => 0
alphaEq (gexpr 42) 1

# Guard literal false on specific pattern falls through to next clause
:macro (gexpr2 5) when false => 1
:macro (gexpr2 5) => 2
alphaEq (gexpr2 5) 2

# Rest vs fixed arity precedence (fixed two-arg should win for arity=2)
:macro (restPref $a $b) => 2
:macro (restPref $a $rest...) => (length $rest)
alphaEq (restPref 1 2) 2
alphaEq (restPref 1 2 3 4) 3

# Range singletons and mixed termination
alphaEq [5 .. 5] [5]
alphaEq [5,4 .. 4] [5,4]
alphaEq [5,3 .. 2] [5,3]

# Composition chaining depth
alphaEq ((succ ∘ pred ∘ succ) 5) (succ (pred (succ 5)))

# ============================================================================
# Beta / Hash Equivalence Native Tests
# ============================================================================

# betaEq: normalize then alpha compare
alphaEq (betaEq ((λx.x) 5) 5) true                 # identity reduction
alphaEq (betaEq ((λx.plus x 1) 4) 5) true          # single beta step inside arithmetic
alphaEq (betaEq ((λf.f 3) succ) 4) true            # higher‑order application reduced
alphaEq (betaEq (λx.x) (λx.λy.x)) false            # different arity after normalization

# hashEq: canonical hash of beta-normal forms
alphaEq (hashEq (λx.x) (λy.y)) true                # alpha variants hash equal
alphaEq (hashEq ((λx.x) (λy.y)) (λz.z)) true       # reduces then compares
alphaEq (hashEq (λx.x) (λx.λy.x)) false            # structurally different normal forms

# --- Additional betaEq / hashEq Edge Coverage ---
# Multi-step beta reductions
alphaEq (betaEq ((λx.plus x 0) 7) 7) true
alphaEq (betaEq ((λx.mult x 1) 9) 9) true
alphaEq (betaEq ((λf.f 3) (λy.plus y 0)) 3) true
alphaEq (betaEq ((λf.λz.f z) (λp.plus p 1)) (λk.plus k 1)) true    # eta-like after beta (no eta reduction implemented, still equivalent structurally)
alphaEq (betaEq (λx.plus x 1) (λy.plus y 1)) true
alphaEq (betaEq (λx.x) (λx.plus x 0)) false          # second not a lambda same shape after normalization (normalizes to λx.plus x 0) vs λx.x

# Force/delay interaction
alphaEq (betaEq (force (delay 42)) 42) true
alphaEq (hashEq (force (delay 42)) 42) true

# (Removed experimental property law macro tests: assoc/comm/id/dist/allProps – rolled back)

# Higher-order + partial application normalization
alphaEq (betaEq ((λf.f 2) (λn.plus n 3)) 5) true
alphaEq (betaEq ((λf. f 1 2) (λa b.plus a b)) 3) true

# List mapping identity
alphaEq (betaEq (map (λx.x) [1,2,3]) [1,2,3]) true

# Hash equivalence with alpha variants
alphaEq (hashEq (λa.λb.a) (λx.λy.x)) true
alphaEq (hashEq (λa.λb.b) (λx.λy.y)) true

# Hash distinguishes different free variable names
# Introduce distinct free vars x and y by referencing before definition (or shadow differently)
alphaEq (hashEq x y) false

# After binding both to same value they hash equal (since evaluation resolves them to numerals)
alphaEq (let x = 5 in let y = 5 in hashEq x y) true
alphaEq (let id = λx.x in let id2 = λy.y in hashEq id id2) true

# Hash equivalence through beta normalization chain
alphaEq (hashEq ((λf.f) (λz.plus z 2)) (λk.plus k 2)) true

# Negative cases
alphaEq (betaEq (λx.x) (λx.x x)) false
alphaEq (hashEq (λx.x) (λx.x x)) false
# Removed previous incorrect negative test (both sides reduce to 3).
# Correct differing case retained below.
alphaEq (betaEq ((λx.plus x 1) 2) ((λx.plus x 2) 0)) false    # 3 vs 2+2=4
alphaEq (hashEq ((λx.plus x 1) 2) ((λx.plus x 2) 0)) false


# --- etaEq Tests (beta-normal + eta-reduction) ---
alphaEq (etaEq (λx.(f x)) f) true                   # classic eta
alphaEq (etaEq (λy.(f y)) f) true                   # alpha difference in binder
alphaEq (etaEq (λx.(succ x)) succ) true             # arithmetic wrapper
alphaEq (etaEq (λx.(plus a x)) (plus a)) true       # partial application
alphaEq (etaEq (λx.x) I) true                       # λx.x vs identity combinator
alphaEq (etaEq (λx.(g (h x))) (g ∘ h)) true         # composition chain
alphaEq (etaEq (λx.(f x x)) f) false                # duplicated argument blocks eta
alphaEq (etaEq (λx.(f (g x))) (λx.(f (g x)))) true  # identical
alphaEq (etaEq (λx.(f (g x))) (f ∘ g)) true         # composition equivalence
alphaEq (etaEq (λx.(f (g (h x)))) (f ∘ g ∘ h)) true # deeper chain
alphaEq (etaEq (λx.(x x)) (λx.(x x))) true          # self application unchanged
alphaEq (etaEq (λx.(x x)) I) false                  # not identity

# --- Infix Precedence & Associativity Tests ---

# Arithmetic precedence: * binds tighter than +
alphaEq (1 + 2 * 3) 7          # 1 + (2 * 3)
alphaEq ((1 + 2) * 3) 9        # parenthesized variant

# Composition (∘) right-associative: f ∘ g ∘ h = f ∘ (g ∘ h)
alphaEq ((succ ∘ succ ∘ succ) 0) 3
alphaEq (((succ ∘ succ) ∘ succ) 0) ((succ ∘ (succ ∘ succ)) 0)

# Chaining '.' right-associative application
alphaEq (succ . pred . 5) (succ (pred 5))
alphaEq (succ . pred . succ . 4) (succ (pred (succ 4)))

# Pipeline lowest precedence: 2 |> succ ∘ succ => (succ ∘ succ) 2
alphaEq (2 |> succ ∘ succ) 4

# Pipeline vs chaining:
# NOTE: '.' is application chaining, NOT composition. The expression `succ . pred` chains as (succ pred)
# so `5 |> succ . pred` parses to (succ pred) 5  ==> succ pred 5  (NOT succ (pred 5)).
# Provide an explicit negative then the correctly parenthesized / pipelined positive form.
alphaEq (5 |> succ . pred) (succ pred 5)    # document chaining semantics
alphaEq (5 |> pred |> succ) (succ (pred 5)) # equivalent with explicit pipeline sequencing (true)

# $ right-associative (already covered elsewhere, add compound): mult 2 $ plus 1 2 = mult 2 (plus 1 2)
alphaEq (mult 2 $ plus 1 2) (mult 2 (plus 1 2))

# Interplay: $ has same lowest precedence as |>; ensure right-assoc of $
alphaEq (succ $ pred $ succ 4) (succ (pred (succ 4)))

# Composition precedence equals chaining precedence (both 9); verify explicit grouping equivalence
alphaEq ((succ ∘ pred) . 5) (succ (pred 5))

# Custom operator precedence check
:infix ** 8 right
def ** a b = exp a b            # right-assoc exponent
alphaEq (2 + 3 ** 2) 11         # 2 + (3 ** 2) = 2 + 9
alphaEq (3 ** 2 ** 2) (exp 3 (exp 2 2))   # right-assoc: 3^(2^2) = 3^4 = 81


# --- Additional Equality Edge Cases (added 2025-09) ---

# Eta non-reducible (λx.f) ≠ f since body not (f x)
alphaEq (etaEq (λx.f) f) false

# Eta blocked by free variable inside definition (f closes over free x)
alphaEq (let f = λy.x in etaEq (λx.(f x)) f) true

# Eta blocked when argument also appears elsewhere in body
alphaEq (etaEq (λx.(pair (f x) x)) f) false

# Multi-arg eta chain reduces fully (λx.λy.f x y) ~ f
alphaEq (etaEq (λx.(λy.(f x y))) f) true

# Beta equivalence extra reductions
alphaEq (betaEq (delay 5) 5) true
alphaEq (betaEq ((λx.x) ((λy.y) 7)) 7) true
alphaEq (betaEq ((λf.f 1) (λx.x)) ((λf.f 2) (λx.x))) false

# Hash equivalence distinguishes different application association
alphaEq (hashEq (f (g x)) ((f g) x)) false

# Eta after beta (wrapper lambda returning applied function)
alphaEq (etaEq ((λf. λx. f x) succ) succ) true

# Beta equivalence recognises eta-redex style variant
alphaEq (betaEq (λx.(succ x)) succ) true


##################################################################
# Additional Core Correctness Tests (added 2025-09)
##################################################################

# --- Substitution & Capture Avoidance ---
# (λx. λy. x y) y  ==>  λfresh. y fresh  (inner y renamed to avoid capture)
alphaEq ((λx. λy. x y) y) (λz. y z)

# (λx. λx. x) y  ==>  λx. x   (shadowing respected)
alphaEq ((λx. λx. x) y) (λz. z)

# --- Parameter Placeholder & Explicit Naming ---
# NOTE: Current underscore semantics: underscores in the parameter list introduce throwaway parameters
# but repeated underscores in the BODY are NOT guaranteed to alias those parameters. For deterministic
# reuse inside the body, switch to explicit names.
alphaEq ((_ -> 42) 999) 42                                    # underscore ignore works
alphaEq ((x, y -> mult (x + y) (x + y)) 2 3) 25               # explicit names for reuse
alphaEq ((x, y -> x + y) 3 4) 7                               # simple addition with named params

# --- Multi-Parameter Arrow vs Curried Form ---
alphaEq ((x,y,z -> x) 1 2 3) 1
alphaEq ((λx. λy. λz. x) 1 2 3) 1

# --- def Sugar ---
def myInc x = succ x
alphaEq (myInc 5) 6
def myAdd x y = x + y
alphaEq (myAdd 3 4) 7

# --- let Multi-binding ---
alphaEq (let x = 5, y = 7 in x + y) 12

# --- Simple Recursion (factorial duplicate sanity) ---
alphaEq (let rec f2 = n -> if (n == 0) 1 (n * (f2 (n - 1))) in f2 5) 120
alphaEq (let rec f3 = n -> if (n == 0) 1 (-- n |> f3 |> mult n) in f3 5) 120

# --- Range Edge Cases ---
alphaEq [1 .. 1] [1]
alphaEq [1 .. 0] [1,0]                  # descending short range
alphaEq [1,3 .. 9] [1,3,5,7,9]
alphaEq [10,7 .. -2] [10,7,4,1,-2]

# --- Pipeline / $ / Composition Interplay ---
alphaEq (succ $ pred $ succ 4) (succ (pred (succ 4)))
alphaEq (3 |> succ |> mult 5) (mult (succ 3) 5)
alphaEq ((succ ∘ pred) 5) 5

# --- List vs Cons/Nil Structural Equivalence ---
alphaEq [1,2,3] (cons 1 (cons 2 (cons 3 nil)))

# --- Map with Underscore Constant Function ---
alphaEq (map (_ -> 0) [1,2,3]) [0,0,0]

# --- Range Non-literal Endpoints (desugaring semantics) ---
# We cannot assert direct structural form easily; instead ensure evaluation after defining needed range2 works.
# Provide minimal range/range2 if not in stdlib (guarded by let to avoid collision errors).
let rangeCheck = (λx.x) in 0   # placeholder no-op (keeps file syntactically valid)


##################################################################
# --- Non-native Arithmetic Verification (native primitives disabled) ---
# Validate core Church arithmetic when native acceleration is off.
# Representative subset keeps runtime reasonable.

:native off

# --- Basic Arithmetic - non-native
alphaEq (plus 2 3) 5
alphaEq (mult 3 4) 12
alphaEq (pred 3) 2
alphaEq (minus 5 2) 3
alphaEq (exp 2 3) 8
alphaEq (div 7 2) 3
alphaEq (mod 7 2) 1

# --- Division and Modulo - non-native
alphaEq (div 7 2) 3
alphaEq (mod 7 2) 1

# --- Comparisons - non-native
alphaEq (leq 2 3) true
alphaEq (leq 3 2) false
alphaEq (eq 4 4) true
alphaEq (eq 4 5) false
alphaEq (gt 5 2) true
alphaEq (lt 2 5) true
alphaEq (neq 2 2) false
alphaEq (neq 2 3) true

# --- Numeric Operations - non-native
alphaEq (max 3 7) 7
alphaEq (min 3 7) 3
alphaEq (even 4) true
alphaEq (odd 5) true
alphaEq (square 6) 36
alphaEq (double 8) 16
alphaEq (half 9) 4
alphaEq (pow 2 5) 32

# length (empty, singleton, nested construction)
alphaEq (length nil) 0
alphaEq (length [5]) 1
alphaEq (length [1,2,3,4]) 4

# append / concat (empty identities, associativity exemplar)
alphaEq (append nil [1,2]) [1,2]
alphaEq (append [1,2] nil) [1,2]
alphaEq (append (append [1] [2]) [3]) (append [1] (append [2] [3]))

# reverse (involution)
alphaEq (reverse (reverse [1,2,3])) [1,2,3]
alphaEq (reverse nil) nil

# map (identity + fusion exemplar)
alphaEq (map (λx.x) [1,2,3]) [1,2,3]
alphaEq (map (λx.succ (succ x)) [1,2]) (map succ (map succ [1,2]))

# filter (all pass / none pass)
alphaEq (filter (λ_.true) [1,2,3]) [1,2,3]
alphaEq (filter (λ_.false) [1,2,3]) []

# take / drop (bounds)
alphaEq (take 0 [1,2,3]) []
alphaEq (take 5 [1,2,3]) [1,2,3]
alphaEq (drop 0 [1,2,3]) [1,2,3]
alphaEq (drop 5 [1,2,3]) []

# any / all (short-circuit shape)
alphaEq (any (λx.eq x 2) [1,2,3]) true
alphaEq (any (λx.eq x 5) [1,2,3]) false
alphaEq (all (λ_.true) [1,2,3]) true
alphaEq (all (λx.lt x 3) [1,2,3]) false

# find (hit / miss)
alphaEq (find (λx.eq x 3) [1,2,3,4]) 3
alphaEq (find (λx.eq x 9) [1,2,3]) nothing

# sum / product (empty, early product zero)
alphaEq (sum []) 0
alphaEq (sum [1,2,3,4]) 10
alphaEq (product []) 1
alphaEq (product [2,3,4]) 24
alphaEq (product [0,2,3,4]) 0

# Additional edge cases (non-native list primitives)
alphaEq (append nil nil) []                 # append identity both sides empty
alphaEq (reverse [42]) [42]                 # reverse singleton
alphaEq (map (λx.succ x) []) []             # map over empty
alphaEq (filter (λ_.true) []) []            # filter over empty (keeps empty)
alphaEq (filter (λ_.false) []) []           # filter over empty (rejects empty)
alphaEq (take 3 [1,2,3]) [1,2,3]            # take exactly length
alphaEq (drop 3 [1,2,3]) []                 # drop exactly length
alphaEq (take 2 nil) []                     # take from empty
alphaEq (drop 0 nil) []                     # drop zero from empty
alphaEq (any (λ_.true) []) false            # any on empty should be false
alphaEq (all (λ_.false) []) true            # all on empty should be true (vacuous truth)
alphaEq (find (λx.eq x 1) []) nothing       # find in empty
alphaEq (sum [5]) 5                         # sum singleton
alphaEq (product [5]) 5                     # product singleton
alphaEq (product [1]) 1                     # product neutral singleton
alphaEq (length (append [1,2] [3,4])) 4     # length after append sanity
alphaEq (length (take 0 [1,2,3])) 0         # length of empty take
alphaEq (length (drop 99 [1,2,3])) 0        # drop beyond length yields empty

:native on

# ---------------------------------------------------------------------------
# Additional Coverage Block (2025-09) – Newly Identified Gaps
# ---------------------------------------------------------------------------

# === Structural Equivalence Helpers (beyond alphaEq) ===
betaEq ((λx.succ x) 4) 5
hashEq (plus 2 3) 5
etaEq (λx.succ x) succ

# === WHILE Combinator & gcd1 Variant ===
alphaEq (WHILE (λn.gt n 0) pred 5) 0
alphaEq (gcd1 12 8) 4
alphaEq (gcd1 18 24) (gcd 18 24)

# === Safe Operations (remaining) ===
alphaEq (safehead [1,2,3]) (just 1)
alphaEq (safehead nil) nothing
alphaEq (safetail [1,2]) (just [2])
alphaEq (safetail nil) nothing
alphaEq (safenth 2 [10,20,30,40]) (just 30)
alphaEq (safenth 5 [10,20]) nothing
alphaEq (safediv 10 2) (just 5)
alphaEq (safediv 10 0) nothing

# === Numeric Predicates & Extras ===
alphaEq (isone 1) true
alphaEq (isone 2) false
alphaEq (istwo 2) true
alphaEq (ispositive 0) false
alphaEq (ispositive 3) true
alphaEq (half 8) 4
alphaEq (quadruple 3) 12
alphaEq (abs 5) 5

# === Delay / Force Semantics ===
alphaEq (force (delay 5)) 5
alphaEq (force (delay (succ 4))) 5

# === Maybe / Either Additional Laws ===
alphaEq (maybeMap (λx.x) (just 5)) (just 5)
alphaEq (maybeBind (just 7) maybeReturn) (just 7)
alphaEq (eitherMap succ (left 9)) (left 9)
alphaEq (eitherBind (right 4) eitherReturn) (right 4)

# Maybe bind associativity (concrete instantiation)
assocL = maybeBind (maybeBind (just 2) (λx.just (succ x))) (λy.just (plus y 1))
assocR = maybeBind (just 2) (λx.maybeBind (just (succ x)) (λy.just (plus y 1)))
alphaEq assocL assocR

# === Tag Helpers ===
alphaEq (first (boolTag true)) 66
alphaEq (first (maybeTag (just 1))) 77
alphaEq (first (eitherTag (right 2))) 69

# === unzip ===
alphaEq (unzip (zip [1,2] [3,4])) (pair [1,2] [3,4])

# === geq Explicit ===
alphaEq (geq 5 5) true
alphaEq (geq 4 5) false

# === Functor Composition (List) ===
alphaEq (map (succ ∘ square) [1,2,3]) (map succ (map square [1,2,3]))

# === State Monad Expanded Tests ===
alphaEq (runState (putState 5) 0) (pair nil 5)
incrState = bindState getState (λn.putState (succ n))
alphaEq (runState incrState 3) (pair nil 4)

# ---------------------------------------------------------------------------
# Additional Coverage Block 2 (2025-09) – Remaining stdlib & macro coverage
# ---------------------------------------------------------------------------
# Focus:
#   - Character predicates & case conversion
#   - String/sequence utilities: words, lines, unwords, unlines, break, intercalate
#   - Boolean/list convenience macros: nand, nor, empty?, rest, first
#   - Mathematical min2 / max2
#   - Repeated application (apply_n) and benchmark semantics
#   - Assertion & structural test macros (basic truth cases)
# Notes:
#   Characters represented as numeric codes. Lists of codes act as strings.

# Character classification predicates
alphaEq (isdigit 48) true
alphaEq (isdigit 65) false
alphaEq (islower 97) true
alphaEq (islower 65) false
alphaEq (isupper 65) true
alphaEq (isupper 97) false
alphaEq (isalpha 65) true
alphaEq (isalpha 48) false
alphaEq (isalnum 48) true
alphaEq (isalnum 65) true
alphaEq (isalnum 32) false
alphaEq (isspace 32) true
alphaEq (isspace 9)  true
alphaEq (isspace 65) false

# Case conversion
alphaEq (tolower 65) 97
alphaEq (tolower 97) 97
alphaEq (toupper 97) 65
alphaEq (toupper 65) 65

# Edge cases
alphaEq (unwords []) []
alphaEq (unlines []) []
alphaEq (intercalate [45] []) []

# Boolean / list convenience macros
alphaEq (nand true false) true
alphaEq (nand true true) false
alphaEq (nor false false) true
alphaEq (nor true false) false
alphaEq (empty? nil) true
alphaEq (empty? [1]) false
alphaEq (head [7,8,9]) 7
alphaEq (rest  [7,8,9]) [8,9]

# min2 / max2
alphaEq (min2 7 3) 3
alphaEq (min2 3 7) 3
alphaEq (max2 7 3) 7
alphaEq (max2 3 7) 7

# apply_n & benchmark
alphaEq (apply_n succ 5 0) 5
alphaEq (apply_n (λx.mult x 2) 3 1) 8
alphaEq (benchmark 10 succ 5) 6

# Assertions & structural test macros
alphaEq (assert (gt 5 0) 42) 42
alphaEq (test (plus 2 3) 5) true
alphaEq (testList [1,2,3] [1,2,3]) true
alphaEq (testPair (pair 1 2) (pair 1 2)) true
alphaEq (testMaybe (just 5) (just 5)) true
alphaEq (testEither (right 9) (right 9)) true

# ---------------------------------------------------------------------------
# Infix Operator Precedence & Associativity Tests (2025-09)
# Ensures parser respects declared precedence / associativity rules:
#   ^ (right-assoc) > *,/,%, then +,-, then comparisons <,<=,>,>=, then ==,!=,
#   then &&, then ||. Also validates parentheses override and left/right assoc.
# ---------------------------------------------------------------------------

# Multiplicative vs Additive precedence
alphaEq (2 + 3 * 4) 14              # parsed as 2 + (3 * 4)
alphaEq (2 * 3 + 4) 10              # (2 * 3) + 4

# Parentheses override
alphaEq ((2 + 3) * 4) 20
alphaEq (2 * (3 + 4)) 14

# Subtraction left-associative
alphaEq (10 - 3 - 2) 5              # (10 - 3) - 2

# Exponentiation right-associative
alphaEq (2 ^ 3 ^ 2) 512             # 2 ^ (3 ^ 2) = 2 ^ 9 = 512

# Mixed exponent & multiplication
alphaEq (2 * 2 ^ 3) 16              # 2 * (2 ^ 3)
alphaEq (2 ^ 3 * 2) 16              # (2 ^ 3) * 2 (since ^ > *)

# Division / Modulo same precedence as multiplication (left-assoc)
alphaEq (20 / 3 * 3) 18             # (20 / 3) * 3 => 6 * 3
alphaEq (20 % 6 + 2) 4              # (20 % 6) + 2 => 2 + 2

# Comparison vs Additive
alphaEq (2 + 3 < 10) true           # (2 + 3) < 10
alphaEq (2 < 3 + 4) true            # 2 < (3 + 4)

# Equality vs Comparison
alphaEq (eqBool (2 < 3) true) true        # (2 < 3) == true
alphaEq (2 + 2 == 4 && 3 + 4 == 7) true
alphaEq (2 + 2 == 5 || 3 + 4 == 7) true

# Logical AND higher than OR
alphaEq (false || true && false) false  # false || (true && false)
alphaEq ((false || true) && false) false
alphaEq (true && true || false && false) true  # (true && true) || (false && false)

# Combined chain sanity
alphaEq (1 + 2 * 3 == 7 && 4 ^ 2 > 3 * 5 || 10 % 4 == 2) true
	# 1 + (2*3) == 7  => true
	# 4^2 > 3*5       => 16 > 15 => true
	# true && true || (10%4==2) => true || true => true


# -----------------------------------------------
# Combinator Laws: SKI, B, C (in-depth) (2025-09)
# -----------------------------------------------

# I as S K K
etaEq (S K K) I
alphaEq ((S K K) 5) 5
alphaEq ((S K K) 0) 0

# K discards second arg
alphaEq ((K 42) 99) 42
alphaEq (((K 7) (succ 2))) 7

# S distributes: S f g x == f x (g x)
alphaEq ((S plus square) 3) (plus 3 (square 3))
alphaEq ((S mult succ) 4) (mult 4 (succ 4))

# S (K f) I == f (extensional)
etaEq (S (K plus) I) plus
etaEq (S (K mult) I) mult

# B is composition, and equals o (extensional)
alphaEq ((B succ square) 3) (succ (square 3))
alphaEq ((B (plus 1) (mult 2)) 5) 11
etaEq (B succ square) (succ o square)
etaEq (B (plus 1) (mult 2)) ((plus 1) o (mult 2))

# B associativity: B (B f g) h == B f (B g h)
etaEq (B (B succ (plus 2)) (mult 3)) (B succ (B (plus 2) (mult 3)))
etaEq (B (B square (plus 1)) (succ)) (B square (B (plus 1) succ))

# B with identity-like functions
etaEq (B I succ) succ
etaEq (B I square) square

# C flips arguments: C f x y == f y x
alphaEq (((C minus) 3 10)) (minus 10 3)
alphaEq (((C pair) 1 2)) (pair 2 1)

# C is an involution: C (C f) == f (extensional)
etaEq (C (C minus)) minus
etaEq (C (C pair)) pair

# C with K yields second projection
alphaEq (((C K) 1 2)) 2
alphaEq (((C (K (K 42))) 1 2)) 42
alphaEq ((42 |> K |> K |> C) 1 2) 42 # chaining style
alphaEq ((C . K . K . 42) 1 2) 42 # chaining with dot
:macro (T6 $a $b $c $e $f $g) => ($a ($b ($c $e))) $f $g
alphaEq (T6 C K K 42 1 2) 42  # macro style

# ---------------------------------------------------
# More Combinators and Derived Identities (2025-09)
# ---------------------------------------------------

# W (duplicator): W f x = f x x; one SK form: W = S S (K I)
etaEq (S S (K I)) (λf x. f x x)
alphaEq (((S S (K I)) plus 3)) (plus 3 3)

# M (mockingbird): M f = f f; one SK form: M = S I I
etaEq (S I I) (λf. f f)
alphaEq (((S I I) (K 42))) 42

# T (thrush): T x f = f x; T = C I
etaEq (C I) (λx f. f x)
alphaEq (((C I) 3 succ)) 4

# SK encodings for B and C
etaEq B (S (K S) K)
# NOTE: The classic SK encoding for C varies by convention and our eta-normalization;
# the following identity can be sensitive to reduction strategy. Keeping it commented for now.
# etaEq C (S (B (B S) K) (K K))

# Small identities
etaEq (S K) (K I)           # S K == K I (both project second arg)
etaEq K true                 # K is Church true
etaEq (C K) false            # C K is Church false

# C (K a) is NOT a 2-arg constant; the 2-arg constant is C (K (K a))
etaEq (C (K (K 42))) (K (K 42))
alphaEq (((C (K succ)) 3 0)) 4   # C (K a) x y == a x (example with succ)

# ---------------------------------------------------
# Module System – Smoke Tests (2025-09)
# ---------------------------------------------------

# Load a tiny demo module that defines:
#   a = 41; b = succ a; f = \x. plus x a; g = \y. f y; h = \plus. plus 1 2
# Expect qualified access to work and internal self-references be rewritten to TM::a
:module load "testmod.lambda" as TM
alphaEq TM::a 41
alphaEq TM::b 42
alphaEq (TM::f 1) 42
alphaEq (TM::g 1) 42
# h remains a constant function of its bound parameter (bound var not qualified)
alphaEq (TM::h) (λplus.3)

# Selective import with renaming; imports land in unqualified scope
:module import TM::{f as f1, a}
alphaEq (f1 1) 42
alphaEq (plus a 1) 42

# Temporary with-scope brings all TM symbols unqualified just for this expression (cannot assert via alphaEq)
# :module with TM => (plus a 1)   # expected 42

# Unload removes qualified names but keeps already-imported unqualified bindings
:module unload TM
alphaEq (f1 1) 42

# ---------------------------------------------------
# Module System – Submodule Smoke Tests (2025-09)
# ---------------------------------------------------

# Load parent module A which itself loads B as a submodule (relative path)
:module load "submodA.lambda" as A

# Parent definitions should be qualified as A::name
alphaEq A::a 1

# Submodule definitions should be accessible as A::B::name under dotted alias A.B
alphaEq A::B::x 99
alphaEq (A::B::inc 1) 2

# Cross-reference inside A to B should rewrite to A::B::x
alphaEq A::ax 100

# Selective import from a submodule using dotted alias
:module import A.B::{inc as incB}
alphaEq (incB 41) 42

# --------------------------------------------------
# Hygienic Macros – Smoke Tests (2025-09)
# --------------------------------------------------

# 1) Capture-avoidance: macro introduces a binder named x; should not capture a free x from the call site
:macro (letX $e) => (qq ((\x. ~ $e) 0))
def x = 42
alphaEq (letX x) 42           # Without hygiene this would be 0 due to capture; with hygiene it's 42

# 2) Splicing + hygiene sanity
:macro (call2h $f $args) => (qq (~ $f ~@ $args))
alphaEq (call2h plus [1, 2]) 3

# --------------------------------------------------
# Hygienic Macros – More Tests (2025-09)
# --------------------------------------------------

# 3) Nested binders introduced by a macro must not capture site vars
:macro (letXY $e) => (qq ((\x. (\y. ~ $e) 0) 0))
def y = 99
alphaEq (letXY x) 42
alphaEq (letXY y) 99

# 4) Binder introduced by macro should not affect inner lambda parameters inside $e
:macro (wrapX $e) => (qq (\x. ~ $e))
alphaEq (((wrapX (\x. x)) 0) 5) 5

# 5) Splicing with free variables in args should not be captured by introduced binder
:macro (applyX $f $args) => (qq ((\x. ~ $f ~@ $args) 0))
alphaEq (applyX plus [x, 1]) 43

# 6) Unquote inside application argument amidst binder should remain a single arg and not be captured
# Use parentheses with unquote to ensure grouping: ~( $a ) becomes one argument
:macro (inArg $a) => (qq ((\x. plus ~( $a ) 1) 0))
def x2 = 41
alphaEq (inArg x2) 42

# --------------------------------------------------
# Quasiquote Splicing – Smoke Tests (2025-09)
# --------------------------------------------------

# Simple function and helpers
def add3 a b c = plus (plus a b) c

# Macro that builds a call with spliced argument list
:macro (call2 $f $args) => (qq ($f ~@ $args))

# Splice two args into add3 with a fixed first arg
alphaEq (call2 (add3 1) [2,3]) 6

# Macro that constructs a list with spliced inner list
:macro (mklist $a $rest) => (qq [~ $a, ~@ $rest, 99])

# Expect flattening of spliced list elements
alphaEq (mklist 1 [2,3]) [1,2,3,99]

# Additional Quasiquote/Unquote/Splice Edge Cases (2025-09)

# Splicing empty list should contribute zero args/elements
:macro (call2_empty $f $xs) => (qq (~ $f ~@ $xs))
alphaEq (call2_empty add3 []) (add3)            # no extra args spliced

# Helper: splice a list into a list literal in macro context
:macro (spliceList $xs) => (qq [~@ ( $xs )])
alphaEq (spliceList []) []

# Splicing singleton list and nested splicing
alphaEq (call2 (add3 1) [2]) (add3 1 2)         # single arg splice
:macro (call_nested $f $xs) => (qq (~ $f ~@ (cons 7 $xs)))
alphaEq (call_nested add3 [1,2]) (add3 7 1 2)

# Splicing Church list (cons/nil) should flatten
alphaEq (call2 add3 (cons 1 (cons 2 nil))) (add3 1 2)
alphaEq (spliceList (cons 9 (cons 8 nil))) [9,8]

# Atomic unquote in the middle of args remains a single argument
# Build via call2 to avoid nested unquotes inside qq
:macro (midArg $a $b) => (call2 (add3 0) [$a, $b])
alphaEq (midArg (plus 1 1) (plus 2 1)) (add3 0 2 3)

# Multiple unquotes in one template are independent
:macro (dup2 $a) => (qq ([~( $a ), ~( $a )]))
alphaEq (dup2 (plus 1 1)) [2,2]

# Splicing with zero, one, and many: apply to a 3-ary function with fixed prefix
:macro (applyFlex $f $xs) => (qq (~( $f ) 1 ~@ ( $xs )))
alphaEq (applyFlex add3 []) (add3 1)
alphaEq (applyFlex add3 [2]) (add3 1 2)
alphaEq (applyFlex add3 [2,3]) (add3 1 2 3)

# Splice two provided lists directly (no nested unquote needed)
:macro (join2 $a $b) => (qq ([~@ ( $a ), ~@ ( $b )]))
alphaEq (join2 [1,2] [3]) [1,2,3]

# Hygiene with spliced free site vars
:macro (applyH $f $xs) => (qq ((\tmp. ~( $f ) ~@ ( $xs )) 0))
def site = 5
alphaEq (applyH plus [site, 2]) 7

# --------------------------------------------------
# Module-qualified Quasiquote – Tests (2025-09)
# --------------------------------------------------

# Load the small demo module as MQ (file already used earlier in the suite)
:module load "testmod.lambda" as MQ

# Sanity: refer to a qualified value and function
alphaEq MQ::a 41
alphaEq (MQ::f 1) 42

# Use qualified names inside quasiquotes and unquotes
:macro (mqUseA) => (qq (~ (MQ::a)))
alphaEq (mqUseA) 41

:macro (mqCallF $x) => (qq (MQ::f ~( $x )))
alphaEq (mqCallF 1) 42

# Splice a qualified function with spliced args
:macro (mqApply $args) => (qq (MQ::f ~@ ( $args )))
alphaEq (mqApply [1]) 42

# Build a list mixing qualified names and unquoted values
:macro (mqList $x) => (qq [MQ::a, ~( $x ), 0])
alphaEq (mqList 1) [41,1,0]

# Hygiene check: introduced binder should not affect qualified references
:macro (mqHyg $x) => (qq ((\x. MQ::f ~( $x )) 0))
alphaEq (mqHyg 1) 42

# Cleanup this module to avoid leaking symbols for later blocks
:module unload MQ

# --------------------------------------------------
# Submodule-qualified Quasiquote – Tests (2025-09)
# --------------------------------------------------

# Load parent module A which loads submodule B; use alias MA
:module load "submodA.lambda" as MA

# Sanity: qualified access to parent and submodule
alphaEq MA::a 1
alphaEq MA::B::x 99
alphaEq (MA::B::inc 1) 2

# Quasiquote with nested qualified names
:macro (mbUse) => (qq ([MA::a, MA::B::x]))
alphaEq (mbUse) [1,99]

# Unquote and splice with nested qualified values/functions
:macro (mbCallBi $n) => (qq (MA::B::inc ~( $n )))
alphaEq (mbCallBi 1) 2

:macro (mbApplyB $args) => (qq (MA::B::inc ~@ ( $args )))
alphaEq (mbApplyB [1]) 2

# Hygiene check: introduced binder must not affect nested qualified references
:macro (mbHyg $n) => (qq ((\x. MA::B::inc ~( $n )) 0))
alphaEq (mbHyg 1) 2

# Cleanup
:module unload MA

# Unload A should also remove A.B symbols (qualified), but imported incB persists
:module unload A
alphaEq (incB 41) 42

##################################################################
# Supplemental coverage block (focused, 2025-10)
##################################################################

# -----------------------------------------------
# Lisp-style Aliases Tests (car/cdr/cadr/etc.)
# -----------------------------------------------
testList = [1, 2, 3, 4, 5]

# Basic car/cdr (head/tail aliases)
alphaEq (car testList) 1
alphaEq (cdr testList) [2, 3, 4, 5]

# Composed accessors
alphaEq (cadr testList) 2         # second element
alphaEq (caddr testList) 3        # third element
alphaEq (cadddr testList) 4       # fourth element

# List constructors
alphaEq (list1 42) [42]
alphaEq (list2 1 2) [1, 2]
alphaEq (list3 1 2 3) [1, 2, 3]
alphaEq (list4 1 2 3 4) [1, 2, 3, 4]
alphaEq (list5 1 2 3 4 5) [1, 2, 3, 4, 5]

# Nested list accessors (only cddr/cdddr work with flat lists)
alphaEq (cddr testList) [3, 4, 5] # cdr of cdr
alphaEq (cdddr testList) [4, 5]   # cdr of cdr of cdr

# Nested list tests - must use cons explicitly for nested structures
nested1 = cons (cons 1 (cons 2 nil)) (cons (cons 3 (cons 4 nil)) (cons 5 nil))
alphaEq (caar nested1) 1       # car of car: get first element of first list
alphaEq (caadr nested1) 3      # car of car of cdr: get first element of second list

# -----------------------------------------------
# Cond and Case Macro Tests
# -----------------------------------------------

# Cond2 macro tests (2 branches)
alphaEq (cond2 (lt 5 10) 1 :else 2) 1
alphaEq (cond2 (gt 5 10) 1 :else 2) 2
alphaEq (cond2 (eq 5 5) 100 :else 200) 100

# Cond3 macro tests (3 branches)
testCond3 = λn. cond3 (eq n 1) 10 (eq n 2) 20 :else 30
alphaEq (testCond3 1) 10
alphaEq (testCond3 2) 20
alphaEq (testCond3 3) 30

# Case2 macro tests  
alphaEq (case2 2 1 10 2 20) 20
alphaEq (case2 1 1 10 2 20) 10
alphaEq (case2 5 1 10 :else 99) 99

# Case3 macro tests
testCase3 = λn. case3 n 1 100 2 200 3 300
alphaEq (testCase3 1) 100
alphaEq (testCase3 2) 200
alphaEq (testCase3 3) 300

testCase3Else = λn. case3 n 1 100 2 200 :else 999
alphaEq (testCase3Else 1) 100
alphaEq (testCase3Else 2) 200
alphaEq (testCase3Else 7) 999

# -----------------------------------------------
# String Operations Tests (Lisp-style)
# -----------------------------------------------

# String is list of ASCII codes
testStr = [72, 101, 108, 108, 111]  # "Hello"

# substring: take slice from start to end
alphaEq (substring testStr 0 3) [72, 101, 108]       # "Hel"
alphaEq (substring testStr 1 4) [101, 108, 108]      # "ell"
alphaEq (substring testStr 2 5) [108, 108, 111]      # "llo"

# stringRef: get character at index (nth)
alphaEq (stringRef testStr 0) 72    # 'H'
alphaEq (stringRef testStr 1) 101   # 'e'
alphaEq (stringRef testStr 4) 111   # 'o'

# stringAppend: concatenate strings
str1 = [72, 105]      # "Hi"
str2 = [33, 33]       # "!!"
alphaEq (stringAppend str1 str2) [72, 105, 33, 33]

# stringLength
alphaEq (stringLength testStr) 5
alphaEq (stringLength nil) 0

# -----------------------------------------------
# Type Predicate Tests (Lisp-style)
# -----------------------------------------------

# null? - test for nil
alphaEq (null? nil) true
alphaEq (null? [1, 2]) false

# pair? - heuristic test for pairs
alphaEq (pair? (pair 1 2)) true
alphaEq (pair? nil) false

# list? - everything is a list in Church encoding
alphaEq (list? [1, 2, 3]) true
alphaEq (list? nil) true

# procedure? - everything is a function
alphaEq (procedure? succ) true
alphaEq (procedure? 42) true  # Even numbers are functions in LC

# -----------------------------------------------
# applyList Tests (apply with list of arguments)
# -----------------------------------------------

# Apply function to list of arguments
alphaEq (applyList plus [3, 4]) 7
alphaEq (applyList mult [5, 6]) 30
alphaEq (applyList max [10, 5]) 10

# -----------------------------------------------
# Native Math Functions Tests
# -----------------------------------------------

# Trigonometric functions (scaled by 1000, degrees)
# sin(0) = 0, sin(90) = 1.0 => 1000
alphaEq (sin 0) 0
alphaEq (sin 90) 1000

# cos(0) = 1.0 => 1000, cos(90) = 0
alphaEq (cos 0) 1000
alphaEq (cos 90) 0

# tan(0) = 0, tan(45) ≈ 1.0 => 1000
alphaEq (tan 0) 0
alphaEq (geq (tan 45) 900) true   # tan(45) ≈ 1, scaled

# log (natural logarithm, scaled by 1000)
# ln(1) = 0
alphaEq (log 1) 0
# ln(e) ≈ 1 => but e ≈ 2.718, so ln(3) ≈ 1.099 => 1099
alphaEq (geq (log 3) 1000) true
alphaEq (leq (log 3) 1200) true

# expReal (e^(n/1000))
# e^0 = 1
alphaEq (expReal 0) 1
# e^1 ≈ 2.718, input 1000 gives e^1
alphaEq (geq (expReal 1000) 2) true
alphaEq (leq (expReal 1000) 3) true

# absReal (absolute value)
alphaEq (absReal 5) 5
alphaEq (absReal 0) 0
# Church numerals are non-negative, but test still works

# floor/ceiling (identity for Church numerals)
alphaEq (floor 42) 42
alphaEq (ceiling 17) 17

# --- Module export/hide (from tests/module-export-hide.lambda) ---
:module load "tests/module-export-hide.lambda" as ME
alphaEq ME::pub 41
alphaEq (ME::subInc 5) 6

# --- for-macro result tests ---
alphaEq (for x at [1,2,3] do (succ x)) [2,3,4]
alphaEq (for x at [2,3,4] do (square x)) [4,9,16]

# --- IO/string helpers ---
alphaEq (getChar [72,105]) 72
alphaEq ((putChar 65 nil)) [65]
alphaEq (putStr [72,105] [33]) [72,105,33]
alphaEq (getLine [72,101,10,33]) [72,101,33]

# --- Currying / Uncurrying extensional laws ---
addPair = \p.plus (first p) (second p)
alphaEq (uncurry (curry addPair) (pair 3 4)) 7
etaEq (curry (uncurry plus)) plus
etaEq (uncurry (curry addPair)) addPair

# --- Functor / Applicative laws (List/Maybe/Either) ---
f = succ
g = square
alphaEq (map (f ∘ g) [1,2,3]) (map f (map g [1,2,3]))
alphaEq (map (f o g) [1,2,3]) (map f (map g [1,2,3]))

comp = \f g x.f (g x)
alphaEq (maybeAp (just I) (just 5)) (just 5)
fs = just succ
gs = just (mult 2)
xs = just 5
lhs = maybeAp (maybeAp (maybeAp (just comp) fs) gs) xs
rhs = maybeAp fs (maybeAp gs xs)
alphaEq lhs rhs
alphaEq (eitherAp (right I) (right 7)) (right 7)

# --- Maybe/Either monad laws (instances) ---
fM = \x.just (x + 1)
gM = \y.just (y * 2)
alphaEq (maybeBind (just 3) fM) (fM 3)
alphaEq (maybeBind (just 4) maybeReturn) (just 4)
alphaEq (maybeBind (maybeBind (just 2) fM) gM) (maybeBind (just 2) (\x.maybeBind (fM x) gM))
alphaEq (eitherBind (right 5) eitherReturn) (right 5)

# --- State monad associativity (instance) ---
mS = returnState 1
kS = \x.returnState (x + 2)
hS = \y.returnState (y * 3)
lhsS = bindState (bindState mS kS) hS
rhsS = bindState mS (\x.bindState (kS x) hS)
alphaEq (runState lhsS 0) (runState rhsS 0)

# --- Map–append fusion and times example ---
alphaEq (map succ (append [1,2] [3])) (append (map succ [1,2]) (map succ [3]))
alphaEq (times 4 (succ 1)) 16

# --- Pair/list encoding exercises ---
alphaEq (pair 3 4 plus) 7
alphaEq (foldr cons nil [1,2,3]) [1,2,3]

# --- Composition alias parity ---
alphaEq ((succ ∘ square) 3) ((succ o square) 3)
etaEq (succ ∘ square) (succ o square)
