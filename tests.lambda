# =========================================================================
# Structural Equality Test Suite (auto-converted from tests.lambda)
# Each prior test:  expr  # expect VALUE  ==>  isStructEqual expr VALUE
# Loads stdlib.lambda first; then load this file: :load struct-tests.lambda
# NOTE:
#   - Some descriptive expectations (e.g., words/unwords textual forms) kept as comments
#   - Ambiguous expectations were converted where a reasonable canonical form exists
# =========================================================================

# --- Boolean Logic ---
isStructEqual (true 1 0) 1
isStructEqual (false 1 0) 0
isStructEqual (not true) false
isStructEqual (not false) true
isStructEqual (and true true) true
isStructEqual (and true false) false
isStructEqual (or true false) true
isStructEqual (xor true true) false
isStructEqual (if true 42 99) 42
isStructEqual (if false 42 99) 99
isStructEqual (eqBool true true) true
isStructEqual (eqBool true false) false

# --- Church Numerals ---
isStructEqual (zero (λx.1) 0) 0
isStructEqual (succ (succ zero)) 2
isStructEqual (plus 2 3) 5
isStructEqual (mult 3 4) 12
isStructEqual (pred 3) 2
isStructEqual (minus 5 2) 3
isStructEqual (iszero 0) true
isStructEqual (iszero 1) false
isStructEqual (exp 2 3) 8

# --- Division and Modulo ---
isStructEqual (div 7 2) 3
isStructEqual (mod 7 2) 1

# --- Comparisons ---
isStructEqual (leq 2 3) true
isStructEqual (leq 3 2) false
isStructEqual (eq 4 4) true
isStructEqual (eq 4 5) false
isStructEqual (gt 5 2) true
isStructEqual (lt 2 5) true
isStructEqual (neq 2 2) false
isStructEqual (neq 2 3) true

# --- Numeric Operations ---
isStructEqual (max 3 7) 7
isStructEqual (min 3 7) 3
isStructEqual (even 4) true
isStructEqual (odd 5) true
isStructEqual (square 6) 36
isStructEqual (double 8) 16
isStructEqual (half 9) 4
isStructEqual (pow 2 5) 32

# --- List Operations ---
isStructEqual nil nil
isStructEqual (isnil nil) true
isStructEqual (isnil (cons 1 nil)) false
isStructEqual (cons 1 (cons 2 (cons 3 nil))) [1,2,3]
isStructEqual (head (cons 1 (cons 2 (cons 3 nil)))) 1
isStructEqual (tail (cons 1 (cons 2 (cons 3 nil)))) [2,3]
isStructEqual (length (cons 1 (cons 2 (cons 3 nil)))) 3
isStructEqual (reverse (cons 1 (cons 2 (cons 3 nil)))) [3,2,1]
isStructEqual (append (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil))) [1,2,3,4,5]
isStructEqual (map succ (cons 1 (cons 2 (cons 3 nil)))) [2,3,4]
isStructEqual (filter even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) [2,4]
isStructEqual (foldr plus 0 (cons 1 (cons 2 (cons 3 nil)))) 6
isStructEqual (foldl plus 0 (cons 1 (cons 2 (cons 3 nil)))) 6

# --- Advanced List Operations ---
isStructEqual (range 5) [0,1,2,3,4]
isStructEqual (countdown 3) [3,2,1,0]
isStructEqual (zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil))) (zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil)))  # structural tuple pairs may need dedicated eq; kept identity
isStructEqual (concat (cons (cons 1 (cons 2 (cons 3 nil))) (cons (cons 4 nil) nil))) [1,2,3,4]

# --- Combinators and Utilities ---
isStructEqual (K 42 99) 42
isStructEqual (I 77) 77
isStructEqual (S (K succ) (K 3) 0) 4
isStructEqual (B succ succ 1) 3
isStructEqual (C minus 5 2) 0

# --- Recursion and Advanced Functions ---
isStructEqual (fact 5) 120
isStructEqual (fib 7) 13
isStructEqual (gcd 18 24) 6
isStructEqual (lcm 6 8) 24

# --- Infix Operators ---
isStructEqual (2 + 3) 5
isStructEqual (7 - 4) 3
isStructEqual (3 * 4) 12
isStructEqual (9 / 2) 4
isStructEqual (9 % 4) 1
isStructEqual (2 ^ 4) 16
isStructEqual (true && false) false
isStructEqual (false || true) true
isStructEqual (5 == 5) true
isStructEqual (5 != 4) true
isStructEqual (2 < 3) true
isStructEqual (2 <= 2) true
isStructEqual (4 > 3) true
isStructEqual (4 >= 4) true

# --- Maybe/Optional Type ---
isStructEqual (just 42) (just 42)
isStructEqual nothing nil
isStructEqual (isJust (just 1)) true
isStructEqual (isNothing nothing) true
isStructEqual (fromJust (just 7)) 7
isStructEqual (fromMaybe 99 (just 5)) 5
isStructEqual (fromMaybe 99 nothing) 99
isStructEqual (maybe 0 succ (just 3)) 4
isStructEqual (maybe 0 succ nothing) 0

# --- Either Type ---
isStructEqual (left 1) (left 1)
isStructEqual (right 2) (right 2)
isStructEqual (isLeft (left 5)) true
isStructEqual (isRight (right 6)) true
isStructEqual (either succ pred (left 10)) 11
isStructEqual (either succ pred (right 10)) 9

# --- Tree Data Structure ---
isStructEqual (leaf 7) (leaf 7)
isStructEqual (node 1 (leaf 2) (leaf 3)) (node 1 (leaf 2) (leaf 3))
isStructEqual (treeValue (leaf 8)) 8
isStructEqual (treeLeft (node 1 (leaf 2) (leaf 3))) (leaf 2)
isStructEqual (treeRight (node 1 (leaf 2) (leaf 3))) (leaf 3)
isStructEqual (isLeaf (leaf 9)) true
isStructEqual (isLeaf (node 1 (leaf 2) (leaf 3))) false

# --- zipWith, scan*, find, partition, splitAt ---
isStructEqual (zipWith plus (cons 1 (cons 2 nil)) (cons 10 (cons 20 nil))) [11,22]
isStructEqual (scanl plus 0 (cons 1 (cons 2 (cons 3 nil)))) [0,1,3,6]
isStructEqual (scanr plus 0 (cons 1 (cons 2 (cons 3 nil)))) [6,5,3,0]
isStructEqual (find (eq 2) (cons 1 (cons 2 (cons 3 nil)))) 2
isStructEqual (partition even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) (partition even (cons 1 (cons 2 (cons 3 (cons 4 nil)))))  # complex tuple result; identity check
isStructEqual (splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))) (splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil)))))

# --- Edge Cases and Safe Functions ---
isStructEqual (safeMinimum nil) nothing
isStructEqual (safeMaximum nil) nothing
isStructEqual (safeMinimum (cons 3 (cons 1 (cons 2 nil)))) (just 1)
isStructEqual (safeMaximum (cons 3 (cons 1 (cons 2 nil)))) (just 3)
isStructEqual (clamp 2 4 1) 2
isStructEqual (clamp 2 4 3) 3
isStructEqual (clamp 2 4 5) 4

# --- Miscellaneous ---
isStructEqual (compose succ succ 1) 3
isStructEqual (flip minus 2 5) 3
isStructEqual (on plus succ 2 3) 7
isStructEqual (apply succ 4) 5
isStructEqual (partial plus 2 3) 5
isStructEqual (partial2 plus 2 3 4) 1024
isStructEqual (memoize succ 10) 11
isStructEqual (id2 123) 123
isStructEqual (const2 7 8) 7

# --- Additional List Operations ---
isStructEqual (take 3 (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))) [1,2,3]
isStructEqual (drop 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))) [3,4]
isStructEqual (nth 2 (cons 10 (cons 20 (cons 30 (cons 40 nil))))) 30
isStructEqual (any (λx.gt x 3) (cons 1 (cons 2 (cons 5 nil)))) true
isStructEqual (all even (cons 2 (cons 4 (cons 6 nil)))) true
isStructEqual (all even (cons 2 (cons 3 (cons 6 nil)))) false
isStructEqual (sum (cons 1 (cons 2 (cons 3 (cons 4 nil))))) 10
isStructEqual (product (cons 2 (cons 3 (cons 4 nil)))) 24
isStructEqual (maximum (cons 1 (cons 5 (cons 3 (cons 2 nil))))) 5
isStructEqual (minimum (cons 4 (cons 1 (cons 3 (cons 2 nil))))) 1

# --- Advanced List Utilities ---
isStructEqual (elem 3 (cons 1 (cons 2 (cons 3 nil)))) true
isStructEqual (elem 5 (cons 1 (cons 2 (cons 3 nil)))) false
isStructEqual (notElem 5 (cons 1 (cons 2 (cons 3 nil)))) true
isStructEqual (nub (cons 1 (cons 2 (cons 1 (cons 3 (cons 2 nil)))))) [3, 2, 1]
isStructEqual (unique (cons 1 (cons 2 (cons 1 (cons 3 nil))))) [3, 2, 1]
isStructEqual (last (cons 1 (cons 2 (cons 3 nil)))) 3
isStructEqual (init (cons 1 (cons 2 (cons 3 nil)))) [1,2]
isStructEqual (safeInit nil) nil
isStructEqual (safeInit (cons 1 nil)) nil
isStructEqual (safeDiv 10 2) (just 5)
isStructEqual (safeDiv 10 0) nothing
isStructEqual (safeInitMaybe nil) nothing
isStructEqual (safeInitMaybe (cons 1 nil)) nothing
isStructEqual (safeInitMaybe (cons 1 (cons 2 nil))) (just [1])
isStructEqual (safeInit (cons 1 (cons 2 nil))) [1]
isStructEqual (safeInitMaybe (cons 1 (cons 2 (cons 3 nil)))) (just [1,2])
isStructEqual (safeDiv 10 2) (safediv 10 2)

# --- Enumeration and Range Functions ---
isStructEqual (enumFromTo 3 7) [3,4,5,6,7]
isStructEqual (enumFrom 5 4) [5,6,7,8]
isStructEqual (iota 4) [0,1,2,3]
isStructEqual (replicate 3 7) [7,7,7]
isStructEqual (repeat 3 9) [9,9,9]

# --- Iteration and Application ---
isStructEqual (iterate succ 5 0) 5
isStructEqual (times 3 succ 0) 3
isStructEqual (when true succ 5) 6
isStructEqual (when false succ 5) 5
isStructEqual (unless true succ 5) 5
isStructEqual (unless false succ 5) 6
isStructEqual (cond true 42 99) 42

# --- Pair Operations ---
isStructEqual (pair 1 2) (pair 1 2)
isStructEqual (first (pair 10 20)) 10
isStructEqual (second (pair 10 20)) 20
isStructEqual (swap (pair 1 2)) (pair 2 1)

# --- Advanced Numeric Functions ---
isStructEqual (abs 5) 5
isStructEqual (sqrt 16) 4
isStructEqual (sqrt 25) 5
isStructEqual (isPrime 7) true
isStructEqual (isPrime 8) false
isStructEqual (isPrime 2) true
isStructEqual (isPrime 1) false
isStructEqual (primes 10) [2,3,5,7]

# --- String/Character Operations ---
# words / unwords expectations left descriptive due to encoding specifics
# words (cons 104 (cons 101 (cons 108 (cons 108 (cons 111 nil)))))
# unwords (cons (cons 104 (cons 105 nil)) (cons (cons 121 (cons 111 nil)) nil))

# --- Set Operations on Lists ---
isStructEqual (union (cons 1 (cons 2 nil)) (cons 2 (cons 3 nil))) [1,2,3]
isStructEqual (intersect (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 3 (cons 4 nil)))) [2,3]
isStructEqual (difference (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 4 nil))) [1,3]
isStructEqual (isSubset (cons 1 (cons 2 nil)) (cons 1 (cons 2 (cons 3 nil)))) true
isStructEqual (isSuperset (cons 1 (cons 2 (cons 3 nil))) (cons 1 (cons 2 nil))) true

# --- Advanced Combinators ---
isStructEqual (omega I) I
isStructEqual (mockingbird I) I
isStructEqual (thrush 5 succ) 6
isStructEqual (cardinal minus 3 10) 7
isStructEqual (bluebird succ pred 5) 5
isStructEqual (kestrel 42 99) 42
isStructEqual (warbler plus 3) 6
isStructEqual (starling (K succ) (K 2) 0) 3

# --- Curry and Uncurry Functions ---
isStructEqual (curry3 (λt.plus (first t) (plus (first (second t)) (second (second t)))) 1 2 3) 6
isStructEqual (uncurry plus (pair 7 3)) 10
isStructEqual (uncurry3 (λx y z.plus x (plus y z)) (pair 1 (pair 2 3))) 6

# --- More Maybe Operations ---
isStructEqual (maybeMap succ (just 5)) (just 6)
isStructEqual (maybeMap succ nothing) nothing

# --- State Monad (simplified) ---
isStructEqual (runState (returnState 42) 0) (runState (returnState 42) 0)
isStructEqual (runState getState 123) (runState getState 123)

# --- Advanced Tree Operations ---
isStructEqual (treeSize (leaf 1)) 1
isStructEqual (treeSize nil) 0
isStructEqual (treeDepth (leaf 1)) 1
isStructEqual (treeDepth nil) 0
isStructEqual (inOrder (leaf 5)) [5]
isStructEqual (preOrder (leaf 5)) [5]
isStructEqual (postOrder (leaf 5)) [5]

# --- Edge Cases and Error Conditions ---
isStructEqual (div 5 0) 0
isStructEqual (mod 5 0) 0
isStructEqual (head nil) nil
isStructEqual (tail nil) nil
isStructEqual (pred 0) 0
isStructEqual (minus 3 5) 0

# --- Complex Expressions ---
isStructEqual (map (λx.mult x x) (range 5)) [0,1,4,9,16]
isStructEqual (filter (λx.eq (mod x 3) 0) (range 10)) [0,3,6,9]
isStructEqual (foldr max 0 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil)))))) 9
isStructEqual (foldl min 999 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil)))))) 1

# --- Recursive Function Tests ---
isStructEqual (factRec 4) 24
isStructEqual (fibRec 6) 8
isStructEqual (sumUptoRec 5) 15

# --- Performance / Stress (sanity) ---
isStructEqual (length (range 50)) 50
isStructEqual (sum (range 10)) 45
isStructEqual (fact 6) 720
isStructEqual (fib 10) 55

# --- Y combinator derived functions ---
isStructEqual (factY 4) 24
isStructEqual (fibY 6) 8
isStructEqual (sumUptoY 5) 15
isStructEqual (expY 2 5) 32
isStructEqual (rangeY 10) [0,1,2,3,4,5,6,7,8,9]
isStructEqual (countdownY 5) [5,4,3,2,1,0]
isStructEqual (gcdY 48 18) 6
isStructEqual (lcmY 12 15) 60
isStructEqual (mapY succ (range 5)) [1,2,3,4,5]
isStructEqual (filterY (λx.eq (mod x 2) 0) (range 10)) [0,2,4,6,8]
isStructEqual (lengthY (range 50)) 50
isStructEqual (reverseY (range 5)) [4,3,2,1,0]
isStructEqual (sumY (range 5)) 10
isStructEqual (productY (tail (range 7))) 720
isStructEqual (anyY (λx.gt x 3) (range 5)) true
isStructEqual (allY (λx.leq x 5) (range 5)) true
isStructEqual (findY (λx.eq x 3) (range 5)) 3

isStructEqual [1,2,3] [1,2,3]
isStructEqual [1,3 .. 6] [1,3,5]
isStructEqual [1,2,3,[4..7],[11 .. 8]] [1,2,3,[4,5,6,7],[11,10,9,8]]

isStructEqual (mapY (ackermann 2) [2..10]) [7,9,11,13,15,17,19,21,23]

# --- Let and Let Rec Examples ---
isStructEqual (let x = 5 in x + 2) 7
isStructEqual (let x = 1, y = 2 in x + y) 3
isStructEqual (let a = 10, b = 20, c = 30 in a + b + c) 60
isStructEqual (let x = 2, y = 3 in x * (y + 1)) 8
isStructEqual (let rec fact = \n. if (eq n 0) 1 (mult n (fact (pred n))) in fact 5) 120
isStructEqual (let rec fib = \n. if (leq n 1) n (plus (fib (pred n)) (fib (minus n 2))) in fib 6) 8
isStructEqual (let rec sumTo = \n. if (eq n 0) 0 (plus n (sumTo (pred n))) in sumTo 4) 10

# --- Pipeline Operator (|>) ---
isStructEqual (5 |> succ) 6
isStructEqual (5 |> square) 25
isStructEqual (5 |> square |> succ) 26
isStructEqual (5 |> succ |> square) 36
isStructEqual (1 |> succ |> succ |> succ) 4
isStructEqual ((5 |> square) |> succ) 26
isStructEqual (5 |> (square |> succ)) 26
isStructEqual (2 |> succ |> square |> pred) 8

# --- Arrow Function Syntax ---
isStructEqual ((x -> x + 1) 5) 6
isStructEqual ((x -> succ x) 4) 5
isStructEqual ((x, y -> x + y) 3 2) 5
isStructEqual ((x, y -> mult x y) 4 3) 12
isStructEqual ((x -> x * x) 6) 36
isStructEqual ((x, y, z -> x + y + z) 1 2 3) 6
isStructEqual (let f = x -> x + 1 in f 10) 11
isStructEqual (let add = x, y -> x + y in add 7 8) 15
isStructEqual (let add = x -> y -> x + y in let mult2 = x -> x * 2 in let div2 = x -> x / 2 in (add 5 3) |> mult2 |> div2) 8
isStructEqual (let add = x, y -> x + y in let mult2 = x -> x * 2 in let div2 = x -> x / 2 in (add 5 3) |> mult2 |> div2) 8
isStructEqual (3 |> (x -> x + 1) |> (y -> y * 2)) 8
isStructEqual ((x -> y -> x + y) 5 3) 8
isStructEqual ((f -> x -> f (f x)) succ 0) 2
isStructEqual (map (x -> x + 1) [1,2,3]) [2,3,4]
isStructEqual (filter (x -> x > 2) [1,2,3,4,5]) [3,4,5]
# Parsing sanity (expression form) - cannot structural test without full desugaring; skip

# --- Infix Composition Operator (.) ---
inc = x -> x + 1
double2 = x -> x * 2   # renamed from 'double' to avoid shadowing stdlib/native name
square = x -> x * x
isStructEqual (inc . double2 . 3) 7
isStructEqual (double2 . inc . 3) 8
isStructEqual (square . inc . 4) 25
isStructEqual (inc . double2 . square . 2) 9
isStructEqual (double2 . inc . square . 2) 10
isStructEqual (inc . double2 . 3 |> square) 49

# --- Advanced Multi-Feature Tests ---
isStructEqual (foldr plus 0 (filter (λx.gt x 2) (map (λx.mult x x) (range 5)))) 29
isStructEqual (let double2 = x -> x * 2 in (map double2 [1,2,3,4]) |> (filter (x -> x > 4))) [6,8]
isStructEqual (let rec sumEvens = \xs. if (isnil xs) 0 (if (even (head xs)) (plus (head xs) (sumEvens (tail xs))) (sumEvens (tail xs))) in sumEvens [1,2,3,4,5,6]) 12
isStructEqual ((maybeMap (x -> x * x) (just 7)) |> (maybe 0 (x -> x + 1))) 50
isStructEqual (let tree = node 1 (leaf 2) (node 3 (leaf 4) (leaf 5)) in foldr plus 0 (inOrder tree)) 15
isStructEqual (map (x -> map (y -> x * y) [1,2,3]) [4,5]) [[4,8,12],[5,10,15]]
isStructEqual (let add3 = x -> y -> z -> x + y + z in (add3 1 2) |> (f -> f 3)) 6
isStructEqual (find (x -> x % 6 == 0) (map (x -> x + 1) [1,3,5,7,8])) 6
isStructEqual (foldl mult 1 (map (pair -> plus (first pair) (second pair)) (zip [1,2,3] [4,5,6]))) 315
isStructEqual (let f = x -> x * 3 in (map f (filter (x -> x > 2) (range 7))) |> (foldl plus 0)) 54

# Maybe monad tests using stdlib encoding (pair-based)
bind = λm f. if (isNothing m) nothing (f (fromJust m))
isStructEqual (bind (just 3) (λx. just (x + 1))) (just 4)
isStructEqual (bind nothing (λx. just (x + 1))) nothing

# Lambda placeholder examples
isStructEqual ((\_ . 42) 123) 42
isStructEqual ((\_ _ . 99) 1 2) 99
isStructEqual ((\x _ . x) 7 8) 7
isStructEqual ((\_ y . y) 5 6) 6
isStructEqual ((_ , _ -> 0) 10 20) 0
isStructEqual ((x, _ -> x) 42 99) 42
isStructEqual (let f = \_ . 123 in f 456) 123
isStructEqual (let g = \_ _ . 1 in g 2 3) 1
isStructEqual (let h = \_ y . y in h 0 9) 9

# Macro System Tests
:macro (letbind $var $val $expr) => ((λ$var.$expr) $val)
isStructEqual ((letbind x 42 (plus x 10))) 52
isStructEqual ((letbind y 5 (mult y y))) 25
isStructEqual ((letbind z 3 (exp 2 z))) 8
:macro (dup $x) => (plus $x $x)  # renamed from (double $x)
isStructEqual ((dup 7)) 14
isStructEqual ((dup (succ 4))) 10
:macro (triple $x) => (plus $x (plus $x $x))
isStructEqual ((triple 8)) 24
:macro (when $cond $expr) => (if $cond $expr I)
isStructEqual ((when true (succ 10))) 11
isStructEqual ((when false (succ 10))) I
:macro (unless $cond $expr) => (if $cond I $expr)
isStructEqual ((unless false (succ 20))) 21
isStructEqual ((unless true (succ 20))) I
for x at [1..10] do (succ x)  # retains list output
for x at [1..10] do (square x)
for x at [1..10] do (div x 2)
for x at [1..10] do (mod x 2)
isStructEqual (iff false then 42 else 9) 9
isStructEqual (iff true then 42 else 9) 42
:macro (swappair $p) => (pair (second $p) (first $p))
isStructEqual ((swappair (pair 1 2))) (pair 2 1)
:macro (list3 $a $b $c) => (cons $a (cons $b (cons $c nil)))
isStructEqual ((list3 1 2 3)) [1,2,3]
:macro (square $x) => (mult $x $x)
isStructEqual ((square 6)) 36
isStructEqual ((square (plus 3 2))) 25
:macro (cube $x) => (mult $x (mult $x $x))
isStructEqual ((cube 3)) 27
:macro (between $x $low $high) => (and (geq $x $low) (leq $x $high))
isStructEqual ((between 5 3 7)) true
isStructEqual ((between 2 3 7)) false
isStructEqual ((between 8 3 7)) false
:macro (inc $x) => (succ $x)
:macro (dec $x) => (pred $x)
isStructEqual ((inc 10)) 11
isStructEqual ((dec 10)) 9
isStructEqual ((inc (square 4))) 17
isStructEqual ((square (inc 4))) 25
:macro (quadratic $a $b $c $x) => (plus (mult $a (square $x)) (plus (mult $b $x) $c))
isStructEqual ((quadratic 2 3 1 4)) 45
:macro (fact2 $n) => (if (iszero $n) 1 (mult $n (fact2 (pred $n))))  # not structurally testable (recursive macro) left as definition

# Additional macro capability tests already at end of original file (kept as-is or identity comparisons)

# ============================================================================
# Extended Coverage: Advanced Macro / Variadic / Guards / Ordering / Lazy / Church Lists
# ============================================================================

# --- Advanced Macro System (Arity & Ordering) ---
:macro (arityDemo) => 0
:macro (arityDemo $a) => 1
:macro (arityDemo $a $b) => 2
isStructEqual (arityDemo) 0
isStructEqual (arityDemo 42) 1
isStructEqual (arityDemo 7 8) 2

# --- Variadic Macros ---
:macro (listify $xs...) => $xs
isStructEqual (listify) nil
isStructEqual (listify 1) [1]
isStructEqual (listify 1 2 3) [1,2,3]

# Variadic with fixed prefix
:macro (sumall $x $rest...) => (foldl plus $x $rest)
isStructEqual (sumall 5) 5
isStructEqual (sumall 1 2 3 4) 10

# --- Guarded Macros & Recency ---
:macro (choose $x) when false => 0
:macro (choose $x) => $x
isStructEqual (choose 9) 9

:macro (choose2 $x) => $x
:macro (choose2 $x) when true => 42
isStructEqual (choose2 7) 42

# Guard depending on variable (literal false only fails)
:macro (guardVar $flag $x) => 0
:macro (guardVar $flag $x) when $flag => $x
isStructEqual (guardVar true 7) 7
isStructEqual (guardVar false 7) 0

# Higher arity precedence
:macro (pref $x $y) => (mult $x $y)
:macro (pref $x) => (succ $x)
isStructEqual (pref 3 4) 12
isStructEqual (pref 5) 6

# Recency (shadowing)
:macro (shadow $x) => (plus $x 1)
:macro (shadow $x) => (plus $x 2)
isStructEqual (shadow 3) 5

# Exact match vs rest capture precedence
:macro (mix $a $b) => (plus $a $b)
:macro (mix $a $rest...) => (foldl plus $a $rest)
isStructEqual (mix 2 3) 5
isStructEqual (mix 2 3 4 5) 14

# --- Pair Equality Helper (uses stdlib pairEq) ---
isStructEqual (pairEq eq eq (pair 1 2) (pair 1 2)) true

# --- Church List Round Trip ---
# Build a Church-encoded list and fold it with cons/nil to a concrete list
isStructEqual (((λf.λz.f 1 (f 2 (f 3 z))) (λh.λt.cons h t)) nil) [1,2,3]

# --- Lazy Evaluation (ensure unused branch not evaluated) ---
# Ω (diverges if forced) = (λx.x x) (λx.x x); use built inline
isStructEqual (if true 1 ((λx.x x) (λx.x x))) 1

# --- Variadic / Utility Macro Extensions ---
:macro (duplicate $x) => (pair $x $x)
isStructEqual (duplicate 7) (pair 7 7)

# Complex nested macro example for process style (inc (square (dec x)))
:macro (dec2 $x) => (pred $x)
:macro (process2 $x) => (inc (square (dec2 $x)))
isStructEqual (process2 5) 17

# Macro composition ordering (outer/inner)
:macro (outer $x) => (inner (plus $x 1))
:macro (inner $y) => (mult $y 2)
isStructEqual (outer 4) 10

# Apply twice (higher-order macro)
:macro (apply_twice $f $x) => ($f ($f $x))
isStructEqual (apply_twice succ 0) 2
isStructEqual (apply_twice (λx.mult x 2) 3) 12

# Composition macro reuse with new 'dup' macro already defined earlier
:macro (compose2b $f $g $x) => ($f ($g $x))
isStructEqual (compose2b succ dup 5) 11

# Final complex macro calculation (mirrors complex_calc)
:macro (complex_calc $a $b $c) => (letbind x (plus $a $b) (letbind y (mult x $c) (square y)))
isStructEqual (complex_calc 2 3 4) 400

# Note: Eta-equivalence not tested (λx.f x vs f) – current equality is alpha only.

# ============================================================================
# Essential Additional Core Law Tests
# ============================================================================

# Alpha-equivalence (binder renaming) & capture avoidance
isStructEqual (λx.λy.x) (λa.λb.a)
isStructEqual ((λx.λy.x) 1) (λz.1)
isStructEqual (λx.λx.λx.x) (λa.λb.λc.c)  # inner shadowing
isStructEqual ((λx.λx.λx.x) 1 2 3) ((λa.λb.λc.c) 1 2 3) # inner shadowing with application

# Combinator Laws
isStructEqual ((S K K) 5) 5
isStructEqual ((S K I) 7) 7

# Arithmetic Identity Laws
isStructEqual (plus 7 0) 7
isStructEqual (plus 0 9) 9
isStructEqual (mult 9 1) 9
isStructEqual (mult 9 0) 0
isStructEqual (minus 5 0) 5

# List Functor Identity
isStructEqual (map I [1,2,3]) [1,2,3]

# Lazy Evaluation (false branch)
isStructEqual (if false ((λx.x x) (λx.x x)) 2) 2

# Nested Pair Equality using pairEq
# isStructEqual (pairEq eq eq (pair (pair 1 2) (pair 3 4)) (pair (pair 1 2) (pair 3 4))) true

# ============================================================================
# Additional Positive Law / Property Tests (no negatives)
# ============================================================================

# Maybe Functor Laws
isStructEqual (maybeMap I (just 5)) (just 5)                     # identity
isStructEqual (maybeMap (λx.mult x x) (maybeMap succ (just 3))) (just 16)   # composition exemplar

# Either usage (Right-biased behavior already covered)
isStructEqual (either succ succ (left 5)) 6
isStructEqual (either succ succ (right 5)) 6

# Append associativity
isStructEqual (append (append [1] [2]) [3]) (append [1] (append [2] [3]))

# Reverse distributes over append: reverse (xs ++ ys) = reverse ys ++ reverse xs
isStructEqual (reverse (append [1,2] [3,4,5])) (append (reverse [3,4,5]) (reverse [1,2]))

# Map length invariant
isStructEqual (length (map succ [1,2,3,4])) (length [1,2,3,4])

# Sum via fold equivalence
isStructEqual (sum [1,2,3,4]) (foldl plus 0 [1,2,3,4])

# Maybe bind laws (using bind defined above)
isStructEqual (bind (just 5) (λx.just (plus x 1))) (just 6)      # left identity exemplar
isStructEqual (bind (just 7) just) (just 7)                     # right identity exemplar

# Tree: size equals length of inorder traversal
isStructEqual (treeSize (node 1 (leaf 2) (leaf 3))) (length (inOrder (node 1 (leaf 2) (leaf 3))))

# test multiple commands in a single line
plus 1 3; mult 2 4; minus 5 1; fib 10
plus 4 3; :macro (aa $a) => (plus $a $a); aa 4
plus 4 3; :macro (bb $a) => (plus $a $a); bb 4; :macro (cc $b) => (mult $b $b); cc 5 # define and call macros