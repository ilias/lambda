# =========================================================================
# Structural Equality Test Suite (auto-converted from tests.lambda)
# Each prior test:  expr  # expect VALUE  ==>  alphaEq expr VALUE
# Loads stdlib.lambda first; then load this file: :load struct-tests.lambda
# NOTE:
#   - Some descriptive expectations (e.g., words/unwords textual forms) kept as comments
#   - Ambiguous expectations were converted where a reasonable canonical form exists
# =========================================================================

:test clear
:clear cache

# --- Boolean Logic ---
alphaEq (true 1 0) 1
alphaEq (false 1 0) 0
alphaEq (not true) false
alphaEq (not false) true
alphaEq (and true true) true
alphaEq (and true false) false
alphaEq (or true false) true
alphaEq (xor true true) false
alphaEq (if true 42 99) 42
alphaEq (if false 42 99) 99
alphaEq (eqBool true true) true
alphaEq (eqBool true false) false

# --- Church Numerals ---
alphaEq (zero (λx.1) 0) 0
alphaEq (succ (succ zero)) 2
alphaEq (plus 2 3) 5
alphaEq (mult 3 4) 12
alphaEq (pred 3) 2
alphaEq (minus 5 2) 3
alphaEq (iszero 0) true
alphaEq (iszero 1) false
alphaEq (exp 2 3) 8

# --- Division and Modulo ---
alphaEq (div 7 2) 3
alphaEq (mod 7 2) 1

# --- Comparisons ---
alphaEq (leq 2 3) true
alphaEq (leq 3 2) false
alphaEq (eq 4 4) true
alphaEq (eq 4 5) false
alphaEq (gt 5 2) true
alphaEq (lt 2 5) true
alphaEq (neq 2 2) false
alphaEq (neq 2 3) true

# --- Numeric Operations ---
alphaEq (max 3 7) 7
alphaEq (min 3 7) 3
alphaEq (even 4) true
alphaEq (odd 5) true
alphaEq (square 6) 36
alphaEq (double 8) 16
alphaEq (half 9) 4
alphaEq (pow 2 5) 32

# --- List Operations ---
alphaEq nil nil
alphaEq (isnil nil) true
alphaEq (isnil (cons 1 nil)) false
alphaEq (cons 1 (cons 2 (cons 3 nil))) [1,2,3]
alphaEq (head (cons 1 (cons 2 (cons 3 nil)))) 1
alphaEq (tail (cons 1 (cons 2 (cons 3 nil)))) [2,3]
alphaEq (length (cons 1 (cons 2 (cons 3 nil)))) 3
alphaEq (reverse (cons 1 (cons 2 (cons 3 nil)))) [3,2,1]
alphaEq (append (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil))) [1,2,3,4,5]
alphaEq (map succ (cons 1 (cons 2 (cons 3 nil)))) [2,3,4]
alphaEq (filter even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) [2,4]
alphaEq (foldr plus 0 (cons 1 (cons 2 (cons 3 nil)))) 6
alphaEq (foldl plus 0 (cons 1 (cons 2 (cons 3 nil)))) 6

# --- Advanced List Operations ---
alphaEq (range 5) [0,1,2,3,4]
alphaEq (countdown 3) [3,2,1,0]
alphaEq (zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil))) (zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil)))  # structural tuple pairs may need dedicated eq; kept identity
alphaEq (concat (cons (cons 1 (cons 2 (cons 3 nil))) (cons (cons 4 nil) nil))) [1,2,3,4]

# --- Combinators and Utilities ---
alphaEq (K 42 99) 42
alphaEq (I 77) 77
alphaEq (S (K succ) (K 3) 0) 4
alphaEq (B succ succ 1) 3
alphaEq (C minus 5 2) 0

# --- Recursion and Advanced Functions ---
alphaEq (fact 5) 120
alphaEq (fib 7) 13
alphaEq (gcd 18 24) 6
alphaEq (lcm 6 8) 24

# --- Infix Operators ---
alphaEq (2 + 3) 5
alphaEq (7 - 4) 3
alphaEq (3 * 4) 12
alphaEq (9 / 2) 4
alphaEq (9 % 4) 1
alphaEq (2 ^ 4) 16
alphaEq (true && false) false
alphaEq (false || true) true
alphaEq (5 == 5) true
alphaEq (5 != 4) true
alphaEq (2 < 3) true
alphaEq (2 <= 2) true
alphaEq (4 > 3) true
alphaEq (4 >= 4) true

# --- Maybe/Optional Type ---
alphaEq (just 42) (just 42)
alphaEq nothing nil
alphaEq (isJust (just 1)) true
alphaEq (isNothing nothing) true
alphaEq (fromJust (just 7)) 7
alphaEq (fromMaybe 99 (just 5)) 5
alphaEq (fromMaybe 99 nothing) 99
alphaEq (maybe 0 succ (just 3)) 4
alphaEq (maybe 0 succ nothing) 0

# --- Either Type ---
alphaEq (left 1) (left 1)
alphaEq (right 2) (right 2)
alphaEq (isLeft (left 5)) true
alphaEq (isRight (right 6)) true
alphaEq (either succ pred (left 10)) 11
alphaEq (either succ pred (right 10)) 9

# --- Tree Data Structure ---
alphaEq (leaf 7) (leaf 7)
alphaEq (node 1 (leaf 2) (leaf 3)) (node 1 (leaf 2) (leaf 3))
alphaEq (treeValue (leaf 8)) 8
alphaEq (treeLeft (node 1 (leaf 2) (leaf 3))) (leaf 2)
alphaEq (treeRight (node 1 (leaf 2) (leaf 3))) (leaf 3)
alphaEq (isLeaf (leaf 9)) true
alphaEq (isLeaf (node 1 (leaf 2) (leaf 3))) false

# --- zipWith, scan*, find, partition, splitAt ---
alphaEq (zipWith plus (cons 1 (cons 2 nil)) (cons 10 (cons 20 nil))) [11,22]
alphaEq (scanl plus 0 (cons 1 (cons 2 (cons 3 nil)))) [0,1,3,6]
alphaEq (scanr plus 0 (cons 1 (cons 2 (cons 3 nil)))) [6,5,3,0]
alphaEq (find (eq 2) (cons 1 (cons 2 (cons 3 nil)))) 2
alphaEq (partition even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) (partition even (cons 1 (cons 2 (cons 3 (cons 4 nil)))))  # complex tuple result; identity check
alphaEq (splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))) (splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil)))))

# --- Edge Cases and Safe Functions ---
alphaEq (safeMinimum nil) nothing
alphaEq (safeMaximum nil) nothing
alphaEq (safeMinimum (cons 3 (cons 1 (cons 2 nil)))) (just 1)
alphaEq (safeMaximum (cons 3 (cons 1 (cons 2 nil)))) (just 3)
alphaEq (clamp 2 4 1) 2
alphaEq (clamp 2 4 3) 3
alphaEq (clamp 2 4 5) 4

# --- Miscellaneous ---
alphaEq (compose succ succ 1) 3
alphaEq (flip minus 2 5) 3
alphaEq (on plus succ 2 3) 7
alphaEq (apply succ 4) 5
alphaEq (partial plus 2 3) 5
alphaEq (partial2 plus 2 3 4) 1024
alphaEq (memoize succ 10) 11
alphaEq (id2 123) 123
alphaEq (const2 7 8) 7

# --- Additional List Operations ---
alphaEq (take 3 (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))) [1,2,3]
alphaEq (drop 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))) [3,4]
alphaEq (nth 2 (cons 10 (cons 20 (cons 30 (cons 40 nil))))) 30
alphaEq (any (λx.gt x 3) (cons 1 (cons 2 (cons 5 nil)))) true
alphaEq (all even (cons 2 (cons 4 (cons 6 nil)))) true
alphaEq (all even (cons 2 (cons 3 (cons 6 nil)))) false
alphaEq (sum (cons 1 (cons 2 (cons 3 (cons 4 nil))))) 10
alphaEq (product (cons 2 (cons 3 (cons 4 nil)))) 24
alphaEq (maximum (cons 1 (cons 5 (cons 3 (cons 2 nil))))) 5
alphaEq (minimum (cons 4 (cons 1 (cons 3 (cons 2 nil))))) 1

# --- Advanced List Utilities ---
alphaEq (elem 3 (cons 1 (cons 2 (cons 3 nil)))) true
alphaEq (elem 5 (cons 1 (cons 2 (cons 3 nil)))) false
alphaEq (notElem 5 (cons 1 (cons 2 (cons 3 nil)))) true
alphaEq (nub (cons 1 (cons 2 (cons 1 (cons 3 (cons 2 nil)))))) [3, 2, 1]
alphaEq (unique (cons 1 (cons 2 (cons 1 (cons 3 nil))))) [3, 2, 1]
alphaEq (last (cons 1 (cons 2 (cons 3 nil)))) 3
alphaEq (init (cons 1 (cons 2 (cons 3 nil)))) [1,2]
alphaEq (safeInit nil) nil
alphaEq (safeInit (cons 1 nil)) nil
alphaEq (safeDiv 10 2) (just 5)
alphaEq (safeDiv 10 0) nothing
alphaEq (safeInitMaybe nil) nothing
alphaEq (safeInitMaybe (cons 1 nil)) nothing
alphaEq (safeInitMaybe (cons 1 (cons 2 nil))) (just [1])
alphaEq (safeInit (cons 1 (cons 2 nil))) [1]
alphaEq (safeInitMaybe (cons 1 (cons 2 (cons 3 nil)))) (just [1,2])
alphaEq (safeDiv 10 2) (safediv 10 2)

# --- Enumeration and Range Functions ---
alphaEq (enumFromTo 3 7) [3,4,5,6,7]
alphaEq (enumFrom 5 4) [5,6,7,8]
alphaEq (iota 4) [0,1,2,3]
alphaEq (replicate 3 7) [7,7,7]
alphaEq (repeat 3 9) [9,9,9]

# --- Iteration and Application ---
alphaEq (iterate succ 5 0) 5
alphaEq (times 3 (succ 1)) 8
alphaEq (when true succ 5) 6
alphaEq (when false succ 5) 5
alphaEq (unless true succ 5) 5
alphaEq (unless false succ 5) 6
alphaEq (cond true 42 99) 42

# --- Pair Operations ---
alphaEq (pair 1 2) (pair 1 2)
alphaEq (first (pair 10 20)) 10
alphaEq (second (pair 10 20)) 20
alphaEq (swap (pair 1 2)) (pair 2 1)

# --- Advanced Numeric Functions ---
alphaEq (abs 5) 5
alphaEq (sqrt 16) 4
alphaEq (sqrt 25) 5
alphaEq (isPrime 7) true
alphaEq (isPrime 8) false
alphaEq (isPrime 2) true
alphaEq (isPrime 1) false
alphaEq (primes 10) [2,3,5,7]

# --- String/Character Operations ---
# words / unwords expectations left descriptive due to encoding specifics
# words (cons 104 (cons 101 (cons 108 (cons 108 (cons 111 nil)))))
# unwords (cons (cons 104 (cons 105 nil)) (cons (cons 121 (cons 111 nil)) nil))

# --- Set Operations on Lists ---
alphaEq (union (cons 1 (cons 2 nil)) (cons 2 (cons 3 nil))) [1,2,3]
alphaEq (intersect (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 3 (cons 4 nil)))) [2,3]
alphaEq (difference (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 4 nil))) [1,3]
alphaEq (isSubset (cons 1 (cons 2 nil)) (cons 1 (cons 2 (cons 3 nil)))) true
alphaEq (isSuperset (cons 1 (cons 2 (cons 3 nil))) (cons 1 (cons 2 nil))) true

# --- Advanced Combinators ---
alphaEq (omega I) I
alphaEq (mockingbird I) I
alphaEq (thrush 5 succ) 6
alphaEq (cardinal minus 3 10) 7
alphaEq (bluebird succ pred 5) 5
alphaEq (kestrel 42 99) 42
alphaEq (warbler plus 3) 6
alphaEq (starling (K succ) (K 2) 0) 3

# --- Curry and Uncurry Functions ---
alphaEq (curry3 (λt.plus (first t) (plus (first (second t)) (second (second t)))) 1 2 3) 6
alphaEq (uncurry plus (pair 7 3)) 10
alphaEq (uncurry3 (λx y z.plus x (plus y z)) (pair 1 (pair 2 3))) 6

# --- More Maybe Operations ---
alphaEq (maybeMap succ (just 5)) (just 6)
alphaEq (maybeMap succ nothing) nothing

# --- State Monad (simplified) ---
alphaEq (runState (returnState 42) 0) (runState (returnState 42) 0)
alphaEq (runState getState 123) (runState getState 123)

# --- Advanced Tree Operations ---
alphaEq (treeSize (leaf 1)) 1
alphaEq (treeSize nil) 0
alphaEq (treeDepth (leaf 1)) 1
alphaEq (treeDepth nil) 0
alphaEq (inOrder (leaf 5)) [5]
alphaEq (preOrder (leaf 5)) [5]
alphaEq (postOrder (leaf 5)) [5]

# --- Edge Cases and Error Conditions ---
alphaEq (div 5 0) 0
alphaEq (mod 5 0) 0
alphaEq (head nil) nil
alphaEq (tail nil) nil
alphaEq (pred 0) 0
alphaEq (minus 3 5) 0

# --- Complex Expressions ---
alphaEq (map (λx.mult x x) (range 5)) [0,1,4,9,16]
alphaEq (filter (λx.eq (mod x 3) 0) (range 10)) [0,3,6,9]
alphaEq (foldr max 0 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil)))))) 9
alphaEq (foldl min 999 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil)))))) 1

# --- Recursive Function Tests ---
alphaEq (factRec 4) 24
alphaEq (fibRec 6) 8
alphaEq (sumUptoRec 5) 15

# --- Performance / Stress (sanity) ---
alphaEq (length (range 50)) 50
alphaEq (sum (range 10)) 45
alphaEq (fact 6) 720
alphaEq (fib 10) 55

# --- Y combinator derived functions ---
alphaEq (factY 4) 24
alphaEq (fibY 6) 8
alphaEq (sumUptoY 5) 15
alphaEq (expY 2 5) 32
alphaEq (rangeY 10) [0,1,2,3,4,5,6,7,8,9]
alphaEq (countdownY 5) [5,4,3,2,1,0]
alphaEq (gcdY 48 18) 6
alphaEq (lcmY 12 15) 60
alphaEq (mapY succ (range 5)) [1,2,3,4,5]
alphaEq (filterY (λx.eq (mod x 2) 0) (range 10)) [0,2,4,6,8]
alphaEq (lengthY (range 50)) 50
alphaEq (reverseY (range 5)) [4,3,2,1,0]
alphaEq (sumY (range 5)) 10
alphaEq (productY (tail (range 7))) 720
alphaEq (anyY (λx.gt x 3) (range 5)) true
alphaEq (allY (λx.leq x 5) (range 5)) true
alphaEq (findY (λx.eq x 3) (range 5)) 3

alphaEq [1,2,3] [1,2,3]
alphaEq [1,3 .. 6] [1,3,5]
alphaEq [1,2,3,[4..7],[11 .. 8]] [1,2,3,[4,5,6,7],[11,10,9,8]]

alphaEq (mapY (ackermann 2) [2..10]) [7,9,11,13,15,17,19,21,23]

# --- Let and Let Rec Examples ---
alphaEq (let x = 5 in x + 2) 7
alphaEq (let x = 1, y = 2 in x + y) 3
alphaEq (let a = 10, b = 20, c = 30 in a + b + c) 60
alphaEq (let x = 2, y = 3 in x * (y + 1)) 8
alphaEq (let rec fact = \n. if (eq n 0) 1 (mult n (fact (pred n))) in fact 5) 120
alphaEq (let rec fib = \n. if (leq n 1) n (plus (fib (pred n)) (fib (minus n 2))) in fib 6) 8
alphaEq (let rec sumTo = \n. if (eq n 0) 0 (plus n (sumTo (pred n))) in sumTo 4) 10

# --- Macro Expansion inside let / let rec (iff) ---
# Ensure iff macro expands inside non-recursive let binding
alphaEq (let f = n -> (iff (iszero n) then 1 else (succ n)) in f 0) 1
alphaEq (let f = n -> (iff (iszero n) then 1 else (succ n)) in f 5) 6

# Ensure iff macro expands inside recursive let binding (with and without outer parens)
alphaEq (let rec fact = n -> (iff (iszero n) then 1 else (mult n (fact (pred n)))) in fact 4) 24
alphaEq (let rec fact = n -> iff (iszero n) then 1 else (mult n (fact (pred n))) in fact 4) 24

# Macro inside later binding referencing earlier binding value
alphaEq (let a = 1, b = (iff (eq a 1) then 2 else 3) in a + b) 3

# --- Macro Expansion inside let / let rec (when / unless) ---
# Non-recursive let with when
alphaEq (let add1IfZero = n -> (when (iszero n) succ n) in add1IfZero 0) 1
alphaEq (let add1IfZero = n -> (when (iszero n) succ n) in add1IfZero 5) 5

# Non-recursive let with unless
alphaEq (let add1UnlessZero = n -> (unless (iszero n) succ n) in add1UnlessZero 0) 0
alphaEq (let add1UnlessZero = n -> (unless (iszero n) succ n) in add1UnlessZero 5) 6

# Multi-binding referencing earlier binding
alphaEq (let x = 0, y = (when (iszero x) succ 5) in y) 6
alphaEq (let x = 0, y = (unless (iszero x) succ 5) in y) 5

# Recursive let using when inside body
alphaEq (let rec countdown = n -> (when (gt n 0) pred n) in countdown 3) 2
alphaEq (let rec countdown = n -> (when (gt n 0) pred n) in countdown 0) 0

# Recursive let using unless inside body
alphaEq (let rec upIfLess5 = n -> (unless (geq n 5) succ n) in upIfLess5 3) 4
alphaEq (let rec upIfLess5 = n -> (unless (geq n 5) succ n) in upIfLess5 5) 5

# --- Pipeline Operator (|>) ---
alphaEq (5 |> succ) 6
alphaEq (5 |> square) 25
alphaEq (5 |> square |> succ) 26
alphaEq (5 |> succ |> square) 36
alphaEq (1 |> succ |> succ |> succ) 4
alphaEq ((5 |> square) |> succ) 26
alphaEq (5 |> (square |> succ)) 26
alphaEq (2 |> succ |> square |> pred) 8

# --- Arrow Function Syntax ---
alphaEq ((x -> x + 1) 5) 6
alphaEq ((x -> succ x) 4) 5
alphaEq ((x, y -> x + y) 3 2) 5
alphaEq ((x, y -> mult x y) 4 3) 12
alphaEq ((x -> x * x) 6) 36
alphaEq ((x, y, z -> x + y + z) 1 2 3) 6
alphaEq (let f = x -> x + 1 in f 10) 11
alphaEq (let add = x, y -> x + y in add 7 8) 15
alphaEq (let add = x -> y -> x + y in let mult2 = x -> x * 2 in let div2 = x -> x / 2 in (add 5 3) |> mult2 |> div2) 8
alphaEq (let add = x, y -> x + y in let mult2 = x -> x * 2 in let div2 = x -> x / 2 in (add 5 3) |> mult2 |> div2) 8
alphaEq (3 |> (x -> x + 1) |> (y -> y * 2)) 8
alphaEq ((x -> y -> x + y) 5 3) 8
alphaEq ((f -> x -> f (f x)) succ 0) 2
alphaEq (map (x -> x + 1) [1,2,3]) [2,3,4]
alphaEq (filter (x -> x > 2) [1,2,3,4,5]) [3,4,5]
# Parsing sanity (expression form) - cannot structural test without full desugaring; skip

# --- Infix Composition Operator (.) ---
inc = x -> x + 1
double2 = x -> x * 2   # renamed from 'double' to avoid shadowing stdlib/native name
square = x -> x * x
alphaEq (inc . double2 . 3) 7
alphaEq (double2 . inc . 3) 8
alphaEq (square . inc . 4) 25
alphaEq (inc . double2 . square . 2) 9
alphaEq (double2 . inc . square . 2) 10
alphaEq (inc . double2 . 3 |> square) 49

# --- Application operator ($) tests ---
alphaEq (succ (pred 5)) (succ $ pred 5)
alphaEq (succ (pred (succ 4))) (succ $ pred $ succ 4)
alphaEq (map (λx.mult x x) (filter (λx.gt x 2) (range 6))) (map (λx.mult x x) $ filter (λx.gt x 2) $ range 6)

# Macro with $ usage
:macro (m $x) => succ $x
alphaEq (m 4) 5

# --- Advanced Multi-Feature Tests ---
alphaEq (foldr plus 0 (filter (λx.gt x 2) (map (λx.mult x x) (range 5)))) 29
alphaEq (let double2 = x -> x * 2 in (map double2 [1,2,3,4]) |> (filter (x -> x > 4))) [6,8]
alphaEq (let rec sumEvens = \xs. if (isnil xs) 0 (if (even (head xs)) (plus (head xs) (sumEvens (tail xs))) (sumEvens (tail xs))) in sumEvens [1,2,3,4,5,6]) 12
alphaEq ((maybeMap (x -> x * x) (just 7)) |> (maybe 0 (x -> x + 1))) 50
alphaEq (let tree = node 1 (leaf 2) (node 3 (leaf 4) (leaf 5)) in foldr plus 0 (inOrder tree)) 15
alphaEq (map (x -> map (y -> x * y) [1,2,3]) [4,5]) [[4,8,12],[5,10,15]]
alphaEq (let add3 = x -> y -> z -> x + y + z in (add3 1 2) |> (f -> f 3)) 6
alphaEq (find (x -> x % 6 == 0) (map (x -> x + 1) [1,3,5,7,8])) 6
alphaEq (foldl mult 1 (map (pair -> plus (first pair) (second pair)) (zip [1,2,3] [4,5,6]))) 315
alphaEq (let f = x -> x * 3 in (map f (filter (x -> x > 2) (range 7))) |> (foldl plus 0)) 54

# Maybe monad tests using stdlib encoding (pair-based)
bind = λm f. if (isNothing m) nothing (f (fromJust m))
alphaEq (bind (just 3) (λx. just (x + 1))) (just 4)
alphaEq (bind nothing (λx. just (x + 1))) nothing

# Lambda placeholder examples
alphaEq ((\_ . 42) 123) 42
alphaEq ((\_ _ . 99) 1 2) 99
alphaEq ((\x _ . x) 7 8) 7
alphaEq ((\_ y . y) 5 6) 6
alphaEq ((_ , _ -> 0) 10 20) 0
alphaEq ((x, _ -> x) 42 99) 42
alphaEq (let f = \_ . 123 in f 456) 123
alphaEq (let g = \_ _ . 1 in g 2 3) 1
alphaEq (let h = \_ y . y in h 0 9) 9

# --- def function definition sugar ---
def inc2 x = x + 1
def add2 x y = x + y
def const42 = 42
alphaEq (inc2 5) 6
alphaEq (add2 3 4) 7
alphaEq const42 42
alphaEq (let z = 10 in add2 (inc2 z) const42) 53

# Macro System Tests
:macro (letbind $var $val $expr) => ((λ$var.$expr) $val)
alphaEq ((letbind x 42 (plus x 10))) 52
alphaEq ((letbind y 5 (mult y y))) 25
alphaEq ((letbind z 3 (exp 2 z))) 8
:macro (dup $x) => (plus $x $x)  # renamed from (double $x)
alphaEq ((dup 7)) 14
alphaEq ((dup (succ 4))) 10
:macro (triple $x) => (plus $x (plus $x $x))
alphaEq ((triple 8)) 24
:macro (when $cond $expr) => (if $cond $expr I)
alphaEq ((when true (succ 10))) 11
alphaEq ((when false (succ 10))) I
:macro (unless $cond $expr) => (if $cond I $expr)
alphaEq ((unless false (succ 20))) 21
alphaEq ((unless true (succ 20))) I
for x at [1..10] do (succ x)  # retains list output
for x at [1..10] do (square x)
for x at [1..10] do (div x 2)
for x at [1..10] do (mod x 2)
alphaEq (iff false then 42 else 9) 9
alphaEq (iff true then 42 else 9) 42
:macro (swappair $p) => (pair (second $p) (first $p))
alphaEq ((swappair (pair 1 2))) (pair 2 1)
:macro (list3 $a $b $c) => (cons $a (cons $b (cons $c nil)))
alphaEq ((list3 1 2 3)) [1,2,3]
:macro (square $x) => (mult $x $x)
alphaEq ((square 6)) 36
alphaEq ((square (plus 3 2))) 25
:macro (cube $x) => (mult $x (mult $x $x))
alphaEq ((cube 3)) 27
:macro (between $x $low $high) => (and (geq $x $low) (leq $x $high))
alphaEq ((between 5 3 7)) true
alphaEq ((between 2 3 7)) false
alphaEq ((between 8 3 7)) false
:macro (inc $x) => (succ $x)
:macro (dec $x) => (pred $x)
alphaEq ((inc 10)) 11
alphaEq ((dec 10)) 9
alphaEq ((inc (square 4))) 17
alphaEq ((square (inc 4))) 25
:macro (quadratic $a $b $c $x) => (plus (mult $a (square $x)) (plus (mult $b $x) $c))
alphaEq ((quadratic 2 3 1 4)) 45
:macro (fact2 $n) => (if (iszero $n) 1 (mult $n (fact2 (pred $n))))  # not structurally testable (recursive macro) left as definition

# Additional macro capability tests already at end of original file (kept as-is or identity comparisons)

# ============================================================================
# Extended Coverage: Advanced Macro / Variadic / Guards / Ordering / Lazy / Church Lists
# ============================================================================

# --- Advanced Macro System (Arity & Ordering) ---
:macro (arityDemo) => 0
:macro (arityDemo $a) => 1
:macro (arityDemo $a $b) => 2
alphaEq (arityDemo) 0
alphaEq (arityDemo 42) 1
alphaEq (arityDemo 7 8) 2

# --- Variadic Macros ---
:macro (listify $xs...) => $xs
alphaEq (listify) nil
alphaEq (listify 1) [1]
alphaEq (listify 1 2 3) [1,2,3]

# Variadic with fixed prefix
:macro (sumall $x $rest...) => (foldl plus $x $rest)
alphaEq (sumall 5) 5
alphaEq (sumall 1 2 3 4) 10

# --- Guarded Macros & Recency ---
:macro (choose $x) when false => 0
:macro (choose $x) => $x
alphaEq (choose 9) 9

:macro (choose2 $x) => $x
:macro (choose2 $x) when true => 42
alphaEq (choose2 7) 42

# Guard depending on variable (literal false only fails)
:macro (guardVar $flag $x) => 0
:macro (guardVar $flag $x) when $flag => $x
alphaEq (guardVar true 7) 7
alphaEq (guardVar false 7) 0

# Higher arity precedence
:macro (pref $x $y) => (mult $x $y)
:macro (pref $x) => (succ $x)
alphaEq (pref 3 4) 12
alphaEq (pref 5) 6

# Recency (shadowing)
:macro (shadow $x) => (plus $x 1)
:macro (shadow $x) => (plus $x 2)
alphaEq (shadow 3) 5

# Exact match vs rest capture precedence
:macro (mix $a $b) => (plus $a $b)
:macro (mix $a $rest...) => (foldl plus $a $rest)
alphaEq (mix 2 3) 5
alphaEq (mix 2 3 4 5) 14

# --- Pair Equality Helper (uses stdlib pairEq) ---
alphaEq (pairEq eq eq (pair 1 2) (pair 1 2)) true

# --- Church List Round Trip ---
# Build a Church-encoded list and fold it with cons/nil to a concrete list
alphaEq (((λf.λz.f 1 (f 2 (f 3 z))) (λh.λt.cons h t)) nil) [1,2,3]

# --- Lazy Evaluation (ensure unused branch not evaluated) ---
# Ω (diverges if forced) = (λx.x x) (λx.x x); use built inline
alphaEq (if true 1 ((λx.x x) (λx.x x))) 1

# --- Variadic / Utility Macro Extensions ---
:macro (duplicate $x) => (pair $x $x)
alphaEq (duplicate 7) (pair 7 7)

# Complex nested macro example for process style (inc (square (dec x)))
:macro (dec2 $x) => (pred $x)
:macro (process2 $x) => (inc (square (dec2 $x)))
alphaEq (process2 5) 17

# Macro composition ordering (outer/inner)
:macro (outer $x) => (inner (plus $x 1))
:macro (inner $y) => (mult $y 2)
alphaEq (outer 4) 10

# Apply twice (higher-order macro)
:macro (apply_twice $f $x) => ($f ($f $x))
alphaEq (apply_twice succ 0) 2
alphaEq (apply_twice (λx.mult x 2) 3) 12

# Composition macro reuse with new 'dup' macro already defined earlier
:macro (compose2b $f $g $x) => ($f ($g $x))
alphaEq (compose2b succ dup 5) 11

# Final complex macro calculation (mirrors complex_calc)
:macro (complex_calc $a $b $c) => (letbind x (plus $a $b) (letbind y (mult x $c) (square y)))
alphaEq (complex_calc 2 3 4) 400

# Note: Eta-equivalence not tested (λx.f x vs f) – current equality is alpha only.

# ============================================================================
# Essential Additional Core Law Tests
# ============================================================================

# Alpha-equivalence (binder renaming) & capture avoidance
alphaEq (λx.λy.x) (λa.λb.a)
alphaEq ((λx.λy.x) 1) (λz.1)
alphaEq (λx.λx.λx.x) (λa.λb.λc.c)  # inner shadowing
alphaEq ((λx.λx.λx.x) 1 2 3) ((λa.λb.λc.c) 1 2 3) # inner shadowing with application

# Combinator Laws
alphaEq ((S K K) 5) 5
alphaEq ((S K I) 7) 7

# Arithmetic Identity Laws
alphaEq (plus 7 0) 7
alphaEq (plus 0 9) 9
alphaEq (mult 9 1) 9
alphaEq (mult 9 0) 0
alphaEq (minus 5 0) 5

# List Functor Identity
alphaEq (map I [1,2,3]) [1,2,3]

# Lazy Evaluation (false branch)
alphaEq (if false ((λx.x x) (λx.x x)) 2) 2

# Nested Pair Equality using pairEq
# alphaEq (pairEq eq eq (pair (pair 1 2) (pair 3 4)) (pair (pair 1 2) (pair 3 4))) true

# ============================================================================
# Additional Positive Law / Property Tests (no negatives)
# ============================================================================

# Maybe Functor Laws
alphaEq (maybeMap I (just 5)) (just 5)                     # identity
alphaEq (maybeMap (λx.mult x x) (maybeMap succ (just 3))) (just 16)   # composition exemplar

# Either usage (Right-biased behavior already covered)
alphaEq (either succ succ (left 5)) 6
alphaEq (either succ succ (right 5)) 6

# Append associativity
alphaEq (append (append [1] [2]) [3]) (append [1] (append [2] [3]))

# Reverse distributes over append: reverse (xs ++ ys) = reverse ys ++ reverse xs
alphaEq (reverse (append [1,2] [3,4,5])) (append (reverse [3,4,5]) (reverse [1,2]))

# Map length invariant
alphaEq (length (map succ [1,2,3,4])) (length [1,2,3,4])

# Sum via fold equivalence
alphaEq (sum [1,2,3,4]) (foldl plus 0 [1,2,3,4])

# Maybe bind laws (using bind defined above)
alphaEq (bind (just 5) (λx.just (plus x 1))) (just 6)      # left identity exemplar
alphaEq (bind (just 7) just) (just 7)                     # right identity exemplar

# Tree: size equals length of inorder traversal
alphaEq (treeSize (node 1 (leaf 2) (leaf 3))) (length (inOrder (node 1 (leaf 2) (leaf 3))))

# test multiple commands in a single line
plus 1 3; mult 2 4; minus 5 1; fib 10
plus 4 3; :macro (aa $a) => (plus $a $a); aa 4
plus 4 3; :macro (bb $a) => (plus $a $a); bb 4; :macro (cc $b) => (mult $b $b); cc 5 # define and call macros


# test different ways to define and use fibonacci
alphaEq (let rec fib2 = n -> if (n <= 2) 1 ((n - 1 |> fib2) + (n - 2 |> fib2)) in fib2 10) 55
alphaEq (let rec fib3 = n -> if (n <= 2) 1 (fib3(n - 1) + fib3(n - 2)) in fib3 10) 55
fib4 = n -> if (n <= 2) 1 ((n - 1 |> fib4) + (n - 2 |> fib4))
fib5 = n -> if (n <= 2) 1 (fib5(n - 1) + fib5(n - 2))
alphaEq (fib4 10) 55
alphaEq (fib5 10) 55
fib6 = Y (\f.\n. if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n)))))
alphaEq (fib6 10) 55
fib7 = Y (\f. \n. if (n <= 2) 1 ((f (n - 1)) + (f (n - 2))))
alphaEq (fib7 10) 55

# ============================================================================
# Added Extended Coverage (new)
# Focus: WHILE combinator, gcd1, ackermann small cases, State monad sequencing,
# structural equality helper families, safe* functions, ASCII predicates,
# unzip, listEq/maybeEq/eitherEq negative cases, tolower/toupper, list unzip.
# ============================================================================

# WHILE loop basic countdown (should reach 0)
alphaEq (WHILE (λn.gt n 0) pred 5) 0

# gcd1 (WHILE-based) correctness vs known value
alphaEq (gcd1 48 18) 6

# Ackermann small direct values (pattern observed: ackermann 2 n = 2n + 3)
alphaEq (ackermann 2 2) 7
alphaEq (ackermann 2 3) 9

# State monad: putState and bindState sequencing
alphaEq (runState (putState 99) 42) (pair nil 99)

# Construct a composite state computation: double state, then increment value & state
doubleThenInc = bindState (λs.pair (mult s 2) (mult s 2)) (λres. λs.pair (succ res) (succ s))
alphaEq (runState doubleThenInc 3) (pair 7 7)

# Structural equality helpers (listEq / maybeEq / eitherEq)
alphaEq (listEq eq [1,2,3] [1,2,3]) true
alphaEq (listEq eq [1,2,3] [1,2]) false
alphaEq (maybeEq eq (just 5) (just 5)) true
alphaEq (maybeEq eq (just 5) nothing) false
alphaEq (eitherEq eq eq (left 3) (left 3)) true
alphaEq (eitherEq eq eq (left 3) (right 3)) false

# Safe head/tail/nth/div operations
alphaEq (safehead [1,2,3]) (just 1)
alphaEq (safehead nil) nothing
alphaEq (safetail [1,2,3]) (just [2,3])
alphaEq (safetail nil) nothing
alphaEq (safenth 1 [10,20,30]) (just 20)
alphaEq (safenth 5 [10]) nothing
alphaEq (safeDiv 12 3) (just 4)
alphaEq (safeDiv 12 0) nothing

# ASCII predicates and case conversion
alphaEq (isdigit 48) true
alphaEq (isdigit 65) false
alphaEq (isalpha 65) true
alphaEq (isalpha 48) false
alphaEq (isspace 32) true
alphaEq (isspace 65) false
alphaEq (toupper 97) 65
alphaEq (toupper 33) 33
alphaEq (tolower 65) 97
alphaEq (tolower 48) 48

# unzip (zip round trip)
alphaEq (unzip (zip [1,2] [3,4])) (pair [1,2] [3,4])

# listEq nested usage example (list of lists)
alphaEq (listEq (listEq eq) [[1,2],[3]] [[1,2],[3]]) true
alphaEq (listEq (listEq eq) [[1,2],[3]] [[1,2],[4]]) false

# Additional numeric predicate & helper coverage
alphaEq (isone 1) true
alphaEq (isone 2) false
alphaEq (istwo 2) true
alphaEq (istwo 3) false
alphaEq (ispositive 0) false
alphaEq (ispositive 3) true
alphaEq (triple 4) 12
alphaEq (quadruple 3) 12

# GCD / LCM edge cases with zero
alphaEq (gcd 0 7) 7
alphaEq (gcd 9 0) 9
alphaEq (gcd1 0 7) 7
alphaEq (lcm 0 5) 0
alphaEq (lcm 6 0) 0

# Structural equality negative variants
alphaEq (listEq eq [1,2] [2,1]) false
alphaEq (pairEq eq eq (pair 1 2) (pair 1 3)) false
alphaEq (maybeEq eq (just 5) (just 6)) false
alphaEq (eitherEq eq eq (right 2) (right 3)) false

# Benchmark & lazy helpers
alphaEq (benchmark 5 succ 1) 2
alphaEq (force (delay 42)) 42

# ASCII classification extended
alphaEq (isupper 65) true
alphaEq (isupper 97) false
alphaEq (islower 97) true
alphaEq (islower 65) false
alphaEq (isalnum 65) true
alphaEq (isalnum 33) false
alphaEq (toupper 65) 65
alphaEq (tolower 97) 97

# State monad laws (left/right identity exemplars)
alphaEq (runState (bindState (returnState 5) (λx.returnState (succ x))) 0) (pair 6 0)
alphaEq (runState (bindState (returnState 5) returnState) 0) (pair 5 0)
mState = λs.pair 1 (succ s)
alphaEq (runState (bindState mState returnState) 0) (runState mState 0)

# --- Additional Macro & Helper Coverage (supplemental) ---
alphaEq (nand true true) false
alphaEq (nand true false) true
alphaEq (nor false false) true
alphaEq (nor true false) false
alphaEq (apply_n succ 3 4) 7
alphaEq (min2 3 5) 3
alphaEq (max2 3 5) 5
alphaEq (empty? nil) true
alphaEq (empty? [1]) false
alphaEq (rest [1,2,3]) [2,3]

# Structural test macros wrappers
alphaEq (testList [1,2] [1,2]) true
alphaEq (testPair (pair 1 2) (pair 1 2)) true
alphaEq (testMaybe (just 9) (just 9)) true
alphaEq (testEither (right 4) (right 4)) true

# Negative with wrappers
alphaEq (testList [1,2] [2,1]) false
alphaEq (testPair (pair 1 2) (pair 2 1)) false
alphaEq (testMaybe (just 9) (just 8)) false
alphaEq (testEither (left 4) (right 4)) false

# WHILE with immediately false condition returns initial state
alphaEq (WHILE (λn.lt n 0) succ 5) 5

# safeInit vs safeInitMaybe distinction
alphaEq (safeInit [1,2]) [1]
alphaEq (safeInitMaybe [1,2]) (just [1])

# Single-element safe min/max
alphaEq (safeMinimum [7]) (just 7)
alphaEq (safeMaximum [7]) (just 7)

# Nested pair equality positive
alphaEq (pairEq (pairEq eq eq) (pairEq eq eq) (pair (pair 1 2) (pair 3 4)) (pair (pair 1 2) (pair 3 4))) true

# isspace tab/newline
alphaEq (isspace 9) true
alphaEq (isspace 10) true

