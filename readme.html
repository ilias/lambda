<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lambda Calculus Interpreter</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
  <style type="text/css">:root { --bg:#0d1117; --panel:#161b22; --border:#30363d; --fg:#c9d1d9; --fg-soft:#a5b1bd; --accent:#58a6ff; --radius:8px; }html { scroll-behavior:smooth; }body { font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; margin:0 auto; max-width:980px; padding:2.2rem 1.6rem 4rem; line-height:1.55; background:var(--bg); color:var(--fg); }h1,h2,h3,h4,h5 { line-height:1.15; font-weight:600; }h1 { font-size:2.25rem; margin-top:0; }h2 { margin-top:2.4rem; padding-top:.4rem; border-top:1px solid var(--border); font-size:1.6rem; }h3 { margin-top:1.8rem; font-size:1.25rem; }p { margin:1rem 0; }pre,code { font-family: ui-monospace,Consolas,"Cascadia Code",monospace; font-size:.85rem; }pre { background:var(--panel); padding:1rem 1.1rem; border:1px solid var(--border); border-radius:var(--radius); overflow:auto; position:relative; }code { background:var(--panel); padding:.15rem .4rem; border:1px solid var(--border); border-radius:5px; }pre code { background:transparent; padding:0; border:none; }table { border-collapse:collapse; width:100%; margin:1.25rem 0; }th,td { border:1px solid var(--border); padding:.55rem .7rem; text-align:left; vertical-align:top; }tr:nth-child(even) { background:#1b2230; }a { color:var(--accent); text-decoration:none; }a:hover { text-decoration:underline; }blockquote { margin:1.2rem 0; padding:.75rem 1rem; background:#132032; border-left:4px solid var(--accent); border-radius:4px; color:var(--fg-soft); }hr { border:none; border-top:1px solid var(--border); margin:3rem 0 2.2rem; }nav#toc { background:var(--panel); border:1px solid var(--border); padding:1rem 1.25rem 1.1rem; border-radius:var(--radius); font-size:.85rem; line-height:1.35; }nav#toc strong { display:block; font-size:.75rem; letter-spacing:.08em; font-weight:700; text-transform:uppercase; margin-bottom:.35rem; opacity:.85; }nav#toc ul { list-style:none; margin:0; padding-left:0; }nav#toc ul ul { margin-left:1rem; }nav#toc a { text-decoration:none; }nav#toc a:hover { text-decoration:underline; }.title-block { margin-bottom:1.5rem; }.title-block h1 { margin-bottom:.25rem; }.meta { color:var(--fg-soft); font-size:.85rem; }.footnotes { font-size:.85rem; opacity:.92; }.highlight table { border:none; }.highlight td { border:none; padding:0; }.highlight pre { margin:0; }@media (max-width:760px){ body{padding:1.4rem .95rem 3rem;} h1{font-size:1.9rem;} }</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lambda Calculus Interpreter</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#lambda-calculus-interpreter" id="toc-lambda-calculus-interpreter">Lambda Calculus Interpreter</a>
<ul>
<li><a href="#table-of-contents-reorganized" id="toc-table-of-contents-reorganized">Table of Contents
(Reorganized)</a></li>
<li><a href="#features" id="toc-features">Features</a>
<ul>
<li><a href="#core-language-features" id="toc-core-language-features">Core Language Features</a></li>
<li><a href="#advanced-features" id="toc-advanced-features">Advanced
Features</a></li>
<li><a href="#performance-optimizations" id="toc-performance-optimizations">Performance Optimizations</a></li>
<li><a href="#recent-ui--tooling-updates-2025-08" id="toc-recent-ui--tooling-updates-2025-08">Recent UI / Tooling Updates
(2025-08)</a></li>
</ul></li>
<li><a href="#quick-start" id="toc-quick-start">Quick Start</a></li>
<li><a href="#getting-started" id="toc-getting-started">Getting
Started</a>
<ul>
<li><a href="#project-layout-library--cli--web" id="toc-project-layout-library--cli--web">Project Layout (Library + CLI
+ Web)</a></li>
<li><a href="#build-everything" id="toc-build-everything">Build
Everything</a></li>
<li><a href="#run-cli-repl" id="toc-run-cli-repl">Run CLI
(REPL)</a></li>
<li><a href="#run-web-api" id="toc-run-web-api">Run Web API</a></li>
<li><a href="#use-as-a-library" id="toc-use-as-a-library">Use as a
Library</a></li>
<li><a href="#notes" id="toc-notes">Notes</a></li>
<li><a href="#run-web-ui" id="toc-run-web-ui">Run Web UI</a></li>
</ul></li>
<li><a href="#web-ui--streaming-logs" id="toc-web-ui--streaming-logs">Web UI &amp; Streaming Logs</a>
<ul>
<li><a href="#transports" id="toc-transports">Transports</a></li>
<li><a href="#progress-feedback" id="toc-progress-feedback">Progress
Feedback</a></li>
<li><a href="#colored-log-classification" id="toc-colored-log-classification">Colored Log Classification</a></li>
<li><a href="#log-retention" id="toc-log-retention">Log
Retention</a></li>
<li><a href="#typical-workflow" id="toc-typical-workflow">Typical
Workflow</a></li>
<li><a href="#api-summary-web-ui-namespace" id="toc-api-summary-web-ui-namespace">API Summary (Web UI
Namespace)</a></li>
<li><a href="#disabling-streaming--fallback" id="toc-disabling-streaming--fallback">Disabling Streaming /
Fallback</a></li>
<li><a href="#extensibility" id="toc-extensibility">Extensibility</a></li>
<li><a href="#streaming-modes-comparison" id="toc-streaming-modes-comparison">Streaming Modes
(Comparison)</a></li>
</ul></li>
<li><a href="#docker-web-ui" id="toc-docker-web-ui">Docker (Web UI)</a>
<ul>
<li><a href="#build-image" id="toc-build-image">Build Image</a></li>
<li><a href="#run-container" id="toc-run-container">Run
Container</a></li>
<li><a href="#bind-mount-files" id="toc-bind-mount-files">Bind Mount
Files</a></li>
<li><a href="#change-port" id="toc-change-port">Change Port</a></li>
<li><a href="#multi-arch-build-optional" id="toc-multi-arch-build-optional">Multi-Arch Build (Optional)</a></li>
<li><a href="#updating-for-net-9" id="toc-updating-for-net-9">Updating
for .NET 9</a></li>
<li><a href="#security-notes" id="toc-security-notes">Security
Notes</a></li>
</ul></li>
<li><a href="#user-defined-native-primitives" id="toc-user-defined-native-primitives">User-Defined Native
Primitives</a>
<ul>
<li><a href="#registering-a-native-primitive-c-example" id="toc-registering-a-native-primitive-c-example">Registering a Native
Primitive (C# Example)</a></li>
<li><a href="#running-the-interpreter" id="toc-running-the-interpreter">Running the Interpreter</a></li>
<li><a href="#basic-syntax" id="toc-basic-syntax">Basic Syntax</a></li>
<li><a href="#advanced-syntax-features" id="toc-advanced-syntax-features">Advanced Syntax Features</a></li>
</ul></li>
<li><a href="#interactive-commands" id="toc-interactive-commands">Interactive Commands</a>
<ul>
<li><a href="#environment-management" id="toc-environment-management">Environment Management</a></li>
<li><a href="#evaluation-control" id="toc-evaluation-control">Evaluation
Control</a></li>
<li><a href="#debugging-and-performance" id="toc-debugging-and-performance">Debugging and Performance</a></li>
<li><a href="#language-extensions" id="toc-language-extensions">Language
Extensions</a></li>
<li><a href="#help-and-information" id="toc-help-and-information">Help
and Information</a></li>
<li><a href="#command-effects--desugarings-summary" id="toc-command-effects--desugarings-summary">Command Effects /
Desugarings (Summary)</a></li>
</ul></li>
<li><a href="#command--expression-chaining" id="toc-command--expression-chaining">Command / Expression Chaining</a>
<ul>
<li><a href="#examples" id="toc-examples">Examples</a></li>
<li><a href="#rules" id="toc-rules">Rules</a></li>
<li><a href="#practical-uses" id="toc-practical-uses">Practical
Uses</a></li>
</ul></li>
<li><a href="#core-language" id="toc-core-language">Core Language</a>
<ul>
<li><a href="#lambda-abstractions" id="toc-lambda-abstractions">Lambda
Abstractions</a></li>
</ul></li>
<li><a href="#formal-grammar" id="toc-formal-grammar">Formal Grammar</a>
<ul>
<li><a href="#parser-errors--diagnostics" id="toc-parser-errors--diagnostics">Parser Errors &amp;
Diagnostics</a></li>
<li><a href="#unary-minus--negative-literals" id="toc-unary-minus--negative-literals">Unary Minus / Negative
Literals</a></li>
<li><a href="#church-numerals" id="toc-church-numerals">Church
Numerals</a></li>
<li><a href="#lists" id="toc-lists">Lists</a></li>
</ul></li>
<li><a href="#standard-library" id="toc-standard-library">Standard
Library</a>
<ul>
<li><a href="#1-core-combinators" id="toc-1-core-combinators">1. Core
Combinators</a></li>
<li><a href="#2-boolean-logic" id="toc-2-boolean-logic">2. Boolean
Logic</a></li>
<li><a href="#3-arithmetic-operations" id="toc-3-arithmetic-operations">3. Arithmetic Operations</a></li>
<li><a href="#4-list-operations" id="toc-4-list-operations">4. List
Operations</a></li>
<li><a href="#5-data-structures" id="toc-5-data-structures">5. Data
Structures</a></li>
</ul></li>
<li><a href="#infix-operators" id="toc-infix-operators">Infix
Operators</a></li>
<li><a href="#operator-precedence--associativity" id="toc-operator-precedence--associativity">Operator Precedence &amp;
Associativity</a>
<ul>
<li><a href="#built-in-special-operators" id="toc-built-in-special-operators">Built-in Special Operators</a></li>
</ul></li>
<li><a href="#macro-system" id="toc-macro-system">Macro System</a>
<ul>
<li><a href="#macro-system-enhancements-recent" id="toc-macro-system-enhancements-recent">Macro System Enhancements
(Recent)</a></li>
<li><a href="#planned--future-improvements" id="toc-planned--future-improvements">Planned / Future
Improvements</a></li>
<li><a href="#performance-metrics-reference" id="toc-performance-metrics-reference">Performance Metrics
Reference</a></li>
</ul></li>
<li><a href="#repl-command-reference" id="toc-repl-command-reference">REPL Command Reference</a></li>
<li><a href="#examples-extended" id="toc-examples-extended">Examples
(Extended)</a>
<ul>
<li><a href="#fibonacci-sequence" id="toc-fibonacci-sequence">Fibonacci
Sequence</a></li>
<li><a href="#prime-numbers" id="toc-prime-numbers">Prime
Numbers</a></li>
<li><a href="#list-processing" id="toc-list-processing">List
Processing</a></li>
<li><a href="#church-encoding-examples" id="toc-church-encoding-examples">Church Encoding Examples</a></li>
<li><a href="#higher-order-functions" id="toc-higher-order-functions">Higher-Order Functions</a></li>
</ul></li>
<li><a href="#advanced-usage" id="toc-advanced-usage">Advanced Usage</a>
<ul>
<li><a href="#complex-function-composition-and-pipelines" id="toc-complex-function-composition-and-pipelines">Complex Function
Composition and Pipelines</a></li>
<li><a href="#advanced-macro-patterns" id="toc-advanced-macro-patterns">Advanced Macro Patterns</a></li>
<li><a href="#integration-patterns" id="toc-integration-patterns">Integration Patterns</a></li>
</ul></li>
<li><a href="#performance-features" id="toc-performance-features">Performance Features</a>
<ul>
<li><a href="#lazy-vs-eager-evaluation-and-macros" id="toc-lazy-vs-eager-evaluation-and-macros">Lazy vs Eager Evaluation
and Macros</a></li>
<li><a href="#native-arithmetic" id="toc-native-arithmetic">Native
Arithmetic</a></li>
</ul></li>
<li><a href="#native-list-primitives" id="toc-native-list-primitives">Native List Primitives</a>
<ul>
<li><a href="#structural-equality-helper-families" id="toc-structural-equality-helper-families">Structural Equality Helper
Families</a></li>
<li><a href="#caching-and-memoization" id="toc-caching-and-memoization">Caching and Memoization</a></li>
<li><a href="#statistics-and-monitoring" id="toc-statistics-and-monitoring">Statistics and Monitoring</a></li>
</ul></li>
<li><a href="#step-tracing--debugging" id="toc-step-tracing--debugging">Step Tracing &amp; Debugging</a></li>
<li><a href="#performance-cookbook" id="toc-performance-cookbook">Performance Cookbook</a></li>
<li><a href="#embedding--programmatic-api" id="toc-embedding--programmatic-api">Embedding &amp; Programmatic
API</a></li>
<li><a href="#multi-user--deployment-strategies" id="toc-multi-user--deployment-strategies">Multi-user &amp; Deployment
Strategies</a></li>
<li><a href="#building-and-running" id="toc-building-and-running">Building and Running</a>
<ul>
<li><a href="#documentation-generation-pandoc" id="toc-documentation-generation-pandoc">Documentation Generation
(Pandoc)</a></li>
<li><a href="#prerequisites-build--run" id="toc-prerequisites-build--run">Prerequisites (Build &amp;
Run)</a></li>
<li><a href="#building" id="toc-building">Building</a></li>
<li><a href="#running" id="toc-running">Running</a></li>
</ul></li>
<li><a href="#file-format" id="toc-file-format">File Format</a></li>
<li><a href="#pretty-printing" id="toc-pretty-printing">Pretty
Printing</a>
<ul>
<li><a href="#what-it-formats" id="toc-what-it-formats">What It
Formats</a></li>
<li><a href="#booleans-vs-conditionals" id="toc-booleans-vs-conditionals">Booleans vs Conditionals</a></li>
<li><a href="#truncation" id="toc-truncation">Truncation</a></li>
<li><a href="#toggling" id="toc-toggling">Toggling</a></li>
<li><a href="#pretty-printing-examples" id="toc-pretty-printing-examples">Pretty Printing Examples</a></li>
<li><a href="#limitations--notes" id="toc-limitations--notes">Limitations / Notes</a></li>
<li><a href="#when-to-turn-it-off" id="toc-when-to-turn-it-off">When to
Turn It Off</a></li>
</ul></li>
<li><a href="#project-overview" id="toc-project-overview">Project
Overview</a></li>
<li><a href="#how-it-works" id="toc-how-it-works">How It Works</a></li>
<li><a href="#contributing" id="toc-contributing">Contributing</a></li>
<li><a href="#troubleshooting--faq" id="toc-troubleshooting--faq">Troubleshooting &amp; FAQ</a></li>
<li><a href="#design-decisions" id="toc-design-decisions">Design
Decisions</a></li>
<li><a href="#license" id="toc-license">License</a></li>
<li><a href="#distribution--packaging-new" id="toc-distribution--packaging-new">Distribution &amp; Packaging
(New)</a>
<ul>
<li><a href="#roadmap" id="toc-roadmap">Roadmap</a></li>
</ul></li>
<li><a href="#build--run-guide" id="toc-build--run-guide">Build &amp;
Run Guide</a>
<ul>
<li><a href="#prerequisites" id="toc-prerequisites">Prerequisites</a></li>
<li><a href="#1-core-library-nuget-package" id="toc-1-core-library-nuget-package">1. Core Library (NuGet
Package)</a></li>
<li><a href="#2-cli-repl-src-cli" id="toc-2-cli-repl-src-cli">2. CLI
REPL (<code>src-cli</code>)</a></li>
<li><a href="#3-web-api-src-web" id="toc-3-web-api-src-web">3. Web API
(<code>src-web</code>)</a></li>
<li><a href="#4-web-ui-src-webui" id="toc-4-web-ui-src-webui">4. Web UI
(<code>src-webui</code>)</a></li>
<li><a href="#5-unified-build-script-buildps1" id="toc-5-unified-build-script-buildps1">5. Unified Build Script
(<code>build.ps1</code>)</a></li>
<li><a href="#7-running-testslambda" id="toc-7-running-testslambda">7.
Running <code>tests.lambda</code></a></li>
<li><a href="#8-troubleshooting" id="toc-8-troubleshooting">8.
Troubleshooting</a></li>
<li><a href="#9-quick-command-reference" id="toc-9-quick-command-reference">9. Quick Command Reference</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<section id="lambda-calculus-interpreter" class="level1">
<h1>Lambda Calculus Interpreter</h1>
<p>A high-performance lambda calculus interpreter written in C#
featuring lazy evaluation, comprehensive standard library, infix
operators, macros, and native arithmetic optimizations.</p>
<section id="table-of-contents-reorganized" class="level2">
<h2>Table of Contents (Reorganized)</h2>
<p>Quick Start &amp; Overview</p>
<ul>
<li><a href="#features">Features</a></li>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#getting-started">Project Layout</a></li>
</ul>
<p>Language &amp; Syntax</p>
<ul>
<li><a href="#core-language">Core Language</a></li>
<li><a href="#advanced-syntax-features">Advanced Syntax
Features</a></li>
<li><a href="#command--expression-chaining">Command / Expression
Chaining</a></li>
<li><a href="#infix-operators">Infix Operators</a></li>
<li><a href="#operator-precedence--associativity">Operator Precedence
&amp; Associativity</a></li>
<li><a href="#macro-system">Macro System</a></li>
<li><a href="#range-syntax-extensions">Range Syntax Extensions</a></li>
<li><a href="#formal-grammar">Formal Grammar</a></li>
</ul>
<p>Runtime &amp; Tooling</p>
<ul>
<li><a href="#interactive-commands">Interactive Commands</a></li>
<li><a href="#standard-library">Standard Library</a></li>
<li><a href="#pretty-printing">Pretty Printing</a></li>
<li><a href="#parser-errors--diagnostics">Parser Errors &amp;
Diagnostics</a></li>
<li><a href="#step-tracing--debugging">Step Tracing &amp;
Debugging</a></li>
</ul>
<p>Performance &amp; Internals</p>
<ul>
<li><a href="#performance-features">Performance Features</a></li>
<li><a href="#native-list-primitives">Native List Primitives</a></li>
<li><a href="#structural-equivalence">Structural Equivalence</a></li>
<li><a href="#performance-cookbook">Performance Cookbook</a></li>
</ul>
<p>Usage Patterns</p>
<ul>
<li><a href="#examples-extended">Examples (Extended)</a></li>
<li><a href="#advanced-usage">Advanced Usage</a></li>
<li><a href="#embedding--programmatic-api">Embedding &amp; Programmatic
API</a></li>
<li><a href="#multi-user--deployment-strategies">Multi-user &amp;
Deployment Strategies</a></li>
</ul>
<p>Build, Deploy &amp; Distribution</p>
<ul>
<li><a href="#building-and-running">Building and Running</a>
<ul>
<li><a href="#documentation-generation-pandoc">Documentation Generation
(Pandoc)</a></li>
<li><a href="#web-ui--streaming-logs">Web UI &amp; Streaming
Logs</a></li>
<li><a href="#docker-web-ui">Docker (Web UI)</a></li>
<li><a href="#streaming-modes-comparison">Streaming Modes
(Comparison)</a></li>
</ul></li>
</ul>
<p>Appendices</p>
<ul>
<li><a href="#unary-minus--negative-literals">Unary Minus / Negative
Literals</a></li>
<li><a href="#either-type-error-handling">Either Type (Error
Handling)</a></li>
</ul>
<p>Meta</p>
<ul>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#troubleshooting--faq">Troubleshooting &amp; FAQ</a></li>
<li><a href="#design-decisions">Design Decisions</a></li>
<li><a href="#license">License</a></li>
</ul>
<blockquote>
<p>The README is intentionally comprehensive. Consider splitting into
smaller docs if publishing to NuGet with a shorter front-page
overview.</p>
</blockquote>
</section>
<section id="features" class="level2">
<h2>Features</h2>
<section id="core-language-features" class="level3">
<h3>Core Language Features</h3>
<ul>
<li><strong>Pure Lambda Calculus</strong>: Supports variables, lambda
abstractions, and function application</li>
<li><strong>Church Numerals</strong>: Built-in support for integers
using Church encoding</li>
<li><strong>Lazy Evaluation</strong>: Efficient lazy evaluation with
thunk caching (can be toggled to eager)</li>
<li><strong>Y Combinator</strong>: Built-in support for recursion via
the Y combinator</li>
<li><strong>Multi-line Input</strong>: Intelligent multi-line expression
support with auto-completion detection</li>
<li><strong>Top-level Sequencing</strong>: Semicolon (<code>;</code>)
support to evaluate multiple expressions sequentially at the REPL or in
files</li>
</ul>
</section>
<section id="advanced-features" class="level3">
<h3>Advanced Features</h3>
<ul>
<li><strong>Infix Operators</strong>: Define custom infix operators with
precedence and associativity</li>
<li><strong>Macro System</strong>: Powerful pattern-driven macro system
(multi-clause, guards, variadic/rest arguments, precedence &amp;
shadowing)</li>
<li><strong>Native Arithmetic &amp; User Primitives</strong>: Optional
native arithmetic optimizations for Church numerals, plus support for
user-defined native primitives (see below)</li>
<li><strong>Structural Equivalence Natives Always-On</strong>:
<code>alphaEq</code>, <code>betaEq</code>, <code>hashEq</code>,
<code>etaEq</code> remain available even when native arithmetic is
disabled via <code>:native off</code> (only numeric/boolean arithmetic
shortcuts are toggled)</li>
<li><strong>Pretty Printing</strong>: Automatic formatting of Church
numerals and lists</li>
<li><strong>Comprehensive Standard Library</strong>: ~200 predefined
functions and utilities (see sections below; count may evolve)</li>
<li><strong>General &amp; Stepped Ranges</strong>: Rich list range
syntax <code>[a .. b]</code>, <code>[a, b .. c]</code> with lazy dynamic
expansion (supports negative &amp; descending ranges)</li>
</ul>
</section>
<section id="performance-optimizations" class="level3">
<h3>Performance Optimizations</h3>
<ul>
<li><strong>Memoization</strong>: Multiple caching layers for
substitution, evaluation, and free variables</li>
<li><strong>Expression Interning</strong>: Memory-efficient expression
representation</li>
<li><strong>Stack-based Evaluation</strong>: CEK (Control, Environment,
Kontinuation) machine for efficient evaluation</li>
<li><strong>Thunk Forcing</strong>: Lazy evaluation with intelligent
thunk management</li>
</ul>
</section>
<section id="recent-ui--tooling-updates-2025-08" class="level3">
<h3>Recent UI / Tooling Updates (2025-08)</h3>
<p>Enhancements to the Web UI (<code>src-webui</code>):</p>
<ul>
<li>Multi-Output Tabs: Separate sessions, independent logs and
filters.</li>
<li>Log Filters: Toggle Macro, Test, Time, Step, Eval, Norm, Name,
Processing categories.</li>
<li>Enhanced Search: Floating navigator, keyboard shortcuts
(<code>/</code>, <code>F3</code>, <code>Shift+F3</code>, <code>n</code>,
<code>N</code>, <code>Esc</code>).</li>
<li>Normalized Output Handling: <code>Norm:</code> lines only when
distinct; blank spacer lines emitted only when normalization
appears.</li>
<li>Local File Loader: Client-side <code>.lambda</code> loading with
progress bar.</li>
<li>Streaming Transports: Buffered vs SSE vs WebSocket switchable at
runtime.</li>
<li>Cache Busting: Timestamped resource fetches + cache/service worker
clearing.</li>
<li>Persistent History: Up/Down arrow navigation with
<code>localStorage</code> retention.</li>
<li>Alpha Equivalence Logging: Consistent
<code>Alpha left/right/passed|failed</code> lines; visibility controlled
purely by filters.</li>
<li>Wrapped Output: Long lines wrap; horizontal scroll removed.</li>
</ul>
<p>Tip: Extend filtering or log classification via
<code>classify()</code> and <code>FILTER_CONFIG</code> in
<code>wwwroot/index.html</code>.</p>
</section>
</section>
<section id="quick-start" class="level2">
<h2>Quick Start</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dotnet build</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">--</span>project src-cli</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>succ <span class="dv">41</span>  <span class="co"># → 42</span></span></code></pre></div>
<p>Web UI</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">--</span>project src-webui</span></code></pre></div>
<p>Open <a href="http://localhost:5000">http://localhost:5000</a> then
evaluate <code>succ 41</code>.</p>
<p>Embed (C#):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> it <span class="op">=</span> <span class="kw">new</span> LambdaCalculus<span class="op">.</span><span class="fu">Interpreter</span><span class="op">(</span>logger<span class="op">:</span> <span class="kw">new</span> LambdaCalculus<span class="op">.</span><span class="fu">Logger</span><span class="op">());</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>await it<span class="op">.</span><span class="fu">LoadFileIfExistsAsync</span><span class="op">(</span><span class="st">&quot;stdlib.lambda&quot;</span><span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">var</span> <span class="op">(</span>_<span class="op">,</span> r<span class="op">)</span> <span class="op">=</span> await it<span class="op">.</span><span class="fu">ProcessInputAsync</span><span class="op">(</span><span class="st">&quot;succ 41&quot;</span><span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>Console<span class="op">.</span><span class="fu">WriteLine</span><span class="op">(</span>r<span class="op">);</span> <span class="co">// 42</span></span></code></pre></div>
<hr />
</section>
<section id="getting-started" class="level2">
<h2>Getting Started</h2>
<section id="project-layout-library--cli--web" class="level3">
<h3>Project Layout (Library + CLI + Web)</h3>
<p>The repository now consists of three projects:</p>
<table>
<thead>
<tr>
<th>Project</th>
<th>Type</th>
<th>Path</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lambda-cek</code></td>
<td>Class Library (multi-target <code>net8.0; net9.0</code>)</td>
<td><code>src/</code></td>
<td>Core interpreter engine (parsing, evaluation, macros, etc.)</td>
</tr>
<tr>
<td><code>lambda-cek.cli</code></td>
<td>Console App (<code>net8.0</code>)</td>
<td><code>src-cli/</code></td>
<td>Interactive REPL and file runner built on the library</td>
</tr>
<tr>
<td><code>lambda-cek.web</code></td>
<td>Minimal ASP.NET Core Web API (<code>net8.0</code>)</td>
<td><code>src-web/</code></td>
<td>Simple HTTP interface to evaluate expressions &amp; load files</td>
</tr>
<tr>
<td><code>lambda-cek.webui</code></td>
<td>ASP.NET Core static + API (<code>net8.0</code>)</td>
<td><code>src-webui/</code></td>
<td>Browser UI (HTML/JS) plus namespaced API (<code>/api/*</code>)</td>
</tr>
</tbody>
</table>
</section>
<section id="build-everything" class="level3">
<h3>Build Everything</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> build</span></code></pre></div>
</section>
<section id="run-cli-repl" class="level3">
<h3>Run CLI (REPL)</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> run <span class="at">--project</span> src-cli <span class="at">--</span> [optional .lambda files]</span></code></pre></div>
<p>Examples:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> run <span class="at">--project</span> src-cli</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> run <span class="at">--project</span> src-cli <span class="at">--</span> examples.lambda tests.lambda</span></code></pre></div>
</section>
<section id="run-web-api" class="level3">
<h3>Run Web API</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> run <span class="at">--project</span> src-web</span></code></pre></div>
<p>Default endpoints (no auth, for local/dev use):</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Route</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><code>/api/health</code></td>
<td>Liveness check (new)</td>
<td><code>curl http://localhost:5000/api/health</code></td>
</tr>
<tr>
<td>GET</td>
<td><code>/health</code></td>
<td>(Legacy) liveness check</td>
<td><code>curl http://localhost:5000/health</code></td>
</tr>
<tr>
<td>GET</td>
<td><code>/eval?expr=EXPR</code></td>
<td>Evaluate a single expression</td>
<td><code>curl &quot;http://localhost:5000/eval?expr=succ%2041&quot;</code></td>
</tr>
<tr>
<td>POST</td>
<td><code>/load</code> (JSON
<code>{ &quot;path&quot;: &quot;file.lambda&quot; }</code>)</td>
<td>Load a file into the global environment</td>
<td><code>curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;path&quot;:&quot;stdlib.lambda&quot;}&#39; http://localhost:5000/load</code></td>
</tr>
</tbody>
</table>
<p>Returns JSON like:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span> <span class="dt">&quot;input&quot;</span><span class="fu">:</span> <span class="st">&quot;succ 1&quot;</span><span class="fu">,</span> <span class="dt">&quot;output&quot;</span><span class="fu">:</span> <span class="st">&quot;2&quot;</span><span class="fu">,</span> <span class="dt">&quot;normalized&quot;</span><span class="fu">:</span> <span class="st">&quot;2&quot;</span> <span class="fu">}</span></span></code></pre></div>
</section>
<section id="use-as-a-library" class="level3">
<h3>Use as a Library</h3>
<p>Reference <code>src/lambda-cek.csproj</code> from another project and
instantiate:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> interp <span class="op">=</span> <span class="kw">new</span> LambdaCalculus<span class="op">.</span><span class="fu">Interpreter</span><span class="op">(</span>logger<span class="op">:</span> <span class="kw">new</span> LambdaCalculus<span class="op">.</span><span class="fu">Logger</span><span class="op">());</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>await interp<span class="op">.</span><span class="fu">LoadFileIfExistsAsync</span><span class="op">(</span><span class="st">&quot;stdlib.lambda&quot;</span><span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">var</span> <span class="op">(</span>expr<span class="op">,</span> result<span class="op">)</span> <span class="op">=</span> await interp<span class="op">.</span><span class="fu">ProcessInputAsync</span><span class="op">(</span><span class="st">&quot;succ 41&quot;</span><span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>Console<span class="op">.</span><span class="fu">WriteLine</span><span class="op">(</span>result<span class="op">);</span> <span class="co">// 42</span></span></code></pre></div>
</section>
<section id="notes" class="level3">
<h3>Notes</h3>
<ul>
<li>Warnings (XML docs) are expected; enable / suppress as needed.</li>
<li>The web API keeps a single in-memory interpreter instance; scale-out
would need state strategy (e.g., per-session or stateless evaluation
model).</li>
<li>For production hosting harden the endpoints (validation, timeouts,
resource limits).</li>
<li>The Web UI project exposes <code>/api/eval</code>,
<code>/api/load</code>, and <code>/api/health</code> (preferred liveness
endpoint). It also serves a single-page interface from
<code>wwwroot</code>.</li>
</ul>
</section>
<section id="run-web-ui" class="level3">
<h3>Run Web UI</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> run <span class="at">--project</span> src-webui</span></code></pre></div>
<p>Then open <a href="http://localhost:5000">http://localhost:5000</a>
(or the shown port) in your browser. Health status appears in the
footer.</p>
</section>
</section>
<section id="web-ui--streaming-logs" class="level2">
<h2>Web UI &amp; Streaming Logs</h2>
<p>The Web UI (<code>src-webui</code>) provides a browser-based REPL
with real-time log streaming and colored output mirroring the CLI.</p>
<section id="transports" class="level3">
<h3>Transports</h3>
<p>Two streaming transports are available for incremental log
delivery:</p>
<table>
<thead>
<tr>
<th>Transport</th>
<th>Endpoint</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Server-Sent Events (SSE)</td>
<td><code>/api/stream</code></td>
<td>Default; simple, auto‑reconnect logic implemented</td>
</tr>
<tr>
<td>WebSocket</td>
<td><code>/ws</code></td>
<td>Optional; toggle with the UI button (&quot;WS: On/Off&quot;)</td>
</tr>
</tbody>
</table>
<p>Toggle streaming via the &quot;Streaming&quot; button. When disabled,
evaluation responses include a buffered copy of the logs
(<code>logs</code> array) in the JSON payload (gathered from the
interpreter&#39;s in‑memory log buffer). When enabled, logs are pushed
line-by-line; the final JSON response only supplies the canonical
result(s).</p>
</section>
<section id="progress-feedback" class="level3">
<h3>Progress Feedback</h3>
<p>While loading <code>.lambda</code> files the interpreter emits
progress pseudo‑log lines in the form:</p>
<pre class="text"><code>PROGRESS::&lt;percent&gt;</code></pre>
<p>The UI converts these into a progress bar; when 100% is reached the
bar auto-hides after a short delay. A final timing / summary line is
also streamed (e.g.
<code>Loaded stdlib.lambda (N lines in X ms)</code>).</p>
</section>
<section id="colored-log-classification" class="level3">
<h3>Colored Log Classification</h3>
<p>Incoming log lines are classified on the client (prefix / pattern
heuristics) and assigned CSS classes:</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Meaning (examples)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>log-error</code></td>
<td>Error diagnostics (<code>Error:</code> …)</td>
</tr>
<tr>
<td><code>log-result</code></td>
<td>Result marker lines starting with <code>-&gt;</code></td>
</tr>
<tr>
<td><code>log-step</code></td>
<td>Step-by-step evaluation traces (when <code>:step on</code>)</td>
</tr>
<tr>
<td><code>log-time</code> / <code>log-name</code></td>
<td>Timing / named expression metadata</td>
</tr>
<tr>
<td><code>log-eval</code></td>
<td>Evaluation summaries (<code>Eval:</code>)</td>
</tr>
<tr>
<td><code>log-macro</code></td>
<td>Macro expansion info</td>
</tr>
<tr>
<td><code>log-test</code>, <code>log-test-pass</code>,
<code>log-test-fail</code></td>
<td>Structural test counters / outcomes</td>
</tr>
<tr>
<td><code>log-command</code></td>
<td>Echoed colon commands (lines beginning with <code>:</code>)</td>
</tr>
<tr>
<td><code>log-loading</code></td>
<td>File loading lines (contain <code>Loading</code>)</td>
</tr>
<tr>
<td><code>log-fileline</code> / <code>log-fileresult</code></td>
<td>Per-line file load traces / outcomes</td>
</tr>
<tr>
<td><code>log-progress</code></td>
<td>Progress pseudo-lines</td>
</tr>
</tbody>
</table>
<p>The classification is intentionally lightweight; adding new patterns
only requires editing <code>classify()</code> inside
<code>wwwroot/index.html</code>.</p>
</section>
<section id="log-retention" class="level3">
<h3>Log Retention</h3>
<p>To prevent the browser DOM from growing unbounded during long step
traces, the UI caps the number of displayed log lines (default 4000).
Older nodes are trimmed once the cap is exceeded. You can now adjust
this at runtime with the &quot;Max Lines&quot; numeric control beside the Result /
Log header (per page session). The underlying cap variable updates
immediately and existing logs are trimmed if above the new limit.</p>
</section>
<section id="typical-workflow" class="level3">
<h3>Typical Workflow</h3>
<ol type="1">
<li>Start the UI: <code>dotnet run --project src-webui</code></li>
<li>(Optional) Click <code>Streaming: On</code> (or append
<code>#stream</code> to the URL for auto-enable)</li>
<li>(Optional) Enable WebSocket transport (<code>WS: On</code>) if
desired</li>
<li>Enter expressions or colon commands (e.g. <code>:stats</code>,
<code>succ 41</code>, <code>let x = 5 in x*x</code>)</li>
<li>Load additional files via the right-hand panel
(<code>stdlib.lambda</code> is preloaded if found)</li>
</ol>
</section>
<section id="api-summary-web-ui-namespace" class="level3">
<h3>API Summary (Web UI Namespace)</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Route</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><code>/api/eval?expr=...</code></td>
<td>Evaluate a single expression (returns JSON with <code>output</code>,
<code>normalized</code>, and <code>logs</code> when not streaming)</td>
</tr>
<tr>
<td>POST</td>
<td><code>/api/load</code> (JSON <code>{ path }</code>)</td>
<td>Load a <code>.lambda</code> file; returns <code>message</code> +
<code>logs</code></td>
</tr>
<tr>
<td>GET</td>
<td><code>/api/stream</code></td>
<td>SSE endpoint for real-time log push (one <code>data:</code> line per
log)</td>
</tr>
<tr>
<td>GET</td>
<td><code>/api/health</code></td>
<td>Health/liveness check</td>
</tr>
<tr>
<td>WS</td>
<td><code>/ws</code></td>
<td>WebSocket log stream (one text frame per log line)</td>
</tr>
</tbody>
</table>
<p>The interpreter instance is shared; stateful definitions/macros
persist across requests and streams. For multi-user deployment, isolate
interpreters (per session) or introduce workspace scoping.</p>
</section>
<section id="disabling-streaming--fallback" class="level3">
<h3>Disabling Streaming / Fallback</h3>
<p>If streaming is off, interactive operations rely solely on the
buffered log snapshot captured between <code>Logger.ClearBuffer()</code>
and evaluation completion. This ensures feature parity for environments
where SSE / WebSockets are blocked.</p>
</section>
<section id="extensibility" class="level3">
<h3>Extensibility</h3>
<p>You can instrument additional events by invoking
<code>Logger.Log(&quot;...&quot;)</code> within interpreter code paths—those lines
will appear uniformly across CLI and Web transports. Keep emitted lines
single-line (newlines are flattened in SSE) for predictable
streaming.</p>
</section>
<section id="streaming-modes-comparison" class="level3">
<h3>Streaming Modes (Comparison)</h3>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Enable</th>
<th>Transport</th>
<th>Log Delivery</th>
<th>Response JSON</th>
<th>Best For</th>
</tr>
</thead>
<tbody>
<tr>
<td>Buffered</td>
<td>Streaming Off</td>
<td>none</td>
<td>After completion (batched)</td>
<td><code>{ output, normalized, logs[] }</code></td>
<td>Simplicity, copy full log</td>
</tr>
<tr>
<td>SSE</td>
<td>Streaming On</td>
<td><code>/api/stream</code></td>
<td>Incremental (auto-reconnect)</td>
<td><code>{ output, normalized }</code></td>
<td>Progressive feedback, long loads</td>
</tr>
<tr>
<td>WebSocket</td>
<td>Streaming On + WS On</td>
<td><code>/ws</code></td>
<td>Incremental (manual reconnect logic)</td>
<td><code>{ output, normalized }</code></td>
<td>Future interactive extensions</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol type="1">
<li>Toggling streaming clears the UI log to visually separate
sessions.</li>
<li>SSE auto-reconnect delay is capped; repeated disconnects are
surfaced with a status banner.</li>
<li>WebSocket mode is optional; fallback to SSE if handshake fails.</li>
<li>All modes share the same underlying <code>Logger</code>; difference
is purely transport serialization.</li>
</ol>
</section>
</section>
<section id="docker-web-ui" class="level2">
<h2>Docker (Web UI)</h2>
<p>Container support is provided for the Web UI project
(<code>src-webui</code>). The Dockerfile builds only the
<code>net8.0</code> target (temporarily rewriting the multi-target
library to avoid requiring a .NET 9 SDK inside the image).</p>
<section id="build-image" class="level3">
<h3>Build Image</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> lambda-cek-webui <span class="at">-f</span> src-webui/Dockerfile .</span></code></pre></div>
</section>
<section id="run-container" class="level3">
<h3>Run Container</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">-p</span> 8080:8080 <span class="at">--name</span> lambda-cek lambda-cek-webui</span></code></pre></div>
<p>Then open <a href="http://localhost:8080">http://localhost:8080</a>.</p>
</section>
<section id="bind-mount-files" class="level3">
<h3>Bind Mount Files</h3>
<p>Mount the repo to allow loading <code>stdlib.lambda</code> or custom
files (PowerShell / CMD on Windows, replace <code>%CD%</code>
appropriately for Linux/macOS):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">-p</span> 8080:8080 <span class="at">-v</span> %CD%:/data:ro <span class="at">--name</span> lambda-cek lambda-cek-webui</span></code></pre></div>
<p>The app looks for <code>stdlib.lambda</code> in the working
directory, its parent, or the base directory. Adjust with
<code>-w</code> or copy files into the image for immutable
deployments.</p>
</section>
<section id="change-port" class="level3">
<h3>Change Port</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">-e</span> ASPNETCORE_URLS=http://0.0.0.0:5005 <span class="at">-p</span> 5005:5005 lambda-cek-webui</span></code></pre></div>
</section>
<section id="multi-arch-build-optional" class="level3">
<h3>Multi-Arch Build (Optional)</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> buildx build <span class="at">--platform</span> linux/amd64,linux/arm64 <span class="at">-t</span> yourrepo/lambda-cek-webui:latest .</span></code></pre></div>
</section>
<section id="updating-for-net-9" class="level3">
<h3>Updating for .NET 9</h3>
<p>Remove the <code>sed</code> line in the Dockerfile and use a .NET SDK
image that supports <code>net9.0</code>. Keep multi-targeting only if
needed for consumers.</p>
</section>
<section id="security-notes" class="level3">
<h3>Security Notes</h3>
<ul>
<li>No authentication / sandboxing by default.</li>
<li>Long or CPU-heavy expressions can monopolize the single interpreter
instance.</li>
<li>Add resource limits (CPU, memory) and reverse proxy restrictions for
shared environments.</li>
</ul>
</section>
</section>
<section id="user-defined-native-primitives" class="level2">
<h2>User-Defined Native Primitives</h2>
<p>You can extend the interpreter with your own native (host language)
primitives. This is useful for adding custom arithmetic, logic, or
interop functions.</p>
<section id="registering-a-native-primitive-c-example" class="level3">
<h3>Registering a Native Primitive (C# Example)</h3>
<p>In your host C# code:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>interpreter<span class="op">.</span><span class="fu">RegisterNativeFunction</span><span class="op">(</span><span class="st">&quot;inc&quot;</span><span class="op">,</span> <span class="op">(</span>args<span class="op">,</span> env<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>args<span class="op">.</span><span class="fu">Count</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> interpreter<span class="op">.</span><span class="fu">TryGetChurchInt</span><span class="op">(</span>args<span class="op">[</span><span class="dv">0</span><span class="op">],</span> env<span class="op">,</span> <span class="kw">out</span> <span class="dt">var</span> n<span class="op">))</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> interpreter<span class="op">.</span><span class="fu">MakeChurchNumeral</span><span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span></code></pre></div>
<p>This makes <code>inc</code> available as a function in your lambda
calculus code:</p>
<pre class="lambda"><code>inc 2   # returns 3 (as a Church numeral)</code></pre>
<p>You can register, override, or remove any primitive at runtime. All
user-defined primitives are listed in the environment display (see
<code>:env</code> command).</p>
</section>
<section id="running-the-interpreter" class="level3">
<h3>Running the Interpreter</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Start interactive mode</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./lambda-cek</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load files at startup</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ex">./lambda-cek</span> file1.lambda file2.lambda</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># The standard library is automatically loaded from stdlib.lambda</span></span></code></pre></div>
</section>
<section id="basic-syntax" class="level3">
<h3>Basic Syntax</h3>
<pre class="lambda"><code># Variables and application
x                        # Variable
f x                      # Function application

# Lambda abstractions
λx.x                     # Identity function
\x.x                     # Alternative syntax
x -&gt; x                   # Arrow function syntax (same as λx.x)

# Placeholder variables (underscore for ignored parameters)
_ -&gt; 42                  # Constant function, parameter ignored → λ_1.42
(x, _, _ -&gt; x) 42 9 8    # Extract first of three arguments → 42
_ + _ -&gt; mult _ _         # Multiple underscores become unique variables
map (_ -&gt; 0) [1, 2, 3]   # Zero out all elements → [0, 0, 0]

# Multi-parameter functions
λx y.x                   # Same as λx.λy.x
x, y -&gt; x + y            # Multi-parameter arrow function → λx.λy.x + y

# Church numerals
0, 1, 2, 42              # Integer literals → λf.λx.x, λf.λx.f x, λf.λx.f (f x), etc.

# Let expressions (syntactic sugar for function application)
let id = x -&gt; x in id 42                    # → (λid.id 42) (λx.x)
let add = x, y -&gt; x + y in add 3 4          # → (λadd.add 3 4) (λx.λy.x + y)

# Multiple let bindings
let x = 3, y = 4 in x * y                   # → (λx.λy.x * y) 3 4

# Recursive definitions (uses Y combinator)
let rec factorial = n -&gt; if (iszero n) 1 (mult n (factorial (pred n))) in factorial 5
# → (λfactorial.factorial 5) (Y (λfactorial.λn.if (iszero n) 1 (mult n (factorial (pred n)))))

# Lists (syntactic sugar for cons/nil structures)
[1, 2, 3]               # → cons 1 (cons 2 (cons 3 nil))
[]                      # → nil
[1 .. 5]                # → cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil))))
[10 .. 5]               # → cons 10 (cons 9 (cons 8 (cons 7 (cons 6 (cons 5 nil)))))
[-3 .. 3]               # Negative &amp; positive literal range
[1, 3 .. 11]            # Stepped range (step = 2) → [1, 3, 5, 7, 9, 11]
[10, 7 .. -2]           # Descending stepped range (step = -3) → [10, 7, 4, 1, -2]

# General / dynamic ranges (non-literal endpoints are desugared, not expanded eagerly)
[f x .. g y]            # Desugars to (range (f x) (g y)) and is produced lazily
[a, a+2 .. b]           # Desugars to (range2 a (a+2) b) when any part is non-literal

# NOTE (Updated): `range` and `range2` are lazily auto-injected if a non-literal range form
# requires them and they are not already defined. Provide your own earlier to override.
# Literal ranges with only integer endpoints expand eagerly and do not depend on these names.

# Built-in operators
5 |&gt; succ |&gt; mult 2     # Pipeline operator: left-to-right data flow → 12
(mult 2) ∘ succ         # True composition operator: right-to-left function building
f . x . y               # Application chaining sugar: (f x) y (&#39;.&#39; no longer composition)
3 + 4 * 5               # Infix arithmetic (when operators are defined) → 23

# Application operator (predefined)
# $ has lowest precedence (1) and is right-associative; f $ x ≡ f x
succ (pred 5)            # Standard parentheses
succ $ pred 5            # Same, parentheses removed
succ $ pred $ succ 4     # Right associative chaining
map (λx.mult x x) (filter (λx.gt x 2) (range 6))
map (λx.mult x x) $ filter (λx.gt x 2) $ range 6   # Clearer without nesting

# def function definition sugar
def inc x = x + 1        # Desugars to: inc = x -&gt; x + 1
def add x y = x + y      # Desugars to: add = x,y -&gt; x + y
def id x = x             # Same as: id = x -&gt; x
def answer = 42          # No parameters ⇒ answer = 42 (no arrow introduced)
inc 5                    # 6
add 3 4                  # 7
answer                   # 42

# Formally:
# def f p1 p2 ... pn = body  ⇒  f = p1,p2,...,pn -&gt; body
# def f = expr               ⇒  f = expr
# - Parameters are a flat sequence of identifiers until &#39;=&#39;.
# - Works equally at top level or inside loaded files / sequences.
# - `f` can also be an infix operator symbol previously declared (rare: for clarity keep alphanumeric names).

# Comments
# This is a comment

# Semicolon sequencing (top-level only)
expr1; expr2; expr3     # Evaluate expr1, then expr2, then expr3; final result shown
let x = 5 in x; succ 10 # Two separate evaluations

# Notes:
# - Semicolons are only recognized at the top level (REPL root or file root)
# - A semicolon inside a list, lambda, let, etc. triggers a parse error (UnexpectedSemicolon)</code></pre>
</section>
<section id="advanced-syntax-features" class="level3">
<h3>Advanced Syntax Features</h3>
<section id="underscore-placeholder-variables" class="level4">
<h4>Underscore Placeholder Variables</h4>
<p>The underscore (<code>_</code>) serves as a placeholder for ignored
or unused parameters in lambda expressions:</p>
<pre class="lambda"><code># Single underscore for ignored parameters
const42 = _ -&gt; 42                    # Always returns 42, ignores input
const42 100                          # → 42

# Multiple underscores become unique variables
first = (x, _, _) -&gt; x               # Extract first of three arguments
first 1 2 3                          # → 1

second = (_, y, _) -&gt; y              # Extract second of three arguments
second 1 2 3                         # → 2

# Underscores in function bodies refer to parameters
swapArgs = (_, _) -&gt; _ _             # Each _ refers to a unique parameter position
# Equivalent to: (x, y) -&gt; y x

# Practical examples with higher-order functions
map (_ -&gt; 0) [1, 2, 3, 4]           # Zero out all elements → [0, 0, 0, 0]
filter (_ -&gt; true) [1, 2, 3]        # Keep all elements → [1, 2, 3]
foldl (_ acc -&gt; acc) 0 [1, 2, 3]    # Ignore values, keep accumulator → 0

# Complex expressions with mixed parameters
transform = (x, _, z) -&gt; x + z       # Use first and third, ignore second
transform 10 999 5                   # → 15

# Underscore with operators
addBoth = _ + _ -&gt; mult _ _           # Each _ is a unique parameter
# Equivalent to: (x, y) -&gt; mult (x + y) (x + y)</code></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li>Each <code>_</code> in a lambda parameter list becomes a unique,
auto-generated variable</li>
<li>Underscores in the function body refer back to these auto-generated
parameters</li>
<li>Useful for partial application patterns and when some parameters are
irrelevant</li>
<li>Improves code readability by explicitly showing which parameters are
ignored</li>
</ul>
</section>
</section>
</section>
<section id="interactive-commands" class="level2">
<h2>Interactive Commands</h2>
<p>The interpreter provides numerous commands for managing your
session:</p>
<section id="environment-management" class="level3">
<h3>Environment Management</h3>
<pre class="shell"><code>:clear                   # Clear everything (env + macros + infix ops + stats + caches)
:clear defs              # Clear only definitions (env); keep macros &amp; infix ops
:clear macros            # Clear only macro clauses
:clear ops               # Clear custom infix operators (restores defaults |&gt;, ., ∘, $)
:clear cache             # Clear all memoization / analysis caches
:clear all               # Same as bare :clear
:env                     # Show environment (defs, macros, infix, natives)
:env defs                # Show only definitions
:env macros              # Show only macros
:env infix               # Show only infix operators
:env native              # Show native primitives
:load &lt;file&gt;             # Load definitions from file
:save &lt;file&gt;             # Save current environment to file</code></pre>
</section>
<section id="evaluation-control" class="level3">
<h3>Evaluation Control</h3>
<pre class="shell"><code>:lazy on|off             # Toggle lazy/eager evaluation
:step on|off             # Toggle step-by-step evaluation
:depth [n]               # Set/show recursion depth limit (10-10000)
:native on|off           # Toggle native arithmetic optimizations
:pretty on|off           # Toggle pretty printing</code></pre>
</section>
<section id="debugging-and-performance" class="level3">
<h3>Debugging and Performance</h3>
<pre class="shell"><code>:stats                   # Show detailed performance statistics
:test clear              # Reset structural equality test counters
:test result             # Show structural equality test counters (calls/successes)
:clear cache             # Clear all caches (memoization)
:log &lt;file|off&gt;          # Enable/disable logging to file</code></pre>
</section>
<section id="language-extensions" class="level3">
<h3>Language Extensions</h3>
<pre class="shell"><code>:infix &lt;op&gt; &lt;prec&gt; &lt;assoc&gt;  # Define infix operator
:macro (pattern) =&gt; body    # Define macro
:env macros                # List macro clauses only (shortcut for filtering)</code></pre>
</section>
<section id="help-and-information" class="level3">
<h3>Help and Information</h3>
<pre class="shell"><code>:help                    # Show comprehensive help (includes multi-line input usage)
:native show             # Show all native arithmetic functions
:env [defs|macros|infix|native|all]  # Show environment (optionally filtered)</code></pre>
</section>
<section id="command-effects--desugarings-summary" class="level3">
<h3>Command Effects / Desugarings (Summary)</h3>
<p>This summarizes the operational effect or syntactic desugaring
performed by each command / construct:</p>
<table>
<thead>
<tr>
<th>Command / Construct</th>
<th>Effect / Desugaring</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>def f x y = body</code></td>
<td><code>f = x,y -&gt; body</code></td>
</tr>
<tr>
<td><code>x, y -&gt; body</code></td>
<td><code>x -&gt; y -&gt; body</code></td>
</tr>
<tr>
<td><code>let x = A, y = B in C</code></td>
<td><code>let x = A in let y = B in C</code></td>
</tr>
<tr>
<td><code>let rec f = E in B</code></td>
<td><code>let f = Y (λf.E) in B</code></td>
</tr>
<tr>
<td><code>a |&gt; f |&gt; g</code></td>
<td><code>g (f a)</code> (left-to-right pipeline)</td>
</tr>
<tr>
<td><code>f . a . b</code></td>
<td><code>(f a) b</code> (application chaining; &#39;.&#39; is not
composition)</td>
</tr>
<tr>
<td><code>f ∘ g</code></td>
<td><code>λx.f (g x)</code> (true composition, right-assoc)</td>
</tr>
<tr>
<td><code>f $ x $ y</code></td>
<td><code>f x y</code> ( <code>$</code> is right-assoc, lowest
precedence application operator )</td>
</tr>
<tr>
<td><code>λx y.z</code></td>
<td><code>λx.λy.z</code></td>
</tr>
<tr>
<td><code>_</code> placeholders</td>
<td>Each <code>_</code> becomes a fresh, unique parameter name (ignored
if unused)</td>
</tr>
<tr>
<td><code>:infix op p a</code></td>
<td>Registers <code>op</code> with precedence <code>p</code> and
associativity <code>a</code></td>
</tr>
<tr>
<td><code>:macro (pat) =&gt; body</code></td>
<td>Adds macro clause (pattern rewrite pre-parse of expressions
segment)</td>
</tr>
<tr>
<td><code>:clear</code></td>
<td>Clears env, macros, infix ops (except built-ins), stats &amp;
caches</td>
</tr>
<tr>
<td><code>:clear macros</code></td>
<td>Clears only macro clauses</td>
</tr>
<tr>
<td><code>:clear defs</code></td>
<td>Removes value bindings (definitions)</td>
</tr>
<tr>
<td><code>:clear ops</code></td>
<td>Removes custom infix operators; keeps predefined |&gt; . ∘ $</td>
</tr>
<tr>
<td><code>:clear cache</code></td>
<td>Clears substitution/evaluation/analysis caches</td>
</tr>
<tr>
<td><code>:depth n</code></td>
<td>Sets recursion depth guard to <code>n</code> (10–10000)</td>
</tr>
<tr>
<td><code>:lazy on|off</code></td>
<td>Toggles lazy vs eager evaluation mode</td>
</tr>
<tr>
<td><code>:native on|off</code></td>
<td>Enables/disables native arithmetic &amp; primitive
optimizations</td>
</tr>
<tr>
<td><code>:native show</code></td>
<td>Lists current native primitives</td>
</tr>
<tr>
<td><code>:pretty on|off</code></td>
<td>Toggles pretty printing for numerals, lists, booleans</td>
</tr>
<tr>
<td><code>:step on|off</code></td>
<td>Toggles CEK step trace emission</td>
</tr>
<tr>
<td><code>:stats</code></td>
<td>Prints performance &amp; cache statistics report</td>
</tr>
<tr>
<td><code>:test clear</code></td>
<td>Resets structural equality counters</td>
</tr>
<tr>
<td><code>:test result</code></td>
<td>Displays structural equality counters</td>
</tr>
<tr>
<td><code>:log file</code></td>
<td>Appends subsequent output to file</td>
</tr>
<tr>
<td><code>:log off</code></td>
<td>Stops logging to file</td>
</tr>
<tr>
<td><code>:log clear</code></td>
<td>Truncates current log file (if any)</td>
</tr>
<tr>
<td><code>:env …</code></td>
<td>Displays filtered environment subsets</td>
</tr>
<tr>
<td><code>:save file</code></td>
<td>Writes definitions/macros/infix declarations to file</td>
</tr>
<tr>
<td><code>:load file</code></td>
<td>Loads and evaluates a <code>.lambda</code> file line-by-line</td>
</tr>
<tr>
<td><code>:help</code></td>
<td>Displays help summary (includes these desugarings)</td>
</tr>
<tr>
<td><code>:exit</code> / <code>:quit</code></td>
<td>Terminates the interpreter</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note: Built-in infix operators always available: <code>|&gt;</code>
(pipeline), <code>∘</code> (composition), <code>.</code> (application
chaining), <code>$</code> (low-precedence application). Overriding them
is discouraged; docs assume these semantics.</p>
</blockquote>
</section>
</section>
<section id="command--expression-chaining" class="level2">
<h2>Command / Expression Chaining</h2>
<p>You can place multiple commands and/or expressions on a single line
(or in a file) separated by top‑level semicolons. This works uniformly
for colon commands (e.g. <code>:load</code>, <code>:macro</code>,
<code>:infix</code>) and ordinary expressions.</p>
<section id="examples" class="level3">
<h3>Examples</h3>
<pre class="shell"><code># Define a macro then immediately use it
:macro (inc $x) =&gt; (succ $x); inc 5            # → 6

# Load a file then run an expression
:load stdlib.lambda; plus 2 3                  # (loads stdlib, then evaluates) → 5

# Chain several expressions (only final result is printed; earlier ones still evaluate)
let x = 10 in succ x; let y = 2 in mult y 5    # → 10

# Mix multiple commands and expressions
:macro (sq $x) =&gt; (mult $x $x); :env macros; sq 7  # Lists macros, then evaluates → 49</code></pre>
</section>
<section id="rules" class="level3">
<h3>Rules</h3>
<ul>
<li>Semicolons are recognized only at the top level (i.e. not inside
parentheses, brackets, lambdas, lets, lists, or macro bodies).</li>
<li>Empty segments (e.g. stray trailing <code>;</code>) are
ignored.</li>
<li><code>:exit</code> / <code>:quit</code> stop further processing of
subsequent segments on the same line.</li>
<li>Each segment is processed in left‑to‑right order; environment
changes (definitions, macros, infix ops) take effect for later segments
in the same line.</li>
<li>Errors in a segment abort the remaining segments on that line.</li>
</ul>
</section>
<section id="practical-uses" class="level3">
<h3>Practical Uses</h3>
<ul>
<li>Rapid prototyping: define + test in one line.</li>
<li>Batch loading:
<code>:load a.lambda; :load b.lambda; :stats</code>.</li>
<li>Macro refinement: redeclare a macro and immediately inspect with
<code>:env macros</code>.</li>
</ul>
<p>This feature streamlines interactive workflows by reducing the number
of round trips required to iterate on definitions and tests.</p>
</section>
</section>
<section id="core-language" class="level2">
<h2>Core Language</h2>
<section id="lambda-abstractions" class="level3">
<h3>Lambda Abstractions</h3>
<pre class="lambda"><code># Basic lambda
id = λx.x
id = \x.x                # Alternative syntax (backslash)
id = x -&gt; x              # Arrow function syntax → λx.x

# Multi-parameter functions
add = λx y.x + y                    # Standard lambda calculus
add = x, y -&gt; x + y                 # Arrow syntax → λx.λy.x + y

# Higher-order functions
twice = f -&gt; x -&gt; f (f x)           # → λf.λx.f (f x)
compose = f -&gt; g -&gt; x -&gt; f (g x)    # → λf.λg.λx.f (g x)</code></pre>
</section>
</section>
<section id="formal-grammar" class="level2">
<h2>Formal Grammar</h2>
<p>This section specifies the concrete grammar accepted by the parser
after the Pratt refactor. Grammar is written in an EBNF‑style notation;
terminals appear in single quotes; parentheses group; <code>*</code> =
0+ repetition, <code>+</code> = 1+ repetition, <code>?</code> =
optional, <code>|</code> = alternation.</p>
<p>Precedence (loosest → tightest):</p>
<pre class="text"><code>let  &lt;  arrow (paramList &#39;-&gt;&#39;)  &lt;  infix operators (by declared precedence number)  &lt;  application  &lt;  atom</code></pre>
<p>Associativity:</p>
<ul>
<li>Let: right (body extends to the rightmost expression)</li>
<li>Arrow (<code>-&gt;</code>): right (parameters associate to the
right, <code>x, y, z -&gt; e</code> =
<code>x -&gt; (y -&gt; (z -&gt; e))</code>)</li>
<li>Infix: per definition
(<code>:infix &lt;op&gt; &lt;prec&gt; left|right</code>); higher
precedence number binds tighter</li>
<li>Application: left (juxtaposition chains left‑to‑right)</li>
</ul>
<p>Lexical elements:</p>
<pre class="ebnf"><code>Identifier    ::= Letter (Letter | Digit | &#39;_&#39; | &#39;?&#39;)*
Integer       ::= Digit+            # Parsed into Church numeral
Underscore    ::= &#39;_&#39;               # Placeholder parameter (fresh name generated)
Comment       ::= &#39;#&#39; &lt;until end of line&gt;
Whitespace    ::= (&#39; &#39; | &#39;\t&#39; | &#39;\r&#39; | &#39;\n&#39;)+
Arrow         ::= &#39;-&gt;&#39;
LambdaIntro   ::= &#39;λ&#39; | &#39;\\&#39;
Ellipsis      ::= &#39;...&#39;</code></pre>
<p>Top level &amp; segmentation:</p>
<pre class="ebnf"><code>Program       ::= Segment (&#39;;&#39; Segment)*                      # Semicolons only at top level
Segment       ::= (Command | Definition | Expression)?        # Empty segments ignored
Command       ::= &#39;:&#39; CommandName CommandArgs?
CommandName   ::= Identifier | &#39;infix&#39; | &#39;macro&#39; | &#39;macros&#39; | &#39;load&#39; | &#39;clear&#39; | ... (see Interactive Commands)
Definition    ::= Identifier &#39;=&#39; Expression                   # Eagerly evaluated &amp; stored</code></pre>
<p>Expressions (ordered by parsing precedence):</p>
<pre class="ebnf"><code>Expression    ::= LetExpr | ArrowExpr | InfixExpr

LetExpr       ::= &#39;let&#39; (&#39;rec&#39;)? LetBinding (&#39;,&#39; LetBinding)* &#39;in&#39; Expression
LetBinding    ::= Identifier &#39;=&#39; Expression
               | Identifier ParamList &#39;-&gt;&#39; Expression         # Sugar: params desugar to nested lambdas

ArrowExpr     ::= ParamList &#39;-&gt;&#39; Expression                   # Recognized only if followed by &#39;-&gt;&#39;
ParamList     ::= Param (&#39;,&#39; Param)* | &#39;(&#39; Param (&#39;,&#39; Param)* &#39;)&#39;
Param         ::= Identifier | Underscore

InfixExpr     ::= Application (InfixOp Application)*          # Pratt: precedence &amp; associativity driven
InfixOp       ::= OperatorSymbol                              # Previously defined via :infix

Application   ::= Atom+                                       # Left associative
Atom          ::= Integer
               | Identifier
               | Lambda
               | List
               | &#39;(&#39; Expression &#39;)&#39;
               | MacroInvocation

Lambda        ::= LambdaIntro Param+ &#39;.&#39; Expression           # λx y z.body → λx.λy.λz.body
MacroInvocation ::= Identifier Arg*                           # After expansion behaves as ordinary expr
Arg           ::= Atom | &#39;(&#39; Expression &#39;)&#39;</code></pre>
<p>Lists &amp; ranges:</p>
<pre class="ebnf"><code>List          ::= &#39;[&#39; ListBody? &#39;]&#39;
ListBody      ::= Elements | RangeSpec | SteppedRangeSpec
Elements      ::= Expression (&#39;,&#39; Expression)*
RangeSpec     ::= Expression &#39;..&#39; Expression                  # Literal endpoints → expanded; else desugars (range a b)
SteppedRangeSpec ::= Expression &#39;,&#39; Expression &#39;..&#39; Expression # Desugars (range2 a b c) if non‑literal</code></pre>
<p>Notes:</p>
<ol type="1">
<li>Ranges expand eagerly only when all endpoints (and middle for
stepped) are integer literals (supports negative forms
<code>-3</code>).</li>
<li>A stepped range with zero step yields a singleton list.</li>
<li>Non‑literal endpoints produce a desugaring: <code>[a .. b]</code> →
<code>(range a b)</code>, <code>[a, b .. c]</code> →
<code>(range2 a b c)</code>.</li>
</ol>
<p>Macros &amp; directives:</p>
<pre class="ebnf"><code>MacroDef      ::= &#39;:macro&#39; &#39;(&#39; Pattern &#39;)&#39; GuardOpt &#39;=&gt;&#39; Expansion
GuardOpt      ::= (&#39;when&#39; &#39;(&#39; Expression &#39;)&#39;)?
Pattern       ::= PatternPart+                               # $var, symbols, rest ($xs ... at tail)
RestPattern   ::= &#39;$&#39; Identifier Ellipsis
Expansion     ::= Expression                                  # Parsed pre‑expansion then substituted
InfixDecl     ::= &#39;:infix&#39; OperatorSymbol Integer (&#39;left&#39; | &#39;right&#39;)
OperatorSymbol ::= NonAlnumSymbol+                            # e.g. +, *, ^, &amp;&amp;, |&gt; , . , &lt;=</code></pre>
<p>Placeholders:</p>
<pre class="text"><code>Every &#39;_&#39; in a ParamList becomes a fresh, unique variable (e.g., _placeholder1) and may be referenced positionally in the body with the same `_` spelling.</code></pre>
<p>Desugarings (informal):</p>
<pre class="text"><code>let x = A in B                ≡ (λx.B) A
let x = a, y = b in B         ≡ (λx.λy.B) a b
let rec f = E in B            ≡ (λf.B) (Y (λf.E))
x, y, z -&gt; R                  ≡ x -&gt; (y -&gt; (z -&gt; R)) ≡ λx.λy.λz.R
[a, b, c]                     ≡ cons a (cons b (cons c nil))
a |&gt; f                        ≡ f a        (left‑to‑right pipeline)
f . g                         ≡ λx.f (g x) (composition)</code></pre>
<p>Error Handling Summary (parser): <code>UnexpectedToken</code>,
<code>MissingLetEquals</code>, <code>UnexpectedArrow</code>,
<code>UnexpectedComma</code>, <code>EmptyExprList</code>,
<code>UnexpectedSemicolon</code>, <code>IllegalAssignment</code>,
<code>UnexpectedDot</code>, <code>UnterminatedList</code>,
<code>MacroPatternError</code>, etc. See &quot;Parser Errors &amp;
Diagnostics&quot; for details.</p>
<p>For a condensed in‑REPL quick reference, run <code>:help</code>. The
help view omits some extended macro and range details for brevity.</p>
<hr />
<p>Rationale: The grammar is optimized for clarity over minimality.
Pratt parsing handles <code>InfixExpr</code> with dynamic precedence
tables populated at runtime via <code>:infix</code> declarations; thus
<code>InfixOp</code> is not a fixed token set.</p>
<hr />
<section id="parser-errors--diagnostics" class="level3">
<h3>Parser Errors &amp; Diagnostics</h3>
<p>This section enumerates the most common parser errors along with
their meaning and likely remedies.</p>
<table>
<thead>
<tr>
<th>Error</th>
<th>Meaning / Trigger</th>
<th>Typical Fix</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>UnexpectedToken</code></td>
<td>Token doesn&#39;t fit current production</td>
<td>Check for missing delimiters or stray characters</td>
</tr>
<tr>
<td><code>MissingLetEquals</code></td>
<td><code>let x ? y</code> missing <code>=</code></td>
<td>Insert <code>=</code> between binding name and expression</td>
</tr>
<tr>
<td><code>UnexpectedArrow</code></td>
<td>Misplaced <code>-&gt;</code> (e.g., outside lambda/guard)</td>
<td>Ensure correct lambda syntax <code>λx.y</code> or guard form</td>
</tr>
<tr>
<td><code>UnexpectedComma</code></td>
<td>Extra comma in lists, params, or ranges</td>
<td>Remove trailing or double commas</td>
</tr>
<tr>
<td><code>EmptyExprList</code></td>
<td><code>[]</code> where at least one element required
(contextual)</td>
<td>Provide an element or remove brackets</td>
</tr>
<tr>
<td><code>UnexpectedSemicolon</code></td>
<td>Stray <code>;</code> not used in this language</td>
<td>Remove <code>;</code></td>
</tr>
<tr>
<td><code>IllegalAssignment</code></td>
<td>Attempt to assign to non‑identifier</td>
<td>Use identifier on left side of binding</td>
</tr>
<tr>
<td><code>UnexpectedDot</code></td>
<td>Misplaced <code>..</code> or <code>.</code> in non‑range
context</td>
<td>Correct range syntax or remove dot</td>
</tr>
<tr>
<td><code>UnterminatedList</code></td>
<td>Missing closing <code>]</code></td>
<td>Add <code>]</code></td>
</tr>
<tr>
<td><code>MacroPatternError</code></td>
<td>Malformed macro pattern / guard</td>
<td>Adjust pattern syntax / guard expression</td>
</tr>
</tbody>
</table>
<p>Diagnostics Strategy:</p>
<ol type="1">
<li>The parser accumulates context to produce precise span highlights
(future: structured JSON diagnostics output for tooling).</li>
<li>Multi‑line input preserves original indentation; caret alignment in
UI mirrors source columns.</li>
<li>Planned: colorized squiggles in the Web UI and a
<code>:errors</code> command to reprint the last parse failure set.</li>
</ol>
</section>
<section id="unary-minus--negative-literals" class="level3">
<h3>Unary Minus / Negative Literals</h3>
<p>Negative integers are parsed as a unified literal token rather than a
prefix application of <code>neg</code> to simplify downstream evaluation
and enable eager list range expansion with negative endpoints.</p>
<p>Rules:</p>
<ol type="1">
<li><code>-0</code> normalizes to <code>0</code>.</li>
<li>A minus immediately followed by digits with no intervening space
becomes a literal (e.g. <code>-42</code>).</li>
<li>A space before digits (<code>- 5</code>) is parsed as the binary
subtraction operator (if defined) or a future infix candidate.</li>
<li>In ranges, <code>[-3 .. 3]</code> expands eagerly; stepped forms
like <code>[-1,1 .. 5]</code> compute step = 2.</li>
<li>Pretty‑printer preserves original negative literal tokens without
inserting extra parentheses.</li>
</ol>
<p>Edge Cases:</p>
<pre class="lambda"><code>[-1]          # singleton list with negative literal
[ -1 ]        # same (whitespace ignored)
(-1)          # still a literal; parentheses preserved only if required by surrounding infix precedence
map (plus -1) [0,1,2]  # partial application with negative literal argument</code></pre>
<p>Rationale: Treating negative numbers as atomic avoids an explosion of
parentheses in normalized forms and keeps macro pattern matching simpler
(patterns can match <code>$n</code> against negative numerals
directly).</p>
</section>
<section id="church-numerals" class="level3">
<h3>Church Numerals</h3>
<p>Church numerals represent natural numbers as functions:</p>
<pre class="lambda"><code># Church numeral n = λf.λx.f^n(x)
0                        # λf.λx.x
1                        # λf.λx.f x
2                        # λf.λx.f (f x)

# Arithmetic operations
plus 2 3                 # 5
mult 4 5                 # 20
exp 2 3                  # 8 (2^3)
pred 5                   # 4 (predecessor)</code></pre>
</section>
<section id="lists" class="level3">
<h3>Lists</h3>
<p>Lists are implemented as right-folded structures:</p>
<pre class="lambda"><code># List construction
[1, 2, 3]               # cons 1 (cons 2 (cons 3 nil))
[]                      # nil (empty list)
[1 .. 5]                # [1, 2, 3, 4, 5]
[10 .. 5]               # [10, 9, 8, 7, 6, 5] (descending)

#### Range Syntax Extensions

The interpreter supports an expressive Haskell‑style range family:

```lambda
[a .. b]        # Inclusive range; expands immediately if a &amp; b are integer literals
[a, b .. c]     # Stepped range; step = b - a; expands immediately if all literals
[-5 .. 5]       # Negative literals allowed
[10, 7 .. -2]   # Descending stepped range using negative step
[f x .. g y]    # Dynamic endpoints → desugars to (range (f x) (g y)) lazily
[a, a+2 .. b]   # Dynamic stepped → desugars to (range2 a (a+2) b)</code></pre>
<p>Expansion Rules:</p>
<ol type="1">
<li>If every endpoint (and the second element for stepped ranges) is a
literal integer, the list is eagerly expanded at parse time.</li>
<li>Otherwise it desugars to one of the built-ins:
<ul>
<li><code>[start .. end]</code> → <code>(range start end)</code></li>
<li><code>[a, b .. c]</code> → <code>(range2 a b c)</code> (step = b -
a)</li>
</ul></li>
<li>A zero step (e.g. <code>[5,5 .. 10]</code>) yields a singleton
<code>[5]</code>.</li>
<li>Stepped progression stops before crossing the target bound
(inclusive if exactly hits it).</li>
</ol>
<p>These helper names are injected lazily by the interpreter (unless you
define them first):</p>
<pre class="lambda"><code>range a b         # Generates numbers from a to b (ascending or descending) lazily
range2 a b c      # Stepped form; b supplies a+step; works both directions lazily</code></pre>
<p>Practical examples:</p>
<pre class="lambda"><code>map (mult 2) [1, 3 .. 11]          # [2, 6, 10, 14, 18, 22]
sum [10, 7 .. -5]                  # Handles descending &amp; negative endpoints
take 5 [f n .. g n]               # Works with dynamic expressions lazily</code></pre>
<p>Error Cases:</p>
<ul>
<li>Missing second element in a stepped form (e.g.
<code>[a, .. b]</code>) raises a parse error.</li>
<li>Extra commas or malformed patterns (e.g.
<code>[a, b, c .. d]</code>) are rejected.</li>
<li>Double dots in non-range contexts raise
<code>UnexpectedDot</code>.</li>
</ul>
<p>List operations:</p>
<pre class="lambda"><code>head [1, 2, 3]          # 1
tail [1, 2, 3]          # [2, 3]
length [1, 2, 3]        # 3
append [1, 2] [3, 4]    # [1, 2, 3, 4]</code></pre>
<section id="multi-line-input" class="level4">
<h4>Multi-line Input</h4>
<p>The interpreter supports intelligent multi-line input:</p>
<pre class="lambda"><code># Automatic continuation for incomplete expressions
lambda&gt; let factorial = Y (λf n.
......&gt; [2]     if (iszero n) 1 
......&gt; [3]         (mult n (f (pred n))))
......&gt; [4] in factorial 5

# Manual continuation with backslash
lambda&gt; let result = very_long_expression \
......&gt; [2] that_continues_here in result

# Multi-line commands while editing
:cancel                            # Discard current input
:show                              # Display current buffer
:abort                             # Same as :cancel</code></pre>
</section>
</section>
</section>
<section id="standard-library" class="level2">
<h2>Standard Library</h2>
<p>The standard library (<code>stdlib.lambda</code>) provides over 200
functions organized into categories:</p>
<section id="1-core-combinators" class="level3">
<h3>1. Core Combinators</h3>
<pre class="lambda"><code># Basic combinators
I = λx.x                 # Identity
K = λx y.x               # Constant
S = λx y z.x z (y z)     # S combinator
B = λx y z.x (y z)       # Composition
C = λx y z.x z y         # Flip

# Y combinator is built-in for recursion
fact = Y (λf n.if (iszero n) 1 (mult n (f (pred n))))</code></pre>
</section>
<section id="2-boolean-logic" class="level3">
<h3>2. Boolean Logic</h3>
<pre class="lambda"><code># Boolean values and operations
true, false             # Church booleans
not, and, or, xor       # Logical operations
if                      # Conditional (λp a b.p a b)

# Examples
and true false          # false
or true false           # true
if (gt 5 3) &quot;yes&quot; &quot;no&quot;  # &quot;yes&quot;</code></pre>
</section>
<section id="3-arithmetic-operations" class="level3">
<h3>3. Arithmetic Operations</h3>
<section id="basic-arithmetic" class="level4">
<h4>Basic Arithmetic</h4>
<pre class="lambda"><code># Church numeral arithmetic
plus 3 4                # 7
minus 10 3              # 7
mult 6 7                # 42
div 15 3                # 5
mod 17 5                # 2
exp 2 8                 # 256

# Additional operations
succ 5                  # 6 (successor)
pred 5                  # 4 (predecessor)
iszero 0                # true
double 7                # 14
square 8                # 64</code></pre>
</section>
<section id="comparisons" class="level4">
<h4>Comparisons</h4>
<pre class="lambda"><code>eq 5 5                  # true
neq 3 7                 # true
lt 3 8                  # true
leq 5 5                 # true
gt 8 3                  # true
geq 5 5                 # true
max 8 12                # 12
min 5 9                 # 5</code></pre>
</section>
<section id="advanced-math" class="level4">
<h4>Advanced Math</h4>
<pre class="lambda"><code># Mathematical functions
fact 6                  # 720 (factorial)
fib 10                  # 89 (Fibonacci)
gcd 48 18               # 6 (greatest common divisor)
lcm 12 8                # 24 (least common multiple)
sqrt 25                 # 5 (integer square root)
isPrime 17              # true

# Number predicates
even 8                  # true
odd 7                   # true
ispositive 5            # true</code></pre>
</section>
</section>
<section id="4-list-operations" class="level3">
<h3>4. List Operations</h3>
<section id="basic-list-functions" class="level4">
<h4>Basic List Functions</h4>
<pre class="lambda"><code># List construction and access
cons 1 [2, 3]          # [1, 2, 3]
head [1, 2, 3]         # 1
tail [1, 2, 3]         # [2, 3]
isnil []               # true
length [1, 2, 3, 4]    # 4

# List manipulation
append [1, 2] [3, 4]   # [1, 2, 3, 4]
reverse [1, 2, 3]      # [3, 2, 1]
take 3 [1, 2, 3, 4, 5] # [1, 2, 3]
drop 2 [1, 2, 3, 4, 5] # [3, 4, 5]</code></pre>
</section>
<section id="higher-order-list-functions" class="level4">
<h4>Higher-Order List Functions</h4>
<pre class="lambda"><code># Map, filter, fold
map (mult 2) [1, 2, 3, 4]           # [2, 4, 6, 8]
filter even [1, 2, 3, 4, 5, 6]      # [2, 4, 6]
foldl plus 0 [1, 2, 3, 4]           # 10
foldr mult 1 [2, 3, 4]              # 24

# List generation
range 5                             # [0, 1, 2, 3, 4]
enumFromTo 3 7                      # [3, 4, 5, 6, 7]
repeat 3 42                         # [42, 42, 42]
primes 20                           # [2, 3, 5, 7, 11, 13, 17, 19]
range 3 9                           # Built-in two-arg form (injected) → [3,4,5,6,7,8,9]
range2 2 4 12                       # Step = 2 (4-2) → [2,4,6,8,10,12]
range2 10 7 -2                      # Step = -3 → [10,7,4,1,-2]</code></pre>
</section>
<section id="list-utilities" class="level4">
<h4>List Utilities</h4>
<pre class="lambda"><code># Element access and searching
nth 2 [10, 20, 30, 40]             # 30
elem 3 [1, 2, 3, 4]                # true
find (gt 10) [5, 15, 3, 20]        # 15
any even [1, 3, 6, 7]              # true
all (lt 10) [1, 5, 8, 9]           # true

# Aggregation
sum [1, 2, 3, 4]                   # 10
product [2, 3, 4]                  # 24
maximum [3, 7, 2, 9, 1]            # 9
minimum [3, 7, 2, 9, 1]            # 2</code></pre>
</section>
<section id="advanced-list-operations" class="level4">
<h4>Advanced List Operations</h4>
<pre class="lambda"><code># Zipping and unzipping
zip [1, 2, 3] [4, 5, 6]            # [(1,4), (2,5), (3,6)]
zipWith plus [1, 2, 3] [4, 5, 6]   # [5, 7, 9]
unzip [(1,4), (2,5), (3,6)]        # ([1,2,3], [4,5,6])

# Set operations
union [1, 2, 3] [3, 4, 5]          # [1, 2, 3, 4, 5]
intersect [1, 2, 3] [2, 3, 4]      # [2, 3]
difference [1, 2, 3, 4] [2, 4]     # [1, 3]
nub [1, 2, 2, 3, 1, 4]             # [1, 2, 3, 4] (remove duplicates)</code></pre>
</section>
</section>
<section id="5-data-structures" class="level3">
<h3>5. Data Structures</h3>
<section id="pairs" class="level4">
<h4>Pairs</h4>
<pre class="lambda"><code># Pair construction and access
p = pair 10 20
first p                            # 10
second p                           # 20
swap p                             # pair 20 10</code></pre>
</section>
<section id="maybe-type-optional" class="level4">
<h4>Maybe Type (Optional)</h4>
<pre class="lambda"><code># Maybe represents optional values
just 42                           # Some value
nothing                           # No value

# Safe operations
safehead [1, 2, 3]                # just 1
safehead []                       # nothing
safediv 10 2                      # just 5
safediv 10 0                      # nothing
safeDiv 10 2                      # alias (preferred casing)

# List tail safe variants
safeInit [1,2,3]                  # [1,2]
safeInitMaybe [1,2,3]             # just [1,2]
safeInitMaybe [1]                 # nothing

# Maybe operations
fromMaybe 0 (just 42)             # 42
fromMaybe 0 nothing               # 0
maybe 0 (mult 2) (just 21)        # 42</code></pre>
</section>
<section id="either-type-error-handling" class="level4">
<h4>Either Type (Error Handling)</h4>
<pre class="lambda"><code># Either represents success/failure
right 42                          # Success value
left &quot;error&quot;                      # Error value

# Either operations
either (λe.0) (λv.v) (right 42)   # 42
either (λe.0) (λv.v) (left &quot;err&quot;) # 0</code></pre>
</section>
</section>
</section>
<section id="infix-operators" class="level2">
<h2>Infix Operators</h2>
<p>Define custom infix operators with precedence and associativity:</p>
<pre class="lambda"><code># Define operators
:infix + 6 left                    # Addition
:infix * 7 left                    # Multiplication (higher precedence)
:infix ^ 8 right                   # Exponentiation (right associative)

# Use infix notation (desugared to function application)
3 + 4 * 5                          # → plus 3 (mult 4 5) = 23
2 ^ 3 ^ 2                          # → exp 2 (exp 3 2) = 512 (right associative)

# Custom operators
:infix &lt;&gt; 5 left
&lt;&gt; = λx y.not (eq x y)
3 &lt;&gt; 4                             # → &lt;&gt; 3 4 → (λx y.not (eq x y)) 3 4 → true</code></pre>
</section>
<section id="operator-precedence--associativity" class="level2">
<h2>Operator Precedence &amp; Associativity</h2>
<p>This section consolidates all precedence and associativity rules the
parser applies (loosest → tightest). Higher numeric precedence binds
tighter for user‑defined infix operators; application (juxtaposition)
always outranks any infix; atoms (parenthesized / literals / identifiers
/ lambdas / lists) are the tightest units.</p>
<p>Global precedence ladder:</p>
<ol type="1">
<li><code>;</code> (top‑level segment separator – not an expression
operator, splits segments)</li>
<li><code>let … in …</code> (right‑associative:
<code>let a = A in let b = B in C</code>)</li>
<li>Arrow (<code>p1, p2 -&gt; body</code>) (right‑associative:
<code>x, y, z -&gt; e</code> ⇒
<code>x -&gt; (y -&gt; (z -&gt; e))</code>)</li>
<li>Infix operators (Pratt parsed by numeric precedence; higher number =
tighter)</li>
<li>Application chaining / composition special operators at precedence 9
(<code>.</code>, <code>∘</code>) – same numeric tier;
right‑associative</li>
<li>Ordinary juxtaposition application (left‑associative) – conceptually
tighter than any infix precedence tier</li>
<li>Atom (identifiers, numerals, lambdas, bracketed lists, parenthesized
expressions)</li>
</ol>
<p>Built‑in operator summary (expanded):</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Kind</th>
<th>Prec</th>
<th>Assoc</th>
<th>Desugaring</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;#124;&gt;</code></td>
<td>pipeline</td>
<td>1</td>
<td>left</td>
<td><code>a &amp;#124;&gt; f</code> ⇒ <code>f a</code></td>
<td>Reads left→right; chains as <code>g (f a)</code></td>
</tr>
<tr>
<td><code>$</code></td>
<td>low-precedence app</td>
<td>1</td>
<td>right</td>
<td><code>f $ x $ y</code> ⇒ <code>f x y</code></td>
<td>Lowest precedence with pipeline; groups from right</td>
</tr>
<tr>
<td><code>.</code></td>
<td>app chaining</td>
<td>9</td>
<td>right</td>
<td><code>f . a . b</code> ⇒ <code>(f a) b</code></td>
<td>Not function composition; just repeated application</td>
</tr>
<tr>
<td><code>∘</code></td>
<td>composition</td>
<td>9</td>
<td>right</td>
<td><code>f ∘ g</code> ⇒ <code>λx.f (g x)</code></td>
<td>Shares precedence with <code>.</code>; prefer parens when
mixing</td>
</tr>
<tr>
<td><code>+</code> (ex)</td>
<td>user infix</td>
<td>6</td>
<td>decl</td>
<td><code>x + y</code> ⇒ <code>plus x y</code></td>
<td>Example (precedence 6)</td>
</tr>
<tr>
<td><code>*</code> (ex)</td>
<td>user infix</td>
<td>7</td>
<td>decl</td>
<td><code>x * y</code> ⇒ <code>mult x y</code></td>
<td>Tighter than <code>+</code></td>
</tr>
<tr>
<td><code>^</code> (ex)</td>
<td>user infix</td>
<td>8</td>
<td>right</td>
<td><code>a ^ b</code> ⇒ <code>exp a b</code></td>
<td>Right-assoc exponent style</td>
</tr>
</tbody>
</table>
<p>Guidelines / subtleties:</p>
<ul>
<li><code>$</code> and <code>|&gt;</code> share the lowest precedence
(1); right vs left associativity changes grouping:
<code>f $ g $ x</code> ⇒ <code>f (g x)</code> while
<code>x |&gt; f |&gt; g</code> ⇒ <code>g (f x)</code>.</li>
<li><code>.</code> and <code>∘</code> intentionally share a high
precedence (9) but differ: <code>f . a . b</code> applies;
<code>f ∘ g</code> composes. They do <strong>not</strong> intermix
without parentheses: <code>f . g ∘ h x</code> parses according to
right‑associativity within the same precedence tier (explicit parens
recommended for clarity).</li>
<li>Plain juxtaposition (application) binds tighter than any infix, so
<code>f x + g y</code> ⇒ <code>(plus (f x) (g y))</code> when
<code>+</code> defined.</li>
<li>Lambda bodies extend rightward: <code>λx.x + y * z</code> groups
infix by their precedence after lambda parameter binding.</li>
<li>Ranges <code>[a .. b]</code> and list literals are atoms; elements
inside respect the same precedence rules.</li>
<li>Composition associativity: <code>f ∘ g ∘ h</code> =
<code>f ∘ (g ∘ h)</code>; chaining associativity: <code>f . g . x</code>
= <code>f . (g . x)</code> ⇒ <code>f (g x)</code>.</li>
<li>To simulate Haskell style <code>$</code> for large expressions, rely
on its lowest precedence: <code>succ $ mult 2 (plus 3 4)</code>.</li>
<li>When mixing pipeline with chaining, remember pipeline groups left
first: <code>a |&gt; f . g</code> parses as <code>(f g) a</code>
<em>not</em> <code>g (f a)</code>; prefer <code>a |&gt; f |&gt; g</code>
or parentheses.</li>
</ul>
<p>Examples:</p>
<pre class="lambda"><code>1 + 2 * 3         # =&gt; 1 + (2 * 3)
f $ g x y         # =&gt; f (g x y)
f . g . 5         # =&gt; f (g 5)
(f ∘ g) x         # =&gt; f (g x)
a |&gt; f |&gt; g       # =&gt; g (f a)
a |&gt; f $ g x      # =&gt; (f $ g x) a  (discouraged; add parens for clarity)</code></pre>
<p>Parentheses always override; prefer them liberally when combining
different precedence tiers.</p>
<section id="built-in-special-operators" class="level3">
<h3>Built-in Special Operators</h3>
<p>The interpreter includes several built-in operators that provide
essential functional programming patterns:</p>
<section id="pipeline-operator-" class="level4">
<h4>Pipeline Operator (<code>|&gt;</code>)</h4>
<p>The pipeline operator enables left-to-right function composition and
data transformation:</p>
<pre class="lambda"><code># Pipeline operator: a |&gt; f |&gt; g desugars to g (f a)
5 |&gt; succ |&gt; mult 2                # → mult 2 (succ 5) = 12

# Compare with nested function calls
mult 2 (succ 5)                    # Same result, but less readable

# Chaining list operations
[1, 2, 3, 4, 5] |&gt; map (mult 2) |&gt; filter (λx.gt x 5)
# → filter (λx.gt x 5) (map (mult 2) [1, 2, 3, 4, 5])
# → [6, 8, 10]

# Data processing pipelines
42 |&gt; pred |&gt; pred |&gt; mult 3       # → mult 3 (pred (pred 42)) = 120</code></pre>
</section>
<section id="function-composition-operator-" class="level4">
<h4>Function Composition Operator (<code>∘</code>)</h4>
<p><code>∘</code> is the dedicated composition operator:
<code>f ∘ g</code> ≡ <code>λx.f (g x)</code>. (The plain dot
<code>.</code> is now only application chaining sugar:
<code>f . a . b</code> ≡ <code>(f a) b</code>).</p>
<pre class="lambda"><code>double = mult 2
increment = succ
doubleInc = double ∘ increment      # → λx.double (increment x)

doubleInc 5                         # → double (increment 5) = 12

# Multiple composition (right-associative)
f ∘ g ∘ h                           # → f (g (h x)) when applied to x

# Creating complex transformations
processNumber = mult 3 ∘ succ ∘ mult 2
processNumber 4                     # → mult 3 (succ (mult 2 4)) = 27

# Function composition in higher-order functions
map (mult 2 ∘ succ) [1, 2, 3]       # → [4, 6, 8]</code></pre>
</section>
<section id="pipeline-vs-composition" class="level4">
<h4>Pipeline vs Composition</h4>
<pre class="lambda"><code># Pipeline: left-to-right data flow (good for data processing)
data |&gt; transform1 |&gt; transform2 |&gt; transform3

# Composition: right-to-left function building (good for creating reusable functions)
complexFunction = transform3 ∘ transform2 ∘ transform1

# Equivalent results:
5 |&gt; succ |&gt; mult 2                # Pipeline
(mult 2 ∘ succ) 5                  # Composition

# Pipeline emphasizes the data flow
# Composition emphasizes function building</code></pre>
</section>
</section>
</section>
<section id="macro-system" class="level2">
<h2>Macro System</h2>
<p>Define reusable patterns with the macro system:</p>
<pre class="lambda"><code># Basic macros (pattern matching and substitution)
:macro (when $cond $body) =&gt; (if $cond $body I)
:macro (unless $cond $body) =&gt; (if $cond I $body)
:macro (square $x) =&gt; (mult $x $x)

# Using macros (expanded at parse time)
when (gt 5 3) (plus 1 2)           # → if (gt 5 3) (plus 1 2) I → 3
unless (iszero 0) 42               # → if (iszero 0) I 42 → I (identity)
square 7                           # → mult 7 7 → 49

# Advanced macros
:macro (for $var at $list do $body) =&gt; (map (λ$var.$body) $list)
for x at [1, 2, 3] do (mult x x)   # → map (λx.mult x x) [1, 2, 3] → [1, 4, 9]</code></pre>
<section id="macro-system-enhancements-recent" class="level3">
<h3>Macro System Enhancements (Recent)</h3>
<p>The macro system has been extended beyond simple one-clause textual
substitution to support more expressive, pattern-driven
transformations:</p>
<ol type="1">
<li><p>Multi‑Clause (Alternation) Macros</p>
<ul>
<li>Multiple definitions may share the same name.</li>
<li>The engine picks the first matching clause using precedence rules
(see Ordering below).
<ul>
<li>Example:</li>
</ul></li>
</ul>
<pre class="lambda"><code>:macro (max2 $a $b) when (geq $a $b) =&gt; $a
:macro (max2 $a $b) =&gt; $b
max2 5 3   # → 5 (guarded clause fires)
max2 2 7   # → 7 (fallback clause)</code></pre></li>
<li><p>Variadic / Rest Patterns</p>
<ul>
<li>Use an ellipsis after a variable at the end of a pattern to capture
zero or more trailing arguments.</li>
<li>Syntax: <code>$xs ...</code> (three-dot ellipsis recognized
lexically).</li>
<li>Captured arguments are provided to the expansion as a list
(Church-encoded list of arguments).
<ul>
<li>Example:</li>
</ul></li>
</ul>
<pre class="lambda"><code>:macro (list $xs ...) =&gt; $xs
list 1 2 3 4   # expands to the list [1,2,3,4]</code></pre></li>
<li><p>Guards</p>
<ul>
<li>Optional <code>when (&lt;expr&gt;)</code> between the pattern and
the <code>=&gt;</code> allows conditional selection among clauses.</li>
<li>Guard expressions can reference pattern variables (e.g.
<code>$a</code>, <code>$b</code>).</li>
<li>A clause only matches if the pattern matches AND the guard does not
evaluate to boolean false.</li>
<li>Example shown in max2 above.</li>
</ul></li>
<li><p>Clause Ordering &amp; Precedence</p>
<ul>
<li>Clauses are ranked by a specificity score so that <strong>more
constrained patterns win over generic ones</strong>.</li>
<li>Specificity factors (current heuristic):
<ul>
<li>Literal symbol or integer literal = high weight</li>
<li>Structural application/list subpattern adds weight (and recursively
includes its children)</li>
<li>Plain variable = neutral; wildcard <code>_</code> = neutral; rest
variable <code>$xs...</code> = slight penalty</li>
<li>Higher total score wins; ties broken by higher arity, then recency
(last defined wins)</li>
</ul></li>
<li>Consequence: <code>(spec (cons 1 $t))</code> beats
<code>(spec $x)</code>; <code>(arity2 ($f $x $y))</code> beats
<code>(arity2 $z)</code>.</li>
</ul></li>
<li><p>Pattern Variable Placeholders</p>
<ul>
<li>During parsing, occurrences of <code>$name</code> in transformation
(and guard) bodies are internally converted to placeholders, ensuring
capture-safe substitution.</li>
<li>Integer literals inside macro bodies are delayed (kept as integers)
until normal expression building, supporting lightweight numeric
macros.</li>
</ul></li>
<li><p>Rest Pattern Constraints</p>
<ul>
<li>At most one rest variable per top-level macro pattern and it must
appear at the end.</li>
<li>Rest capture currently disallowed inside nested structural
subpatterns (planned relaxation).</li>
</ul></li>
<li><p>Structural &amp; Nested Application Patterns (NEW)</p>
<ul>
<li><p>You can match the <em>application spine</em> of an argument using
a parenthesized pattern: <code>(f a b)</code> matches an expression
shaped like <code>((f a) b)</code>.</p></li>
<li><p>Patterns compose recursively, enabling nested destructuring of
list constructors or curried function calls:</p>
<pre class="lambda"><code>:macro (head (cons $h $t)) =&gt; $h
:macro (dropSecond (cons $x (cons _ $rest))) =&gt; (cons $x $rest)
:macro (wrap (plus 0 $x)) =&gt; $x   # structural match against (plus 0 x)
:macro (swapArgs ($f $a $b)) =&gt; ($f $b $a)
:macro (arity2 ($f $x $y)) =&gt; 2
:macro (arity2 $z) =&gt; 0          # fallback</code></pre></li>
<li><p>Each component inside a structural subpattern can itself be a
literal, variable, wildcard, or another structural list.</p></li>
</ul></li>
<li><p>Wildcard Pattern <code>_</code> (NEW)</p>
<ul>
<li>Use <code>_</code> in any pattern position to ignore that
subexpression without binding it.</li>
<li>Example:
<code>:macro (ignoreMiddle (triple $a _ $c)) =&gt; (pair $a $c)</code>.</li>
</ul></li>
<li><p>Integer Literal Patterns (NEW)</p>
<ul>
<li>Integer tokens in patterns (e.g. <code>1</code>, <code>42</code>)
match the corresponding Church numeral only.</li>
<li>Enables precise rewrites like
<code>:macro (spec (cons 1 $t)) =&gt; 1</code> while avoiding accidental
matches on other numerals.</li>
</ul></li>
<li><p>Display / Introspection</p>
<ul>
<li><code>:env macros</code> lists every clause including guard (if
present), structural subpatterns, wildcards, and rest markers
<code>...</code>.</li>
</ul></li>
</ol>
<section id="example-putting-it-together" class="level4">
<h4>Example Putting It Together</h4>
<pre class="lambda"><code>:macro (assert-max $a $b) when (geq $a $b) =&gt; (assert (geq $a $b) $a)
:macro (assert-max $a $b) =&gt; (assert (geq $b $a) $b)
:macro (pipeline $first $rest ...) =&gt; ($rest ... $first)</code></pre>
</section>
</section>
<section id="planned--future-improvements" class="level3">
<h3>Planned / Future Improvements</h3>
<p>These enhancements are on the roadmap to further strengthen the macro
system:</p>
<ul>
<li>Hygiene &amp; gensym (automatic alpha-renaming to prevent variable
capture).</li>
<li>Quasiquote / unquote / splicing for ergonomic macro bodies.</li>
<li>Richer guard semantics (full evaluation + boolean recognition beyond
literal <code>false</code>).</li>
<li>Macro removal / replacement controls (<code>:unmacro</code>, groups,
shadow listing).</li>
<li>Namespacing and selective macro importing.</li>
<li>Nested rest patterns &amp; rest inside structural subpatterns.</li>
<li>Compile-time evaluation blocks and macro-time assertions.</li>
</ul>
</section>
<section id="performance-metrics-reference" class="level3">
<h3>Performance Metrics Reference</h3>
<p>The <code>:stats</code> command now exposes fine‑grained runtime
counters and timers to help you understand performance characteristics
of reductions:</p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>TimeInCacheLookup</td>
<td>Elapsed ticks spent checking the evaluation cache</td>
</tr>
<tr>
<td>TimeInSubstitution</td>
<td>Time spent performing variable substitution / beta-reduction
prep</td>
</tr>
<tr>
<td>TimeInEvaluation</td>
<td>Core CEK evaluation loop time (excluding forcing &amp; cache
lookups)</td>
</tr>
<tr>
<td>TimeInForcing</td>
<td>Time spent forcing (evaluating) thunks in lazy mode</td>
</tr>
<tr>
<td>NormalizeCEKCount</td>
<td>Number of normalization (evaluation) passes completed</td>
</tr>
<tr>
<td>CacheHits</td>
<td>Number of successful cache lookups (expression result reused)</td>
</tr>
<tr>
<td>CacheMisses</td>
<td>Number of times an expression wasn’t cached and had to be
evaluated</td>
</tr>
<tr>
<td>TotalIterations</td>
<td>Cumulative machine steps across all evaluations in the session</td>
</tr>
<tr>
<td>Iterations</td>
<td>Machine steps for the last evaluated top‑level expression</td>
</tr>
<tr>
<td>SubstitutionExprCount</td>
<td>Count of expressions traversed during substitution operations</td>
</tr>
<tr>
<td>ThunkForceCount</td>
<td>How many thunks were forced (realized)</td>
</tr>
<tr>
<td>VarCounter</td>
<td>Internal counter for generating fresh variable names (used for
avoiding clashes)</td>
</tr>
<tr>
<td>MaxRecursionDepth</td>
<td>Safety cut‑off to prevent runaway / infinite recursive
expansions</td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ul>
<li>Timings are raw tick counts (convert with
<code>TimeSpan.FromTicks</code> if needed) and are indicative rather
than absolute wall time.</li>
<li><code>CacheHits</code> vs <code>CacheMisses</code> helps gauge
effectiveness of memoization; a very low hit rate may signal highly
unique expressions.</li>
<li>A rapidly growing <code>SubstitutionExprCount</code> or
<code>Iterations</code> value can indicate a need to refactor or
introduce more sharing.</li>
<li>If you routinely hit the <code>MaxRecursionDepth</code>, consider
refactoring with tail recursion or increasing the limit in code (config
command forthcoming).</li>
</ul>
</section>
</section>
<section id="repl-command-reference" class="level2">
<h2>REPL Command Reference</h2>
<p>This table is synchronized with the interpreter&#39;s internal command
metadata (shown via <code>:help</code>).</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>:clear</td>
<td><code>:clear [macros|defs|ops|cache|all]</code></td>
<td>Clear state (default all). macros, defs, ops (infix), cache
(memoization), or all (env+macros+ops+stats+caches)</td>
</tr>
<tr>
<td>:depth</td>
<td><code>:depth [n]</code></td>
<td>Show or set maximum recursion depth (range 10-10000)</td>
</tr>
<tr>
<td>:env</td>
<td><code>:env [defs|macros|infix|native|all]</code></td>
<td>Display environment (optionally filtered); default all</td>
</tr>
<tr>
<td>:exit</td>
<td><code>:exit | :quit</code></td>
<td>Exit the interpreter</td>
</tr>
<tr>
<td>:help</td>
<td><code>:help</code></td>
<td>Show help summary</td>
</tr>
<tr>
<td>:infix</td>
<td><code>:infix [op prec assoc]</code></td>
<td>Define or list infix operators (assoc = left|right)</td>
</tr>
<tr>
<td>:lazy</td>
<td><code>:lazy on|off</code></td>
<td>Toggle lazy (on) vs eager (off) evaluation</td>
</tr>
<tr>
<td>:load</td>
<td><code>:load &lt;file&gt;</code></td>
<td>Load a .lambda file (may contain defs, macros, infix)</td>
</tr>
<tr>
<td>:log</td>
<td><code>:log &lt;file|off|clear&gt;</code></td>
<td>Log output to file, disable or clear current file</td>
</tr>
<tr>
<td>:macro</td>
<td><code>:macro (&lt;pattern&gt;) =&gt; &lt;body&gt;</code></td>
<td>Define a macro clause (supports guards &amp; rest)</td>
</tr>
<tr>
<td>(cache)</td>
<td><code>:clear cache</code></td>
<td>Clear all memoization caches</td>
</tr>
<tr>
<td>:native</td>
<td><code>:native on|off|show</code></td>
<td>Toggle native arithmetic or list native primitives</td>
</tr>
<tr>
<td>:pretty</td>
<td><code>:pretty on|off</code> / <code>:pp on|off</code></td>
<td>Toggle pretty printing (numerals, lists, booleans)</td>
</tr>
<tr>
<td>:save</td>
<td><code>:save &lt;file&gt;</code></td>
<td>Persist current environment to a file</td>
</tr>
<tr>
<td>:stats</td>
<td><code>:stats</code></td>
<td>Show performance statistics &amp; cache metrics</td>
</tr>
<tr>
<td>:step</td>
<td><code>:step on|off</code></td>
<td>Toggle step-by-step CEK trace output</td>
</tr>
<tr>
<td>:test</td>
<td><code>:test clear</code> / <code>:test result</code></td>
<td>Reset or display structural equality test counters</td>
</tr>
</tbody>
</table>
<p>Tip: After heavy experimentation, run <code>:clear all</code> then
<code>:load stdlib.lambda</code> to restore the baseline library. For
only redefining functions without losing macro/infix definitions use
<code>:clear defs</code>.</p>
</section>
<section id="examples-extended" class="level2">
<h2>Examples (Extended)</h2>
<section id="fibonacci-sequence" class="level3">
<h3>Fibonacci Sequence</h3>
<pre class="lambda"><code># Recursive Fibonacci
fibRec = Y (λf n.if (iszero n) 1 (plus (f (pred n)) (f (pred (pred n)))))

# Iterative Fibonacci (more efficient)
fib 10                             # 89

# Fibonacci sequence
map fib (range 10)                   # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
mapY (n -&gt; [n, (fibY n)]) (range 10) # [[0, 1], [1, 2], [2, 3], [3, 5], [4, 8], [5, 13], [6, 21], [7, 34], [8, 55], [9, 89]]</code></pre>
</section>
<section id="prime-numbers" class="level3">
<h3>Prime Numbers</h3>
<pre class="lambda"><code># Check if number is prime
isPrime 17                         # true
isPrime 15                         # false

# Generate primes up to n
primes 30                          # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# Prime factorization (simplified)
factors = λn.filter (λd.eq (mod n d) 0) (enumFromTo 2 n)
factors 12                         # [2, 3, 4, 6, 12]</code></pre>
</section>
<section id="list-processing" class="level3">
<h3>List Processing</h3>
<pre class="lambda"><code># Process a list of numbers
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Get even squares
evenSquares = map square (filter even numbers)
# Result: [4, 16, 36, 64, 100]

# Sum of squares
sumOfSquares = sum (map square numbers)
# Result: 385

# Complex processing pipeline
result = sum (map square (filter odd (take 5 numbers)))
# Result: 35 (1² + 3² + 5² = 1 + 9 + 25)</code></pre>
</section>
<section id="church-encoding-examples" class="level3">
<h3>Church Encoding Examples</h3>
<pre class="lambda"><code># Church booleans in action
selectValue = λcond.if cond &quot;success&quot; &quot;failure&quot;
selectValue true                   # &quot;success&quot;
selectValue false                  # &quot;failure&quot;

# Church numerals as iterators
applyNTimes = λn f x.n f x
applyNTimes 3 succ 5              # 8 (apply successor 3 times to 5)
applyNTimes 4 (mult 2) 1          # 16 (multiply by 2, 4 times)</code></pre>
</section>
<section id="higher-order-functions" class="level3">
<h3>Higher-Order Functions</h3>
<pre class="lambda"><code># Function composition chain
pipeline = compose (mult 3) (compose (plus 2) square)
pipeline 4                         # 54 ((4²+2)*3 = (16+2)*3 = 54)

# Partial application
add5 = partial plus 5
map add5 [1, 2, 3, 4]              # [6, 7, 8, 9]

# Function combinators
twice = λf x.f (f x)
twice succ 3                       # 5
twice (mult 2) 3                   # 12</code></pre>
</section>
</section>
<section id="advanced-usage" class="level2">
<h2>Advanced Usage</h2>
<p>This section demonstrates sophisticated applications combining
multiple features of the interpreter for real-world functional
programming patterns.</p>
<section id="complex-function-composition-and-pipelines" class="level3">
<h3>Complex Function Composition and Pipelines</h3>
<pre class="lambda"><code># Building sophisticated data processing pipelines (helpers shown all exist)
processNumbers =
    filter (_ &gt; 5) .          # narrow early
    map (square . succ) .     # transform (x+1)^2
    filter (_ &lt; 101)          # emulate upper bound (takeWhile not in stdlib)

processNumbers [1,2,3,4,5,6,7,8,9,10]
# → [49, 64, 81, 100]

# Alternative left-to-right style using the pipeline operator
[1,2,3,4,5,6,7,8,9,10]
    |&gt; filter (_ &gt; 5)
    |&gt; map (square . succ)
    |&gt; filter (_ &lt; 101)

# Combining macros with pipelines
:macro (between $x $low $high) =&gt; (and (geq $x $low) (leq $x $high))
:macro (clamp $min $max $x) =&gt; (if (lt $x $min) $min (if (gt $x $max) $max $x))

processData = 
    map (clamp 0 100) .
    filter (between _ 10 90) .
    map (_ |&gt; mult 2 |&gt; succ)

processData [-5, 15, 25, 105, 75]  # → [31, 51, 151] after clamping, filtering, transforming</code></pre>
<blockquote>
<p>Earlier drafts referenced <code>takeWhile</code>; it is <strong>not
implemented</strong> in the distributed stdlib. Substitute a final
<code>filter</code> (as above) or define your own helper.</p>
</blockquote>
</section>
<section id="advanced-macro-patterns" class="level3">
<h3>Advanced Macro Patterns</h3>
<section id="conceptual-dsl-illustrative--not-in-stdlib" class="level4">
<h4>Conceptual DSL (Illustrative – Not in Stdlib)</h4>
<p>The following macros reference imaginary helpers
(<code>record</code>, <code>get</code>, <code>sortBy</code>,
<code>groupWith</code>, <code>fromList</code>, <code>lookup</code>).
They are <em>not provided</em>; they show how you could layer a DSL on
top.</p>
<pre class="lambda"><code>:macro (from $xs) =&gt; $xs
:macro (where $p) =&gt; (filter $p)
:macro (select $f) =&gt; (map $f)
# :macro (orderBy $k) =&gt; (sortBy $k)        # needs sortBy implementation
# :macro (groupBy $k) =&gt; (groupWith (eq . $k))

# Hypothetical usage once primitives exist:
# people = [ (record &quot;name&quot; &quot;Alice&quot; &quot;age&quot; 30)
#          , (record &quot;name&quot; &quot;Bob&quot;   &quot;age&quot; 25) ]
# from people |&gt; where (λp. gt (get &quot;age&quot; p) 25) |&gt; select (λp. get &quot;name&quot; p)</code></pre>
<p>To make this concrete, choose a representation (e.g. association
lists of key/value string–number pairs) and implement the missing
primitives.</p>
</section>
</section>
<section id="integration-patterns" class="level3">
<h3>Integration Patterns</h3>
<pre class="lambda"><code># Combining all features for a complete application
:macro (app $config $routes) =&gt; (λrequest. dispatch $routes request)
:macro (route $pattern $handler) =&gt; (pair $pattern $handler)

# Web server simulation using lambda calculus
webApp = app 
    (config &quot;port&quot; 8080 &quot;host&quot; &quot;localhost&quot;)
    [
        route &quot;/api/users&quot; (λreq.
            req |&gt; getPath |&gt; parseUserId |&gt; 
            maybe (error404) (λid. 
                users |&gt; find (eq id . getId) |&gt;
                maybe (error404) (toJson))),
        
        route &quot;/api/health&quot; (λ_. ok &quot;Server is healthy&quot;),
        
        route _ (λ_. error404)
    ]

# Request processing pipeline
processRequest = λreq.
    req |&gt; validateHeaders |&gt;
    bind auth |&gt;
    bind (webApp) |&gt;
    either errorResponse successResponse

# This demonstrates how lambda calculus can express
# complex application logic with proper error handling,
# data transformation, and modular design patterns</code></pre>
</section>
</section>
<section id="performance-features" class="level2">
<h2>Performance Features</h2>
<section id="lazy-vs-eager-evaluation-and-macros" class="level3">
<h3>Lazy vs Eager Evaluation and Macros</h3>
<p>Macros expand at parse time before evaluation mode (lazy/eager)
matters. After expansion:</p>
<ul>
<li>Lazy mode (default) defers evaluation of arguments and
macro-expanded bodies until needed.</li>
<li>Switching with <code>:lazy off</code> makes evaluation eager;
previously created thunks are forced as they appear.</li>
<li>Guards in multi-clause macros are evaluated under the current mode
(a false value blocks the clause). Currently, guard evaluation
short‑circuits only if the top-level evaluates to Church false; deeper
reductions still follow normal evaluation semantics.</li>
</ul>
<p>Guidelines:</p>
<ul>
<li>Prefer lazy mode for large or infinite ranges (e.g.
<code>[1 .. 1000000]</code> with <code>take 10</code>).</li>
<li>Disable laziness (<code>:lazy off</code>) when benchmarking
deterministic CPU-heavy pure functions to reduce overhead of thunk
bookkeeping.</li>
<li>If a macro expansion intentionally builds large intermediate
expressions that are immediately consumed, eager mode can expose
performance differences for optimization.</li>
</ul>
</section>
<section id="native-arithmetic" class="level3">
<h3>Native Arithmetic</h3>
<p>When enabled (<code>:native on</code>), the interpreter uses
optimized native operations for Church numerals:</p>
<pre class="lambda"><code># These operations are accelerated when native arithmetic is enabled:
plus, minus, mult, div, mod        # Basic arithmetic
succ, pred, iszero                 # Successor/predecessor
lt, leq, eq, geq, gt, neq          # Comparisons
max, min, sqrt, random             # Additional functions
alphaEq                            # Alpha-equivalence (normalize both; binder names ignored)</code></pre>
<section id="structural-equivalence" class="level4">
<h4>Structural Equivalence</h4>
<p>The interpreter provides an always-on suite of structural comparison
helpers: <code>alphaEq</code>, <code>betaEq</code>, <code>hashEq</code>,
<code>etaEq</code>. These remain active even when
<code>:native off</code> disables arithmetic fast paths. See detailed
table below in the alphaEq subsection.</p>
</section>
<section id="alpha-equivalence-alphaeq" class="level4">
<h4>Alpha Equivalence (alphaEq)</h4>
<p><code>alphaEq</code> is a native helper that returns a Church boolean
(<code>true</code> / <code>false</code>) indicating whether two
expressions are <em>semantically equal up to normalization and
alpha-equivalence</em>.</p>
<blockquote>
<p>Always-On Structural Equivalence Suite</p>
<p>The interpreter ships with a family of structural comparison helpers
that are <strong>always enabled</strong>, independent of the
<code>:native on|off</code> setting (which only affects arithmetic &amp;
comparison speedups):</p>
<table>
<thead>
<tr>
<th>Helper</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alphaEq a b</code></td>
<td>Normalize both expressions; compare modulo binder renaming</td>
</tr>
<tr>
<td><code>betaEq a b</code></td>
<td>Beta-normalize both; then alpha compare (skips raw pre-normalization
shortcut)</td>
</tr>
<tr>
<td><code>hashEq a b</code></td>
<td>Beta-normalize; compare canonical De Bruijn structural hash (fast
approximation)</td>
</tr>
<tr>
<td><code>etaEq a b</code></td>
<td>Beta-normalize; eta-reduce; then alpha compare (captures more
extensional equalities)</td>
</tr>
</tbody>
</table>
<p>Use <code>hashEq</code> for a quick (possibly conservative) equality
screen, and fall back to <code>betaEq</code> / <code>etaEq</code> for
definitive logical equivalence checks depending on whether
eta-extensionality matters.</p>
</blockquote>
<p>Current pipeline (implementation detail, but useful to know):</p>
<ol type="1">
<li>Force thunks on both sides (only as far as needed to expose head
constructors).</li>
<li>Normalize both expressions (bounded beta-reduction with:
<ul>
<li>Inlining of top-level named lambda bindings for deeper combinator
simplification (e.g. <code>K</code>, <code>S</code>, etc.).</li>
<li>Memoization &amp; depth / cycle guards to avoid runaway
expansion.)</li>
</ul></li>
<li>Perform alpha-equivalence comparison (binder names are ignored;
structure &amp; binding topology must match).</li>
<li>If alpha-equivalent normalized forms fail, a fallback direct
structural check on original (pre-normalized) forms may be used for
diagnostics.</li>
</ol>
<p>Characteristics:</p>
<ul>
<li>Ignores superficial binder name differences:
<code>alphaEq (λx.x) (λy.y)</code> → <code>true</code>.</li>
<li>Distinguishes genuinely different structure (no eta-reduction:
<code>λx.f x</code> ≠ <code>f</code>).</li>
<li>Reduces common combinator compositions so higher-order identities
hold (e.g. <code>(S K K) v</code> equals <code>v</code>).</li>
<li>Treats Church-encoded lists and their explicit
<code>cons</code>/<code>nil</code> forms uniformly only after
normalization; distinct encodings that do not normalize to the same
shape still differ.</li>
</ul>
</section>
</section>
</section>
<section id="native-list-primitives" class="level2">
<h2>Native List Primitives</h2>
<p>The interpreter provides a set of optional native (host-implemented)
list helpers for performance. They are enabled/disabled together with
arithmetic via <code>:native on|off</code> (structural equality natives
remain always-on). Each native attempts a fast-path structural
pattern-match on a concrete <code>cons</code>/<code>nil</code> chain. If
the argument does not match the expected shape or any element fails
conversion (for numeric folds), the native returns <code>null</code> so
that a pure lambda version (from <code>stdlib.lambda</code>) can run
instead.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Aliases</th>
<th>Arity</th>
<th>Behavior</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>length xs</code></td>
<td>–</td>
<td>1</td>
<td>Returns Church numeral length</td>
<td>O(n) eager traversal</td>
</tr>
<tr>
<td><code>append a b</code></td>
<td><code>concat</code></td>
<td>2</td>
<td>Concatenate two lists</td>
<td>Rebuilds new list (no mutation)</td>
</tr>
<tr>
<td><code>reverse xs</code></td>
<td>–</td>
<td>1</td>
<td>Reverse list</td>
<td>Uses accumulator (O(n))</td>
</tr>
<tr>
<td><code>map f xs</code></td>
<td>–</td>
<td>2</td>
<td>Apply <code>f</code> to each element</td>
<td>Eager; may allocate new list</td>
</tr>
<tr>
<td><code>filter p xs</code></td>
<td>–</td>
<td>2</td>
<td>Keep elements where <code>p x</code> is Church true</td>
<td>Predicate coerced via Church boolean shape (λt.λf.t/f)</td>
</tr>
<tr>
<td><code>take n xs</code></td>
<td>–</td>
<td>2</td>
<td>First <code>n</code> elements</td>
<td>If <code>n</code> &gt; length returns whole list</td>
</tr>
<tr>
<td><code>drop n xs</code></td>
<td>–</td>
<td>2</td>
<td>Remove first <code>n</code> elements</td>
<td>If <code>n</code> &gt; length returns <code>nil</code></td>
</tr>
<tr>
<td><code>any p xs</code></td>
<td>–</td>
<td>2</td>
<td>Church true if any element passes</td>
<td>Short-circuits on first true</td>
</tr>
<tr>
<td><code>all p xs</code></td>
<td>–</td>
<td>2</td>
<td>Church true if all pass</td>
<td>Short-circuits on first false</td>
</tr>
<tr>
<td><code>find p xs</code></td>
<td><code>findFirst</code></td>
<td>2</td>
<td>Returns <code>(just x)</code> for first match else
<code>nothing</code></td>
<td>Uses maybe constructors from stdlib</td>
</tr>
<tr>
<td><code>sum xs</code></td>
<td>–</td>
<td>1</td>
<td>Sum of numeric elements</td>
<td>Fallback if any non-numeric element</td>
</tr>
<tr>
<td><code>product xs</code></td>
<td>–</td>
<td>1</td>
<td>Product of elements (empty =&gt; 1)</td>
<td>Early-exits on 0</td>
</tr>
</tbody>
</table>
<p>Failure / Fallback (native returns null -&gt; pure stdlib variant
used):</p>
<ul>
<li>Non <code>cons</code>/<code>nil</code> structure encountered</li>
<li>Arity mismatch (pre-checked)</li>
<li>For
<code>map</code>/<code>filter</code>/<code>any</code>/<code>all</code>/<code>find</code>:
predicate result not a Church boolean (shape probe fails)</li>
<li>For <code>sum</code>/<code>product</code>: element not a Church
numeral</li>
</ul>
<p>Design Rationale: Returning null instead of throwing keeps semantics
extensible—user code can shadow or augment behavior with alternative
representations (e.g., Church lists, lazy streams) without losing
functionality.</p>
<p>Inspection: <code>:env native</code> and <code>:native show</code>
enumerate these under category <code>list</code> with aliases and
doc.</p>
<ul>
<li>Safe for recursive definitions via Y so long as expansion reaches a
stable normalized comparison within the configured limits.</li>
</ul>
<p>Instrumentation:</p>
<ul>
<li>Every <code>alphaEq</code> invocation increments counters
(<code>StructEqCalls</code>, <code>StructEqSuccesses</code>).</li>
<li>View with <code>:test result</code>, reset with
<code>:test clear</code>.</li>
<li>Useful for tracking test coverage density in large spec suites.</li>
</ul>
<p>Practical examples:</p>
<pre class="lambda"><code>alphaEq (pair 1 (cons 2 nil)) (pair 1 (cons 2 nil))          # true
alphaEq [1,2,3] (cons 1 (cons 2 (cons 3 nil)))               # true
alphaEq (λx.plus x 1) (λy.plus y 1)                          # true (alpha-insensitive)
alphaEq (λx.plus x 1) (λy.plus y (succ 0))                   # false (different body after norm)
alphaEq ((S K K) 5) 5                                        # true (combinator reduces)
alphaEq (λx.f x) f                                           # false (no eta)</code></pre>
<p>Notes &amp; Limits:</p>
<ul>
<li>Not an extensional (eta-complete) equality: add your own eta rule if
needed.</li>
<li>Normalization is bounded; extremely large self-expanding macros may
yield a conservative <code>false</code> if forms cannot be fully reduced
within limits.</li>
<li>Designed for test/regression usage rather than user-facing proof of
equivalence.</li>
</ul>
<p>If you require different equivalence semantics (e.g. eta-equivalence
or observational equivalence), layer a custom checker on top of
normalized forms.</p>
<section id="structural-equality-helper-families" class="level3">
<h3>Structural Equality Helper Families</h3>
<p>For standard encodings you can use lighter-weight structural
comparators instead of full normalization:</p>
<table>
<thead>
<tr>
<th>Helper</th>
<th>Purpose</th>
<th>Informal Signature</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>listEq</code></td>
<td>Deep list equality</td>
<td><code>(eqE -&gt; list a -&gt; list a -&gt; Bool)</code></td>
</tr>
<tr>
<td><code>pairEq</code></td>
<td>Pair equality</td>
<td><code>(eqA -&gt; eqB -&gt; pair a b -&gt; pair a b -&gt; Bool)</code></td>
</tr>
<tr>
<td><code>maybeEq</code></td>
<td>Maybe equality</td>
<td><code>(eqA -&gt; Maybe a -&gt; Maybe a -&gt; Bool)</code></td>
</tr>
<tr>
<td><code>eitherEq</code></td>
<td>Either equality</td>
<td><code>(eqL -&gt; eqR -&gt; Either l r -&gt; Either l r -&gt; Bool)</code></td>
</tr>
</tbody>
</table>
<p>Macro wrappers (<code>testList</code>, <code>testPair</code>,
<code>testMaybe</code>, <code>testEither</code>, and *By variants)
delegate to these.</p>
<section id="lazy-helpers--benchmarking" class="level4">
<h4>Lazy Helpers &amp; Benchmarking</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>delay</code></td>
<td>Wrap a value into a thunk <code>(λf.f value)</code></td>
</tr>
<tr>
<td><code>force</code></td>
<td>Force a thunk: <code>force (delay x) = x</code></td>
</tr>
<tr>
<td><code>benchmark n f x</code></td>
<td>Apply <code>f</code> to <code>x</code> <code>n</code> times (simple
micro benchmark)</td>
</tr>
<tr>
<td><code>memoize</code></td>
<td>Currently identity (placeholder for future caching layer)</td>
</tr>
</tbody>
</table>
</section>
<section id="state-monad-encapsulated-state" class="level4">
<h4>State Monad (Encapsulated State)</h4>
<p>State is encoded as functions
<code>s -&gt; pair value newState</code>.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>returnState</code></td>
<td>Lift pure value</td>
</tr>
<tr>
<td><code>bindState</code></td>
<td>Monadic bind / sequencing</td>
</tr>
<tr>
<td><code>getState</code></td>
<td>Read current state</td>
</tr>
<tr>
<td><code>putState</code></td>
<td>Replace state (returns unit-like <code>nil</code>)</td>
</tr>
<tr>
<td><code>runState</code></td>
<td>Execute a stateful computation</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre class="lambda"><code>increment = λs.pair (succ s) (succ s)
runState increment 5      # → pair 6 6</code></pre>
</section>
<section id="loop-combinator-while" class="level4">
<h4>Loop Combinator (WHILE)</h4>
<p><code>WHILE cond body initial</code> repeatedly applies
<code>body</code> while <code>cond current</code> is true.</p>
<pre class="lambda"><code>countDown = WHILE (λn.gt n 0) pred 5   # → 0</code></pre>
</section>
<section id="additional-numeric--utility-functions" class="level4">
<h4>Additional Numeric / Utility Functions</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ackermann</code></td>
<td>Fast-growing benchmark function (use small arguments)</td>
</tr>
<tr>
<td><code>clamp min max x</code></td>
<td>Bound value to inclusive range</td>
</tr>
</tbody>
</table>
</section>
<section id="safe-operation-summary" class="level4">
<h4>Safe Operation Summary</h4>
<table>
<thead>
<tr>
<th>Function</th>
<th>Returns</th>
<th>Empty / Error Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>safehead</code></td>
<td><code>just x</code> / <code>nothing</code></td>
<td>Empty → <code>nothing</code></td>
</tr>
<tr>
<td><code>safetail</code></td>
<td><code>just tail</code> / <code>nothing</code></td>
<td>Empty → <code>nothing</code></td>
</tr>
<tr>
<td><code>safenth n l</code></td>
<td><code>just (nth n)</code> / <code>nothing</code></td>
<td>OOB index → <code>nothing</code></td>
</tr>
<tr>
<td><code>safediv a b</code> / <code>safeDiv</code></td>
<td><code>just q</code></td>
<td><code>nothing</code> if divisor = 0</td>
</tr>
<tr>
<td><code>safeMinimum</code></td>
<td><code>just min</code></td>
<td>Empty → <code>nothing</code></td>
</tr>
<tr>
<td><code>safeMaximum</code></td>
<td><code>just max</code></td>
<td>Empty → <code>nothing</code></td>
</tr>
<tr>
<td><code>safeInit</code></td>
<td>list (not Maybe)</td>
<td>Empty or singleton → <code>nil</code></td>
</tr>
<tr>
<td><code>safeInitMaybe</code></td>
<td><code>just prefix</code> / <code>nothing</code></td>
<td>Empty or singleton → <code>nothing</code></td>
</tr>
</tbody>
</table>
<p>Chain with <code>maybe</code>, <code>maybeMap</code>, or a custom
bind pattern.</p>
</section>
</section>
<section id="caching-and-memoization" class="level3">
<h3>Caching and Memoization</h3>
<p>The interpreter includes multiple caching layers:</p>
<ul>
<li><strong>Substitution cache</strong>: Speeds up variable
substitution</li>
<li><strong>Evaluation cache</strong>: Memoizes expression
evaluation</li>
<li><strong>Free variable cache</strong>: Caches free variable
analysis</li>
<li><strong>Expression interning</strong>: Reduces memory usage</li>
</ul>
</section>
<section id="statistics-and-monitoring" class="level3">
<h3>Statistics and Monitoring</h3>
<p>Use <code>:stats</code> to view detailed performance information:</p>
<pre class="shell"><code>:stats
# Shows cache hit rates, evaluation counts, memory usage, etc.</code></pre>
</section>
</section>
<section id="step-tracing--debugging" class="level2">
<h2>Step Tracing &amp; Debugging</h2>
<p>Enable detailed CEK reductions with:</p>
<pre class="shell"><code>:step on</code></pre>
<p>You will see <code>Step</code> lines (green/yellow in CLI, class
<code>log-step</code> in Web UI) for each continuation application or
reduction. Combine with <code>:pretty off</code> for raw lambda
forms.</p>
<table>
<thead>
<tr>
<th>Technique</th>
<th>Command(s)</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enable tracing</td>
<td><code>:step on</code></td>
<td>Show each evaluation step</td>
</tr>
<tr>
<td>Disable tracing</td>
<td><code>:step off</code></td>
<td>Return to concise mode</td>
</tr>
<tr>
<td>Inspect environment</td>
<td><code>:env</code></td>
<td>Verify bindings contributing to steps</td>
</tr>
<tr>
<td>Abort multi-line input</td>
<td><code>:cancel</code></td>
<td>Prevent accidental huge traces</td>
</tr>
</tbody>
</table>
<p>Common pattern to isolate a problematic expansion:</p>
<pre class="shell"><code>:clear all; :load stdlib.lambda; :step on; :pretty off
mySuspiciousExpr</code></pre>
<p>Turn tracing off immediately once you&#39;ve captured enough lines to
avoid performance overhead.</p>
</section>
<section id="performance-cookbook" class="level2">
<h2>Performance Cookbook</h2>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Recommended Setup</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pure lambda benchmarking</td>
<td><code>:lazy off; :native off; :pretty off</code></td>
<td>Removes thunk + native shortcut overhead</td>
</tr>
<tr>
<td>Demonstrate laziness</td>
<td><code>:lazy on; take 10 [0 .. 1000000]</code></td>
<td>Shows finite prefix of huge range</td>
</tr>
<tr>
<td>Maximizing cache hits</td>
<td>Evaluate same function repeatedly then <code>:stats</code></td>
<td>Observe CacheHits growth</td>
</tr>
<tr>
<td>Macro expansion audit</td>
<td><code>:pretty off; :step on</code> once</td>
<td>Inspect raw expanded forms</td>
</tr>
<tr>
<td>Structural regression tests</td>
<td>Use <code>alphaEq</code> in macros + <code>:test result</code></td>
<td>Track success count trend</td>
</tr>
</tbody>
</table>
<p>Quick timing heuristic: compare <code>Iterations</code> between
implementations of the same function (e.g., naive vs tail-recursive)
under identical settings.</p>
</section>
<section id="embedding--programmatic-api" class="level2">
<h2>Embedding &amp; Programmatic API</h2>
<p>Minimal embedding example:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> logger <span class="op">=</span> <span class="kw">new</span> LambdaCalculus<span class="op">.</span><span class="fu">Logger</span> <span class="op">{</span> EnableBuffering <span class="op">=</span> <span class="kw">true</span> <span class="op">};</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> interp <span class="op">=</span> <span class="kw">new</span> LambdaCalculus<span class="op">.</span><span class="fu">Interpreter</span><span class="op">(</span>logger<span class="op">:</span> logger<span class="op">);</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>await interp<span class="op">.</span><span class="fu">LoadFileIfExistsAsync</span><span class="op">(</span><span class="st">&quot;stdlib.lambda&quot;</span><span class="op">);</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="fu">var</span> <span class="op">(</span>ast<span class="op">,</span> value<span class="op">)</span> <span class="op">=</span> await interp<span class="op">.</span><span class="fu">ProcessInputAsync</span><span class="op">(</span><span class="st">&quot;succ 41&quot;</span><span class="op">);</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>Console<span class="op">.</span><span class="fu">WriteLine</span><span class="op">(</span>interp<span class="op">.</span><span class="fu">Format</span><span class="op">(</span>value<span class="op">));</span> <span class="co">// 42</span></span></code></pre></div>
<p>Registering a native primitive:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>interp<span class="op">.</span><span class="fu">RegisterNativeFunction</span><span class="op">(</span><span class="st">&quot;triple&quot;</span><span class="op">,</span> <span class="op">(</span>op<span class="op">,</span> args<span class="op">,</span> env<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>args<span class="op">.</span><span class="fu">Count</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> interp<span class="op">.</span><span class="fu">TryGetChurchInt</span><span class="op">(</span>args<span class="op">[</span><span class="dv">0</span><span class="op">],</span> env<span class="op">,</span> <span class="kw">out</span> <span class="dt">var</span> n<span class="op">))</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> interp<span class="op">.</span><span class="fu">MakeChurchNumeral</span><span class="op">(</span>n <span class="op">*</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">null</span><span class="op">;</span> <span class="co">// Not handled</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="op">});</span></span></code></pre></div>
<p>Chained processing (commands + expression):</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>await interp<span class="op">.</span><span class="fu">ProcessInputAsync</span><span class="op">(</span><span class="st">&quot;:lazy off; :native on; plus 20 22&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Buffered logs:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode csharp"><code class="sourceCode cs"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">foreach</span> <span class="op">(</span><span class="dt">var</span> line <span class="kw">in</span> logger<span class="op">.</span><span class="fu">GetBufferSnapshot</span><span class="op">())</span> Console<span class="op">.</span><span class="fu">WriteLine</span><span class="op">(</span>line<span class="op">);</span></span></code></pre></div>
</section>
<section id="multi-user--deployment-strategies" class="level2">
<h2>Multi-user &amp; Deployment Strategies</h2>
<p>Current Web UI: single shared interpreter instance (stateful).
Options to scale:</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Isolation</th>
<th>Outline</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Per-request new instance</td>
<td>Full</td>
<td>Instantiate <code>Interpreter</code> per eval</td>
<td>No state bleed</td>
<td>High GC &amp; start cost</td>
</tr>
<tr>
<td>Session-scoped</td>
<td>Medium</td>
<td>Dictionary keyed by session ID; expire LRU</td>
<td>Persistent user state</td>
<td>Cleanup complexity</td>
</tr>
<tr>
<td>Pooled</td>
<td>Medium</td>
<td>Pool of warm interpreters; <code>:clear</code> before checkout</td>
<td>Amortized init</td>
<td>Risk of incomplete reset</td>
</tr>
<tr>
<td>Stateless eval service</td>
<td>Logical</td>
<td>Reject definitions; evaluate single expr with ephemeral env</td>
<td>Horizontal scaling</td>
<td>Loses interactive definitions</td>
</tr>
</tbody>
</table>
<p>Hardening checklist:</p>
<ul>
<li>Enforce max iterations / time (wrap <code>ProcessInputAsync</code>
with cancellation).</li>
<li>Limit macro clause count + expansion depth.</li>
<li>Restrict file load paths (whitelist) for <code>:load</code> /
<code>/api/load</code>.</li>
<li>Add auth &amp; rate limiting at reverse proxy.</li>
</ul>
<p>Observability: subscribe to
<code>Logger.Subscribe(line =&gt; Forward(line));</code> to pipe logs to
structured telemetry (ensure async, non-blocking).</p>
</section>
<section id="building-and-running" class="level2">
<h2>Building and Running</h2>
<section id="documentation-generation-pandoc" class="level3">
<h3>Documentation Generation (Pandoc)</h3>
<p>The build script can generate a styled <code>readme.html</code> (and
optionally other docs like <code>help.html</code>) for the Web UI. This
requires <strong>Pandoc</strong> to be installed and available on your
<code>PATH</code>.</p>
<p>Pandoc is NOT bundled. If it is missing the script will emit an error
and skip HTML generation.</p>
<p>Install options (choose one):</p>
<p>Windows (Chocolatey):</p>
<pre><code>choco install pandoc</code></pre>
<p>Windows (Winget):</p>
<pre><code>winget install --id JohnMacFarlane.Pandoc -e</code></pre>
<p>macOS (Homebrew):</p>
<pre><code>brew install pandoc</code></pre>
<p>Linux (Debian/Ubuntu):</p>
<pre><code>sudo apt-get update &amp;&amp; sudo apt-get install -y pandoc</code></pre>
<p>Verify:</p>
<pre><code>pandoc --version</code></pre>
<p>Generation happens automatically during <code>build.ps1</code>
execution; output is copied into
<code>src-webui/wwwroot/readme.html</code> (and CSS if present).
Customize styling via <code>readme.css</code> (expected beside
<code>build.ps1</code>).</p>
<p>If you change <code>README.md</code>, re-run the build script (or
manually invoke <code>pandoc</code> with the same flags) to refresh the
Web UI copy.</p>
</section>
<section id="prerequisites-build--run" class="level3">
<h3>Prerequisites (Build &amp; Run)</h3>
<ul>
<li>.NET 8.0 or later</li>
<li>C# compiler</li>
</ul>
</section>
<section id="building" class="level3">
<h3>Building</h3>
<div class="sourceCode" id="cb90"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build the project</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> build</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Run in development mode</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> run</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Build release version</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> build <span class="at">-c</span> Release</span></code></pre></div>
</section>
<section id="running" class="level3">
<h3>Running</h3>
<div class="sourceCode" id="cb91"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Start interactive mode</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./lambda-cek</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Load specific files</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="ex">./lambda-cek</span> stdlib.lambda tests.lambda</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Run with native arithmetic enabled by default</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a><span class="ex">./lambda-cek</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a><span class="ex">:native</span> on</span></code></pre></div>
<p>The interpreter automatically loads <code>stdlib.lambda</code> if it
exists in the current directory, providing access to the full standard
library.</p>
</section>
</section>
<section id="file-format" class="level2">
<h2>File Format</h2>
<p>Lambda files (<code>.lambda</code> extension) support:</p>
<ul>
<li>Lambda expressions and definitions</li>
<li>Comments (lines starting with <code>#</code> or text after
<code>#</code>)</li>
<li>Multi-line expressions</li>
<li>Macro definitions</li>
<li>Infix operator definitions</li>
</ul>
<p>Example file structure:</p>
<pre class="lambda"><code># My lambda file
# Define some utilities
id = λx.x
compose = λf g x.f (g x)

# Define infix operators
:infix ∘ 9 right
∘ = compose

# Use the definitions
twice = f -&gt; f ∘ f
result = twice succ 5  # 7</code></pre>
<p>This interpreter provides a complete environment for exploring lambda
calculus, functional programming concepts, and advanced language
features while maintaining high performance through lazy evaluation and
intelligent caching.</p>
</section>
<section id="pretty-printing" class="level2">
<h2>Pretty Printing</h2>
<p>The interpreter includes an optional pretty-print layer (enabled by
default) that rewrites common Church encodings into familiar surface
forms for readability.</p>
<section id="what-it-formats" class="level3">
<h3>What It Formats</h3>
<ol type="1">
<li>Church numerals<br />
Structure: <code>λf.λx.f^n x</code> rendered as the decimal integer
<code>n</code>. Example: <code>λf.λx.f (f (f x))</code> →
<code>3</code>.</li>
<li>Church booleans<br />
<code>λa.λb.a</code> → <code>true</code>, <code>λa.λb.b</code> →
<code>false</code> (variable names may differ; the structure determines
the value).</li>
<li>cons / nil lists<br />
Nested applications of <code>cons</code> ending in <code>nil</code>
render as <code>[a, b, c]</code>.<br />
Example: <code>cons 1 (cons 2 (cons 3 nil))</code> →
<code>[1, 2, 3]</code>.</li>
<li>Church-encoded lists<br />
<code>λf.λz.f a1 (f a2 (... (f an z)))</code> also renders as
<code>[a1, a2, ..., an]</code>.</li>
<li>Thunks<br />
Unforced: <code>&lt;thunk: ...&gt;</code><br />
Forced: <code>&lt;forced: renderedValue&gt;</code></li>
<li>Cycles / repeated references<br />
Already-visited nodes during printing show as <code>&lt;cycle&gt;</code>
to avoid infinite output.</li>
</ol>
</section>
<section id="booleans-vs-conditionals" class="level3">
<h3>Booleans vs Conditionals</h3>
<p>Only the canonical Church boolean forms print as <code>true</code> /
<code>false</code>. Any other two-argument selector (e.g.
<code>λx.λy.y x</code>) keeps its raw lambda form.</p>
</section>
<section id="truncation" class="level3">
<h3>Truncation</h3>
<p>Very large output is truncated at 5000 characters with a
<code>... (output truncated)</code> suffix to protect the REPL.</p>
</section>
<section id="toggling" class="level3">
<h3>Toggling</h3>
<p>Use the command:</p>
<pre class="shell"><code>:pretty off   # Show raw lambda structures
:pretty on    # Re‑enable formatting</code></pre>
<p>Disabling pretty printing is useful for debugging structural
differences or confirming alpha‐conversion results.</p>
</section>
<section id="pretty-printing-examples" class="level3">
<h3>Pretty Printing Examples</h3>
<table>
<thead>
<tr>
<th>Raw Form</th>
<th>Pretty Printed</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>λf.λx.x</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>λf.λx.f (f x)</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>λa.λb.a</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>λp.λq.q</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>cons 1 (cons 2 nil)</code></td>
<td><code>[1, 2]</code></td>
</tr>
<tr>
<td><code>λf.λz.f 4 (f 5 (f 6 z))</code></td>
<td><code>[4, 5, 6]</code></td>
</tr>
<tr>
<td><code>&lt;thunk: λf.λx.f x&gt;</code> (unforced)</td>
<td><code>&lt;thunk: 1&gt;</code></td>
</tr>
<tr>
<td><code>&lt;forced: λf.λx.f (f x)&gt;</code> (already forced)</td>
<td><code>&lt;forced: 2&gt;</code></td>
</tr>
</tbody>
</table>
</section>
<section id="limitations--notes" class="level3">
<h3>Limitations / Notes</h3>
<ul>
<li>Church numeral detection currently expects the exact two‑abstraction
shape; if you manually construct numerals with additional wrapping
lambdas they will not collapse to integers.</li>
<li>Boolean detection is name-agnostic: <code>λt.λf.f</code> still
prints <code>false</code>.</li>
<li>If you redefine <code>cons</code> or <code>nil</code> to
non-standard meanings, list rendering may become misleading.</li>
<li>Extremely deep or cyclic structures may show
<code>&lt;cycle&gt;</code> early to prevent runaway traversal.</li>
<li>Pretty printing is orthogonal to evaluation; disabling it does not
change semantics or performance of normalization/evaluation (aside from
minor formatting cost).</li>
</ul>
</section>
<section id="when-to-turn-it-off" class="level3">
<h3>When to Turn It Off</h3>
<p>Disable with <code>:pretty off</code> when:</p>
<ul>
<li>Verifying the <em>exact</em> lambda structure (e.g., in macro
expansion debugging).</li>
<li>Measuring performance without the formatting overhead (minor but
measurable for very large outputs).</li>
<li>Teaching / demonstrations where raw encodings are pedagogically
important.</li>
</ul>
<p>Re‑enable with <code>:pretty on</code> once finished.</p>
<hr />
</section>
</section>
<section id="project-overview" class="level2">
<h2>Project Overview</h2>
<p>This project is a high-performance, feature-rich lambda calculus
interpreter implemented in C#. It is designed for students, researchers,
and enthusiasts interested in functional programming, language theory,
and interpreter implementation. The interpreter is based on the CEK
(Control, Environment, Kontinuation) machine model, supporting both lazy
and eager evaluation, a macro system, infix operators, and a
comprehensive standard library.</p>
<p><strong>Goals:</strong></p>
<ul>
<li>Provide a practical and educational tool for exploring lambda
calculus and functional programming concepts.</li>
<li>Offer a modern, extensible playground for experimenting with
language features, macros, and evaluation strategies.</li>
<li>Achieve high performance through native optimizations and
intelligent caching.</li>
</ul>
</section>
<section id="how-it-works" class="level2">
<h2>How It Works</h2>
<p><strong>Evaluation Engine:</strong></p>
<ul>
<li>The interpreter uses a CEK machine, which models computation as a
stack of states (control, environment, continuation). This enables
efficient evaluation, supports both strict and lazy semantics, and makes
it easy to implement advanced features like thunks and
continuations.</li>
</ul>
<p><strong>Lazy vs. Eager Evaluation:</strong></p>
<ul>
<li>By default, the interpreter uses lazy evaluation (thunks), only
computing values when needed. You can switch to eager evaluation with
<code>:lazy off</code>.</li>
</ul>
<p><strong>Macros and Infix Operators:</strong></p>
<ul>
<li>Macros are expanded at parse time, allowing for powerful syntactic
abstractions and domain-specific language features. Infix operators are
user-definable with custom precedence and associativity, parsed using a
Pratt parser.</li>
</ul>
<p><strong>Standard Library:</strong></p>
<ul>
<li>The standard library (<code>stdlib.lambda</code>) is loaded
automatically and provides a rich set of combinators, arithmetic, list
operations, and more.</li>
</ul>
<p>For more theoretical background, see <code>THEORY.md</code>.</p>
</section>
<section id="contributing" class="level2">
<h2>Contributing</h2>
<p>Contributions are welcome! To get started:</p>
<ol type="1">
<li><p><strong>Clone the repository and build:</strong></p>
<div class="sourceCode" id="cb94"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone <span class="op">&lt;</span>repo-url<span class="op">&gt;</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> lambda-cek-Y</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="ex">dotnet</span> build</span></code></pre></div></li>
<li><p><strong>Run tests:</strong></p>
<ul>
<li>(Add instructions here if you have a test suite, e.g.,
<code>dotnet test</code>)</li>
</ul></li>
<li><p><strong>Style guidelines:</strong></p>
<ul>
<li>Use clear, descriptive names and add comments for new features.</li>
<li>Keep code modular; new primitives or macros should be added in their
respective files.</li>
</ul></li>
<li><p><strong>Adding features:</strong></p>
<ul>
<li>To add new primitives, see <code>Interpreter.Eval.cs</code>.</li>
<li>For new macros or infix operators, update <code>stdlib.lambda</code>
or use the REPL.</li>
</ul></li>
<li><p><strong>Pull requests:</strong></p>
<ul>
<li>Please describe your changes and reference any related issues.</li>
</ul></li>
</ol>
</section>
<section id="troubleshooting--faq" class="level2">
<h2>Troubleshooting &amp; FAQ</h2>
<p><strong>Q: I get an &#39;Evaluation exceeded maximum iterations&#39;
error.</strong> A: This usually means your code has an infinite loop or
non-terminating recursion. Check for missing base cases or undefined
variables.</p>
<p><strong>Q: Why do I get a parse error about semicolons or
commas?</strong> A: Semicolons are only allowed at the top level. Commas
must separate parameters or list elements, not appear at the end or in
the wrong context.</p>
<p><strong>Q: How do I debug my code?</strong> A: Use
<code>:step on</code> for step-by-step evaluation, <code>:stats</code>
for performance info, and <code>:log &lt;file&gt;</code> to log output.
Disable pretty printing with <code>:pretty off</code> to see raw
structures.</p>
<p><strong>Q: How do I add new native functions?</strong> A: Extend the
<code>TryNativeArithmetic</code> method in
<code>Interpreter.Eval.cs</code>.</p>
<p><strong>Q: How do I reset the environment?</strong> A: Use
<code>:clear</code> (or <code>:clear all</code>) to reset everything, or
selectively <code>:clear defs</code> / <code>:clear macros</code> /
<code>:clear ops</code>.</p>
</section>
<section id="design-decisions" class="level2">
<h2>Design Decisions</h2>
<ul>
<li><p><strong>CEK Machine:</strong> Chosen for its clarity and
efficiency in modeling lambda calculus evaluation, supporting both
strict and lazy semantics.</p></li>
<li><p><strong>Church Encoding:</strong> Used for numbers, booleans, and
lists to stay true to pure lambda calculus, with pretty-printing for
usability.</p></li>
<li><p><strong>C# Implementation:</strong> Leverages .NET performance,
strong typing, and modern tooling.</p></li>
<li><p><strong>Extensibility:</strong> Macro and infix systems allow
users to extend the language without modifying the core interpreter.
<strong>Current Limitations (Updated):</strong></p></li>
<li><p>No floating-point or rational literal support yet (only Church
integers; extension planned).</p></li>
<li><p>No hygienic macro system or quasiquotation (planned).</p></li>
<li><p>Module/import system absent (single global environment unless
manually isolated).</p></li>
<li><p>Error objects are string-based (structured diagnostics
planned).</p></li>
<li><p>Sandboxing (timeouts, memory quotas) not yet enforced—use caution
in multi-user setups.</p></li>
<li><p>Pattern matching construct (<code>match</code>) not yet
implemented (macros approximate use cases).</p></li>
</ul>
</section>
<section id="license" class="level2">
<h2>License</h2>
<p>This project is licensed under the MIT License. See
<code>LICENSE</code> for details.</p>
</section>
<section id="distribution--packaging-new" class="level2">
<h2>Distribution &amp; Packaging (New)</h2>
<p>Artifacts planned / available:</p>
<ul>
<li>NuGet package: <code>LambdaCalculus.Interpreter</code> (core
library, CEK evaluator, parser, macros). Install with:
<code>dotnet add package LambdaCalculus.Interpreter</code></li>
<li>CLI tool project (<code>src-cli</code>) provides interactive REPL
(build: <code>dotnet run --project src-cli</code>).</li>
<li>Web host (<code>src-web</code> / <code>src-webui</code>) serves
browser UI.</li>
</ul>
<section id="roadmap" class="level3">
<h3>Roadmap</h3>
<ul>
<li>Add GitHub Actions workflow to pack &amp; push NuGet on tagged
release.</li>
<li>Provide minimal JS interop API (evaluate, normalize, stats) for
embedding.</li>
</ul>
</section>
</section>
<section id="build--run-guide" class="level2">
<h2>Build &amp; Run Guide</h2>
<p>This section summarizes how to build and run each form of the
interpreter: core library (NuGet), CLI, Web API, and Web UI.</p>
<section id="prerequisites" class="level3">
<h3>Prerequisites</h3>
<ul>
<li>.NET 8 SDK (required). Optional: .NET 9 preview for multi-target
build; ignore preview warning if not needed.</li>
<li>PowerShell (examples assume Windows <code>pwsh</code>).</li>
<li>(Optional) Docker Desktop for container build of Web UI.</li>
</ul>
</section>
<section id="1-core-library-nuget-package" class="level3">
<h3>1. Core Library (NuGet Package)</h3>
<p>Build only:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>dotnet build src<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">csproj</span> <span class="op">-</span>c Release</span></code></pre></div>
<p>Pack (produces <code>.nupkg</code> in <code>artifacts</code>):</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>dotnet pack src<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">csproj</span> <span class="op">-</span>c Release <span class="op">-</span>o artifacts</span></code></pre></div>
<p>Override version:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>dotnet pack src<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">csproj</span> <span class="op">-</span>c Release <span class="op">-</span>o artifacts <span class="op">/</span>p<span class="op">:</span>PackageVersion<span class="op">=</span><span class="dv">0.1</span><span class="op">.</span><span class="dv">1</span></span></code></pre></div>
<p>Consume in another project:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>dotnet add package LambdaCalculus<span class="op">.</span><span class="fu">Interpreter</span> <span class="op">--</span>version <span class="dv">0.1</span><span class="op">.</span><span class="dv">0</span></span></code></pre></div>
</section>
<section id="2-cli-repl-src-cli" class="level3">
<h3>2. CLI REPL (<code>src-cli</code>)</h3>
<p>Run (Debug):</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">--</span>project src-cli<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">cli</span><span class="op">.</span><span class="fu">csproj</span></span></code></pre></div>
<p>Run (Release):</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">-</span>c Release <span class="op">--</span>project src-cli<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">cli</span><span class="op">.</span><span class="fu">csproj</span></span></code></pre></div>
<p>Load extra lambda files at startup:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">--</span>project src-cli<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">cli</span><span class="op">.</span><span class="fu">csproj</span> <span class="op">--</span> mydefs<span class="op">.</span><span class="fu">lambda</span> tests<span class="op">.</span><span class="fu">lambda</span></span></code></pre></div>
<p>Inside REPL: use <code>:help</code>, exit with <code>:quit</code> /
<code>:exit</code>.</p>
</section>
<section id="3-web-api-src-web" class="level3">
<h3>3. Web API (<code>src-web</code>)</h3>
<p>Starts a minimal HTTP host (e.g., evaluation endpoints if
implemented):</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">--</span>project src-web<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">web</span><span class="op">.</span><span class="fu">csproj</span></span></code></pre></div>
<p>If HTTPS dev cert not trusted:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>dotnet dev-certs https <span class="op">--</span>trust</span></code></pre></div>
<p>Override URL/port:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">--</span>project src-web<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">web</span><span class="op">.</span><span class="fu">csproj</span> <span class="op">--</span> <span class="op">--</span>urls http<span class="op">://</span>localhost<span class="op">:</span><span class="dv">5055</span></span></code></pre></div>
</section>
<section id="4-web-ui-src-webui" class="level3">
<h3>4. Web UI (<code>src-webui</code>)</h3>
<p>Interactive browser-based REPL with multi-tab output, search,
filters.</p>
<p>Run:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">--</span>project src-webui<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">webui</span><span class="op">.</span><span class="fu">csproj</span></span></code></pre></div>
<p>Navigate to the printed local URL (commonly <a href="http://localhost:5000">http://localhost:5000</a>).</p>
<section id="docker-build-web-ui" class="level4">
<h4>Docker Build (Web UI)</h4>
<p>Using the build script (includes Docker unless
<code>-NoDocker</code>):</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="op">./</span>build<span class="op">.</span><span class="fu">ps1</span></span></code></pre></div>
<p>Manual build &amp; run:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>docker build <span class="op">-</span>t lambda-cek-webui <span class="op">-</span>f src-webui<span class="op">/</span>Dockerfile <span class="op">.</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>docker run <span class="op">-</span>p <span class="dv">8080</span><span class="op">:</span><span class="dv">8080</span> <span class="op">--</span>name lambda-cek-webui lambda-cek-webui</span></code></pre></div>
<p>Open <a href="http://localhost:8080">http://localhost:8080</a>.</p>
</section>
</section>
<section id="5-unified-build-script-buildps1" class="level3">
<h3>5. Unified Build Script (<code>build.ps1</code>)</h3>
<p>Examples:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build everything + pack NuGet + build Docker image</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="op">./</span>build<span class="op">.</span><span class="fu">ps1</span> <span class="op">-</span>Pack</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Skip Docker</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="op">./</span>build<span class="op">.</span><span class="fu">ps1</span> <span class="op">-</span>Pack <span class="op">-</span>NoDocker</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Validate package content &amp; abort if missing files</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="op">./</span>build<span class="op">.</span><span class="fu">ps1</span> <span class="op">-</span>Pack <span class="op">-</span>Validate</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Continue pack even if validation fails</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a><span class="op">./</span>build<span class="op">.</span><span class="fu">ps1</span> <span class="op">-</span>Pack <span class="op">-</span>Validate <span class="op">-</span>SkipPackOnError</span></code></pre></div>
<p>Outputs:</p>
<ul>
<li>NuGet package → <code>artifacts/*.nupkg</code></li>
<li>Docker image → <code>lambda-cek-webui</code> (run with
<code>docker run -p 8080:8080 lambda-cek-webui</code>)</li>
</ul>
</section>
<section id="7-running-testslambda" class="level3">
<h3>7. Running <code>tests.lambda</code></h3>
<p>CLI:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode powershell"><code class="sourceCode powershell"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>dotnet run <span class="op">--</span>project src-cli<span class="op">/</span>lambda-cek<span class="op">.</span><span class="fu">cli</span><span class="op">.</span><span class="fu">csproj</span> <span class="op">--</span> tests<span class="op">.</span><span class="fu">lambda</span></span></code></pre></div>
<p>In REPL: <code>:load tests.lambda</code></p>
</section>
<section id="8-troubleshooting" class="level3">
<h3>8. Troubleshooting</h3>
<table>
<thead>
<tr>
<th>Issue</th>
<th>Cause</th>
<th>Fix</th>
</tr>
</thead>
<tbody>
<tr>
<td>NU5019 README not found</td>
<td>Wrong relative path in <code>.csproj</code></td>
<td>Confirm <code>src/lambda-cek.csproj</code> uses
<code>..\README.md</code></td>
</tr>
<tr>
<td>NETSDK1057 preview warning</td>
<td>net9.0 preview</td>
<td>Ignore or remove <code>net9.0</code> from
<code>TargetFrameworks</code></td>
</tr>
<tr>
<td>HTTPS trust prompt</td>
<td>Dev cert untrusted</td>
<td><code>dotnet dev-certs https --trust</code></td>
</tr>
<tr>
<td>Port in use</td>
<td>Conflict with existing process</td>
<td>Use <code>--urls</code> to pick another port</td>
</tr>
</tbody>
</table>
</section>
<section id="9-quick-command-reference" class="level3">
<h3>9. Quick Command Reference</h3>
<table>
<thead>
<tr>
<th>Target</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Build all</td>
<td><code>dotnet build -c Release</code></td>
</tr>
<tr>
<td>Pack</td>
<td><code>dotnet pack src/lambda-cek.csproj -c Release -o artifacts</code></td>
</tr>
<tr>
<td>CLI REPL</td>
<td><code>dotnet run --project src-cli/lambda-cek.cli.csproj</code></td>
</tr>
<tr>
<td>Web UI</td>
<td><code>dotnet run --project src-webui/lambda-cek.webui.csproj</code></td>
</tr>
<tr>
<td>Web API</td>
<td><code>dotnet run --project src-web/lambda-cek.web.csproj</code></td>
</tr>
<tr>
<td>Docker image</td>
<td><code>docker build -t lambda-cek-webui -f src-webui/Dockerfile .</code></td>
</tr>
</tbody>
</table>
<hr />
</section>
</section>
</section>
</body>
</html>
