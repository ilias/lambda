# Church encoding of lambda calculus

# Logical/Boolean functions
true = λx.λy.x
false = λx.λy.y
not = λp.p false true
and = λp.λq.p q p
or = λp.λq.p true q
xor = λp.λq.p (not q) q
nand = λp.λq.not (and p q)         # NAND
nor = λp.λq.not (or p q)          # NOR
implies = λp.λq.or (not p) q      # Implication (p → q)
if = λp.λa.λb.p a b
eq-bool = λx.λy.x y (not y)
neq-bool = λx.λy.not (eq-bool x y) # Boolean not-equal

all = λl.foldl and true l    # Returns true if all elements are true
any = λl.foldl or false l    # Returns true if any element is true

# Church numerals and arithmetic
0 = λf.λx.x
1 = λf.λx.f x
2 = λf.λx.f (f x)
3 = λf.λx.f (f (f x))
4 = λf.λx.f (f (f (f x)))
5 = λf.λx.f (f (f (f (f x))))
6 = λf.λx.f (f (f (f (f (f x)))))
7 = λf.λx.f (f (f (f (f (f (f x))))))
8 = λf.λx.f (f (f (f (f (f (f (f x)))))))
9 = λf.λx.f (f (f (f (f (f (f (f (f x))))))))
zero = λf.λx.x
succ = λn.λf.λx.f (n f x)
pred = λn.λf.λx. n (λg.λh. h (g f)) (λu.x) (λu.u)
plus = λm.λn.λf.λx.m f (n f x)
double = λn.plus n n              # Double (n*2)
mult = λm.λn.λf.m (n f)
square = λn.mult n n              # Square (n*n)
exp = λm.λn.n m
iszero = λn.n (λx.false) true
minus = λm.λn.n pred m
half = λn.n (λx.λy.y) 0           # Integer division by 2 (using Church numerals)
max = λm.λn.if (leq m n) n m      # Maximum
min = λm.λn.if (leq m n) m n      # Minimum
even = λn.iszero (mod n 2)        # Even predicate
odd = λn.not (even n)             # Odd predicate

# Comparison
leq = λm.λn.iszero (minus m n)
eq = λm.λn.and (leq m n) (leq n m)
gt = λm.λn.not (leq m n)
geq = λm.λn.not (lt m n)
lt = λm.λn.and (leq m n) (not (eq m n))

# Combinators
K = λx.λy.x            # K (Kestrel, constant)
I = λx.x               # I (Identity)
S = λx.λy.λz.x z (y z) # S (Substitution)
B = λx.λy.λz.x (y z)   # B (Composition)
C = λx.λy.λz.x z y     # C (Flip)
W = λx.λy.x y y        # W (Duplication)
M = λx.x x             # M (Mockingbird)
Y = λf.(λx.f (x x)) (λx.f (x x)) # Y (Fixed-point)
Z = λf.(λx.f (λv.x x v)) (λx.f (λv.x x v)) # Z (applicative-order Y combinator)
Ω = (λx.x x) (λx.x x)  # Ω (Omega, infinite loop)

# Pairs
pair = λx.λy.λf.f x y
first = λp.p (λx.λy.x)
second = λp.p (λx.λy.y)
swap = λp.p (λx.λy.y x) (λx.λy.x y)

# Lists
nil = λx.λy.x                           # Empty list
cons = λx.λy.λf.f x y                   # Create a list node with head x and tail y
head = λl.l (λx.λy.x)                   # Extract the first element
tail = λl.l (λx.λy.y)                   # Extract the rest of the list
nth = λl.λn. head (n tail l)            # Returns the nth element of a list (0-based)

# Higher-order list operations
append = λl1.λl2.l1 (λx.λy.cons x (append y l2)) l2   # Append l2 to l1
map = λf.λl.l (λx.λy.cons (f x) (map f y)) nil        # Apply f to each element
filter = λf.λl.l (λx.λy.if (f x) (cons x (filter f y)) (filter f y)) nil  # Keep elements satisfying f
foldr = λf.λz.λl.l (λx.λy.f x (foldr f z y)) z        # Fold from right with initial value z
foldl = λf.λz.λl.l (λx.λy.y (f z x)) z                # Fold from left with initial value z
length = λl.foldl (λx.λy.succ x) 0 l                  # Count elements
reverse = λl.foldl (λx.λy.cons y x) nil l             # Reverse list order

# Arithmetic functions (recursive)
fact = λn.if (iszero n) 1 (mult n (fact (pred n)))
fib = λn.if (iszero n) 0 (if (eq n 1) 1 (plus (fib (pred n)) (fib (pred (pred n)))))

# Utility and convenience functions
id-num = λn.n (λx.succ x) 0                # Identity for Church numerals
bool-to-num = λb.b 1 0                     # Boolean to Church numeral
ispos = λn.not (iszero n)                  # Is positive (n > 0)
isnil = λl.l (λx.λy.false) true             # Checks if a list is nil
singleton = λx.cons x nil                  # Singleton list
compose = λf.λg.λx.f (g x)                 # Function composition
flip = λf.λx.λy.f y x                      # Flip arguments
make-pair = pair                           # Alias for pair
swap-pair = swap                           # Alias for swap
sub = λm.λn.n pred m                       # Alias for minus
isone = λn.eq n 1                          # Is one predicate
map-pair = λf.λp. pair (f (first p)) (f (second p))   # Applies f to both elements of a pair

# Iterate n times to build up Fibonacci value
FIB_ITER_HELPER = λn.n (λp.pair (second p) (plus (first p) (second p))) (pair 0 1)
FIB_ITER = λn.first (FIB_ITER_HELPER n)

# Iterative factorial (like FIB_ITER)
FACT_ITER_HELPER = λp. pair (pred (first p)) (mult (first p) (second p))
FACT_ITER = λn. second (n FACT_ITER_HELPER (pair n 1))

# Iterative division and modulo (no Y combinator)
DIV_ITER_HELPER = λn.λp. if (lt (first p) n) p (pair (minus (first p) n) (succ (second p)))
div = λm.λn. second (m (DIV_ITER_HELPER n) (pair m 0))

MOD_ITER_HELPER = λn.λp. if (lt (first p) n) p (pair (minus (first p) n) 0)
mod = λm.λn. first (m (MOD_ITER_HELPER n) (pair m 0))

# Iterative map-with-index (no Y combinator)
MWI_HELPER = λf.λp. \
  pair \
    (pair (tail (first (first p))) (succ (second (first p)))) \
    (cons (f (second (first p)) (head (first (first p)))) (second p))

map-with-index = λf.λl. \
  reverse (second (length l (MWI_HELPER f) (pair (pair l 0) nil)))

sum = λl.foldl plus 0 l      # Sums all elements in the list
product = λl.foldl mult 1 l  # Multiplies all elements in the list

num-to-list = λn. n (λxs. cons true xs) nil   # Converts a Church numeral to a list of n trues

