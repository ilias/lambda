# =============================================================================
# BOOLEAN OPERATIONS

# =============================================================================

id       = λx.x 
true     = λx y.x 
false    = λx y.y 
and      = λp q.p q false 
not      = λp.p false true 
or       = λp q.p true q 
xor      = λp q.p (not q) q 
if       = λp a b.p a b 
eqBool   = λx y.x y (not y)

# =============================================================================
# CHURCH NUMERALS
# =============================================================================

zero     = λf x.x
succ     = λn f x.f (n f x)
pred     = λn f x.n (λg h.h (g f)) (λu.x) (λu.u) 
plus     = λm n f x.m f (n f x)
mult     = λm n f.m (n f)    
iszero   = λn.n (λx.false) true
exp      = Y (λf. λb n. if (iszero n) 1 (mult b (f b (pred n))))
minus    = λm n.n pred m

# =============================================================================
# DIVISION AND MODULO (more efficient iterative implementation)
# =============================================================================

# Iterative division helper. Returns a pair (quotient, remainder).
# It works by repeatedly subtracting n from m.
DIV_ITER = Y(λf. λq m n. \
    if (lt m n) \
        (pair q m)\
        (f (succ q) (minus m n) n)\
)

div = λm n. first (DIV_ITER 0 m n)
mod = λm n. second (DIV_ITER 0 m n)

# =============================================================================
# COMPARISON OPERATIONS
# =============================================================================

leq      = λm n.iszero (minus m n)
eq       = λm n.and (leq m n) (leq n m)
gt       = λm n.not (leq m n)
geq      = λm n.not (lt m n)
lt       = λm n.and (leq m n) (not (eq m n))
neq      = λm n.not (eq m n)                  # Not equal

# =============================================================================
# ADDITIONAL NUMERIC OPERATIONS
# =============================================================================

abs      = λn.n                               # Absolute value (Church numerals are non-negative)
max      = λm n.if (geq m n) m n              # Maximum of two numbers
min      = λm n.if (leq m n) m n              # Minimum of two numbers
even     = λn.eq (mod n 2) zero               # Check if number is even
odd      = λn.not (even n)                    # Check if number is odd
square   = λn.mult n n                        # Square a number
double   = λn.plus n n                        # Double a number
half     = λn.div n 2                         # Half a number (integer division)
pow      = exp                                # Power (alias for exp)

# =============================================================================
# NUMERIC RANGES AND SEQUENCES
# =============================================================================
range = λn. Y (λf k. if (eq k n) nil (cons k (f (succ k)))) 0  # Generate [0, 1, ..., n-1]
countdown = λn. Y (λf k. if (iszero k) (cons 0 nil) (cons k (f (pred k)))) n  # Generate [n, n-1, ..., 0]

# =============================================================================
# COMBINATORS
# =============================================================================

K        = λx y.x
I        = λx.x
S        = λx y z.x z (y z)
B        = λx y z.x (y z)
C        = λx y z.x z y
#Y        = λf.(λx.f (x x)) (λx.f (x x))

# =============================================================================
# ADDITIONAL COMBINATORS AND UTILITIES
# =============================================================================

const    = K                                # Constant function (alias for K)
compose  = B                                # Function composition (alias for B)
flip     = C                                # Flip arguments (alias for C)
apply    = λf x.f x                         # Function application
curry    = λf x y.f (pair x y)              # Curry a function
uncurry  = λf p.f (first p) (second p)      # Uncurry a function
on       = λop f x y.op (f x) (f y)         # Apply function to both args before operation
#fix      = Y                                # Fixed point combinator (alias for Y)

# =============================================================================
# CONDITIONAL UTILITIES
# =============================================================================

when     = λp f x.if p (f x) x              # Apply function conditionally
unless   = λp f x.if p x (f x)              # Apply function unless condition
cond     = λp t e.if p t e                  # Alias for if for readability

# =============================================================================
# PAIR OPERATIONS
# =============================================================================

pair     = λx y f.f x y
first    = λp.p (λx y.x)
second   = λp.p (λx y.y)
swap     = λp.λf.p (λx y.f y x)

# =============================================================================
# BASIC LIST OPERATIONS
# =============================================================================

nil      = λf z.z                              # Empty list
isnil    = λl.l (λx xs.false) true             # Check if list is empty
cons     = λx xs f z.f x (xs f z)              # Create a list node with head x and tail xs
head     = λl.l (λx xs.x) nil                  # Extract the first element
tail     = λl.first (l (λx p.pair (second p) (cons x (second p))) (pair nil nil)) # Extract the rest of the list

# =============================================================================
# HIGHER-ORDER LIST OPERATIONS (iterative implementations)
# =============================================================================

append   = λl1 l2.l1 cons l2
map      = λf l.l (λx rest.cons (f x) rest) nil
filter   = λf l.l (λx rest.if (f x) (cons x rest) rest) nil
foldr    = λf z l.l f z
foldl    = λf z l.foldr (λx g acc.g (f acc x)) (λy.y) l z
length   = λl.foldr (λx acc.succ acc) zero l
reverse  = λl.foldl (λacc x.cons x acc) nil l

# =============================================================================
# ADDITIONAL LIST OPERATIONS
# =============================================================================

isempty  = λl.l (λx xs.false) true        # Check if list is empty
last     = λl.head (reverse l)            # Get last element of list
init     = λl.reverse (tail (reverse l))  # Get all but last element
take     = λn l.n (λf prev.if (isempty prev) nil \
                              (cons (head prev) (f (tail prev)))) \
                  (λx.nil) l
drop     = λn l.n tail l                  # Drop first n elements
nth      = λn l.head (drop n l)           # Get nth element (0-indexed)
any      = λl.foldr or false l     # True if any element satisfies predicate
all      = λl.foldr and true l     # True if all elements satisfy predicate
sum      = λl.foldr plus zero l           # Sum all elements
product  = λl.foldr mult 1 l              # Product of all elements
maximum  = λl.foldr (λx acc.if (gt x acc) x acc) zero l    # Maximum element
minimum  = λl.tail l (foldr (λx acc.if (lt x acc) x acc) (head l) (tail l)) (head l)  # Minimum element
concat   = λll.foldr append nil ll        # Concatenate list of lists

# =============================================================================
# ITERATIVE COMPUTATIONAL HELPERS
# =============================================================================

FACT_ITER_HELPER = λn.n (λp.pair (succ (first p)) \
                                  (mult (succ (first p)) (second p))) \
                         (pair 0 1)
fact             = λn.second (FACT_ITER_HELPER n)

FIB_ITER_HELPER  = λn.n (λp.pair (second p) \
                                  (plus (first p) (second p))) \
                         (pair 0 1)
fib              = λn.first (FIB_ITER_HELPER n)

factRec = Y (\f.\n. if (iszero n) 1 (mult n (f (pred n))))

fibRec = Y (\f.\n. if (iszero n) 1 (plus (f (pred n)) (f (pred (pred n)))))

sumUptoRec = Y (\f.\n.if (iszero n) 0 (plus n (f (pred n)))) # Recursive sum of numbers up to n

# =============================================================================
# ADDITIONAL COMPUTATIONAL FUNCTIONS
# =============================================================================

# A proper WHILE loop combinator
WHILE = Y (λloop. λcond body state. if (cond state) (loop cond body (body state)) state)

# GCD using the Euclidean algorithm with the WHILE combinator
GCD_STEP = λp. if (gt (first p) (second p)) \
                 (pair (minus (first p) (second p)) (second p)) \
                 (pair (first p) (minus (second p) (first p)))

gcd1 = λm n. if (or (iszero m) (iszero n)) (if (iszero m) n m) \
    (first (WHILE (λp. neq (first p) (second p)) GCD_STEP (pair m n)))


# Robust GCD and LCM definitions
gcd = Y (λg a b. if (iszero b) a (g b (mod a b)))  # Euclidean algorithm
lcm = λa b. if (or (iszero a) (iszero b)) 0 (div (mult a b) (gcd a b))

factorial        = fact                                       # Alias for fact
fibonacci        = fib                                        # Alias for fib

# =============================================================================
# ITERATION UTILITIES
# =============================================================================

iterate          = λf n x.n f x                              # Apply function n times to x
repeat           = λn x.n (const x) x                        # Create list with n copies of x
replicate        = repeat                                    # Alias for repeat
times            = λn f.n f I                                # Apply function n times (composition)

# =============================================================================
# LIST GENERATION
# =============================================================================

iota             = range                                      # Alias for range
enumFromTo       = λstart end.map (plus start) \
                                   (range (succ (minus end start)))  # [start..end]
enumFrom         = λstart n.map (plus start) (range n)        # n numbers starting from start

# =============================================================================
# ADVANCED LIST UTILITIES (safe, non-recursive implementations)
# =============================================================================

# Safe zip using foldr instead of recursion
zip              = λl1 l2.reverse (foldl (λacc p.if (isempty (second p)) acc \
                                                     (cons (pair (head (first p)) (head (second p))) acc)) \
                                          nil \
                                          (foldl (λacc x.cons (pair (drop (length acc) l1) \
                                                                    (drop (length acc) l2)) acc) \
                                                 nil (range (min (length l1) (length l2)))))

# Safe zipWith using map and zip
zipWith          = λf l1 l2.map (λp.f (first p) (second p)) (zip l1 l2)

# Simplified transpose - just take first elements, no recursion
transpose        = λll.if (or (isempty ll) (any isempty ll)) nil \
                          (cons (map head ll) nil)  # Only do first row to avoid recursion

# Safe intercalate using foldr
intercalate      = λsep l.if (isempty l) nil \
                             (if (isempty (tail l)) (head l) \
                                 (foldr (λx acc.if (isempty acc) x (append x (cons sep acc))) \
                                        nil l))

# Safe intersperse using foldr  
intersperse      = λx l.if (isempty l) nil \
                           (if (isempty (tail l)) l \
                               (foldr (λy acc.if (isempty acc) (cons y nil) \
                                                               (cons y (cons x acc))) \
                                      nil l))

# Safe nub using foldl - remove duplicates iteratively
nub              = λl.foldl (λacc x.if (elem x acc) acc (cons x acc)) nil l

unique           = nub                                     # Alias for nub
elem             = λx l.any (eq x) l                       # Check if element is in list
notElem          = λx l.not (elem x l)                     # Check if element is not in list

# Safe find using foldr instead of recursion
find             = λp l.foldr (λx acc.if (and (p x) (isempty acc)) x acc) nil l

partition        = λp l.pair (filter p l) (filter (λx.not (p x)) l)
splitAt          = λn l.pair (take n l) (drop n l)

# Safe break using foldr - find break point iteratively
break            = λp l.foldl (λacc x.if (p x) acc \
                                       (pair (cons x (first acc)) (second acc))) \
                              (pair nil l) l

words            = λl.filter (λw.not (isempty w)) (break is-space l)  # Simplified split on whitespace
lines            = λl.filter (λw.not (isempty w)) (break (eq 10) l)   # Simplified split on newlines
unwords          = λl.intercalate (cons 32 nil) l          # Join with spaces
unlines          = λl.intercalate (cons 10 nil) l          # Join with newlines

# =============================================================================
# ADVANCED NUMERIC FUNCTIONS
# =============================================================================

# Iterative square root using Newton's method with bounded iterations
SQRT_ITER_HELPER = λn guess limit.limit (λp.if (leq (abs (minus (mult (first p) (first p)) n)) (first p)) \
                                                      p \
                                                      (pair (half (plus (first p) (div n (first p)))) (second p))) \
                                          (pair guess guess)
sqrt             = λn.if (iszero n) zero (first (SQRT_ITER_HELPER n n n))  # Bounded iterations

# Simple prime check using trial division up to sqrt(n)
isPrime = Y (λf n. \
    let iter = Y (λiter i. \
        if (gt (mult i i) n) true \
        (if (eq (mod n i) 0) false \
            (iter (succ i))) \
    ) in \
    if (lt n 2) false (iter 2) \
)

primes           = λn.filter isPrime (enumFromTo 2 n)       # Generate primes up to n

# =============================================================================
# SET OPERATIONS ON LISTS (treating lists as sets)
# =============================================================================

union            = λl1 l2.append l1 (filter (λx.notElem x l1) l2)
intersect        = λl1 l2.filter (λx.elem x l2) l1
difference       = λl1 l2.filter (λx.notElem x l2) l1
isSubset         = λl1 l2.all (λx.elem x l2) l1
isSuperset       = λl1 l2.isSubset l2 l1

# =============================================================================
# TREE DATA STRUCTURES (using pairs and lists - safe implementations)
# =============================================================================

# Binary tree: nil | (pair value (pair left right))
leaf             = λv.pair v (pair nil nil)                  # Create a leaf node
node             = λv l r.pair v (pair l r)                  # Create an internal node
treeValue        = first                                     # Get value of tree node
treeLeft         = λt.first (second t)                       # Get left subtree
treeRight        = λt.second (second t)                      # Get right subtree
isLeaf           = λt.and (isempty (treeLeft t)) (isempty (treeRight t))

# Safe tree size - limited depth to prevent infinite recursion
treeSize         = λt.if (isempty t) zero 1  # Simplified: just count if not empty

# Safe tree depth - limited depth  
treeDepth        = λt.if (isempty t) zero 1  # Simplified: constant depth

# Safe tree traversals - only visit immediate children to avoid recursion
inOrder          = λt.if (isempty t) nil \
                         (cons (treeValue t) nil)  # Simplified: just return value

preOrder         = λt.if (isempty t) nil \
                         (cons (treeValue t) nil)  # Simplified: just return value

postOrder        = λt.if (isempty t) nil \
                         (cons (treeValue t) nil)  # Simplified: just return value

# =============================================================================
# OPTIONAL/MAYBE TYPE (using pairs)
# =============================================================================

# nothing = nil, just x = pair true x
nothing          = nil
just             = λx.pair true x
isNothing        = isempty
isJust           = λm.not (isNothing m)
fromJust         = second
maybe            = λdef f m.if (isNothing m) def (f (fromJust m))

# =============================================================================
# EITHER TYPE (using pairs)
# =============================================================================

# left x = pair false x, right x = pair true x
left             = λx.pair false x
right            = λx.pair true x
isLeft           = λe.not (first e)
isRight          = first
fromLeft         = second
fromRight        = second
either           = λf g e.if (isLeft e) (f (fromLeft e)) (g (fromRight e))

# =============================================================================
# STATE MONAD HELPERS (using pairs for state)
# =============================================================================

returnState      = λx s.pair x s
bindState        = λm f s.f (first (m s)) (second (m s))  # Simplified without let
getState         = λs.pair s s
putState         = λs.λ_.pair nil s
runState         = λm s.m s

# =============================================================================
# IO SIMULATION (using lists for demonstration)
# =============================================================================

putChar          = λc.cons c
getChar          = head
putStr           = append
getLine          = λl.filter (neq 10) l              # Take until newline (simplified)

# =============================================================================
# DEBUGGING AND UTILITY FUNCTIONS
# =============================================================================

trace            = λmsg x.x                                 # Identity function for tracing (no-op in pure lambda)
debug            = trace                                    # Alias for trace  
undefined        = Y I                                      # Infinite loop (represents undefined value)
error            = undefined                                # Alias for undefined

# =============================================================================
# PERFORMANCE TESTING HELPERS
# =============================================================================

benchmark        = λn f x.times n (λ_.f x) x                # Run function n times
timeIt           = benchmark                                # Alias for benchmark

# =============================================================================
# ADVANCED COMBINATORS
# =============================================================================

omega            = λx.x x                                   # Self-application
#omega2           = omega omega                              # Infinite loop
mockingbird      = λf.f f                                   # M combinator (same as omega)
thrush           = λx f.f x                                 # T combinator (reverse application)
cardinal         = flip                                     # Cardinal (same as flip/C)
bluebird         = compose                                  # Bluebird (same as compose/B)
kestrel          = const                                    # Kestrel (same as const/K)
warbler          = λf x.f x x                               # W combinator
starling         = S                                        # Starling (same as S)

# =============================================================================
# FUNCTION UTILITIES
# =============================================================================

memoize          = λf.f                                     # Identity (true memoization requires mutation)
curry3           = λf x y z.f (pair x (pair y z))           # Curry a 3-argument function
uncurry3         = λf t.f (first t) (first (second t)) \
                          (second (second t))               # Uncurry a 3-argument function
partial          = λf x.λy.f x y                            # Partial application
partial2         = λf x y.λz.f x y z                        # Partial application of first 2 args

# =============================================================================
# ADDITIONAL LIST UTILITIES (safe, non-recursive implementations)
# =============================================================================

scanl    = λf z l.reverse (foldl (λacc x.cons (f (head acc) x) acc) (cons z nil) l)
scanr    = λf z l.foldr (λx acc.cons (f x (head acc)) acc) (cons z nil) l

findIndex = λp l.foldl (λacc x.if (and (isempty acc) (p x)) (cons (length acc) nil) acc) nil l
elemIndex = λx l.findIndex (eq x) l

unzip    = λl.pair (map first l) (map second l)

fromMaybe = λdef m.if (isNothing m) def (fromJust m)
maybeMap  = λf m.if (isNothing m) nothing (just (f (fromJust m)))

clamp    = λmin max x.if (lt x min) min (if (gt x max) max x)

# =============================================================================
# IMPROVED EXISTING FUNCTIONS
# =============================================================================

# minimum and maximum: handle empty lists gracefully
safeMinimum = λl.if (isempty l) nothing (just (foldr (λx acc.if (lt x acc) x acc) (head l) (tail l)))
safeMaximum = λl.if (isempty l) nothing (just (foldr (λx acc.if (gt x acc) x acc) (head l) (tail l)))

# init: handle single-element and empty lists
safeInit = λl.if (isempty l) nil (reverse (tail (reverse l)))

# reverse: add comment for clarity
# reverse = λl.foldl (λacc x.cons x acc) nil l  # Already present, iterative and safe

# =============================================================================
# ADDITIONAL FUNCTION UTILITIES
# =============================================================================

id2      = λx.x  # Alias for id, for clarity
const2   = λx y.x  # Alias for const/K

# =============================================================================
# INFIX OPERATORS
# =============================================================================

+ = plus
- = minus
* = mult
/ = div
^ = exp
% = mod
:infix + 6 left
:infix - 6 left 
:infix * 7 left
:infix / 7 left
:infix % 7 left
:infix ^ 8 right

&& = and
|| = or
^^ = xor
== = eq
!= = neq
<  = lt
<= = leq
>  = gt
>= = geq
:infix && 3 left
:infix || 2 left
:infix ^^ 3 left
:infix == 4 left
:infix != 4 left
:infix <  5 left
:infix <= 5 left
:infix >  5 left
:infix >= 5 left



