# Church encoding of lambda calculus

# Logical/Boolean functions
true = λx.λy.x
false = λx.λy.y
not = λp.p false true
and = λp.λq.p q p
or = λp.λq.p true q
xor = λp.λq.p (not q) q
nand = λp.λq.not (and p q)         # NAND
nor = λp.λq.not (or p q)          # NOR
implies = λp.λq.or (not p) q      # Implication (p → q)
if = λp.λa.λb.p a b
eq-bool = λx.λy.x y (not y)
neq-bool = λx.λy.not (eq-bool x y) # Boolean not-equal

# Church numerals and arithmetic
0 = λf.λx.x
1 = λf.λx.f x
2 = λf.λx.f (f x)
3 = λf.λx.f (f (f x))
4 = λf.λx.f (f (f (f x)))
5 = λf.λx.f (f (f (f (f x))))
6 = λf.λx.f (f (f (f (f (f x)))))
7 = λf.λx.f (f (f (f (f (f (f x))))))
8 = λf.λx.f (f (f (f (f (f (f (f x)))))))
9 = λf.λx.f (f (f (f (f (f (f (f (f x))))))))
zero = λf.λx.x
succ = λn.λf.λx.f (n f x)
pred = λn.λf.λx. n (λg.λh. h (g f)) (λu.x) (λu.u)
plus = λm.λn.λf.λx.m f (n f x)
double = λn.plus n n              # Double (n*2)
mult = λm.λn.λf.m (n f)
square = λn.mult n n              # Square (n*n)
exp = λm.λn.n m
iszero = λn.n (λx.false) true
minus = λm.λn.n pred m
half = λn.n (λx.λy.y) 0           # Integer division by 2 (using Church numerals)
max = λm.λn.if (leq m n) n m      # Maximum
min = λm.λn.if (leq m n) m n      # Minimum
even = λn.iszero (mod n 2)        # Even predicate
odd = λn.not (even n)             # Odd predicate

# Comparison
leq = λm.λn.iszero (minus m n)
eq = λm.λn.and (leq m n) (leq n m)
gt = λm.λn.not (leq m n)
geq = λm.λn.not (lt m n)
lt = λm.λn.and (leq m n) (not (eq m n))

# Division and Modulo (using Y combinator for recursion)
DIV_HELPER = λrec. λm. λn. if (lt m n) 0 (succ (rec (minus m n) n))
div = Y DIV_HELPER
MOD_HELPER = λrec. λm. λn. if (lt m n) m (rec (minus m n) n)
mod = Y MOD_HELPER

# Combinators
K = λx.λy.x            # K (Kestrel, constant)
I = λx.x               # I (Identity)
S = λx.λy.λz.x z (y z) # S (Substitution)
B = λx.λy.λz.x (y z)   # B (Composition)
C = λx.λy.λz.x z y     # C (Flip)
W = λx.λy.x y y        # W (Duplication)
M = λx.x x             # M (Mockingbird)
Y = λf.(λx.f (x x)) (λx.f (x x)) # Y (Fixed-point)
Z = λf.(λx.f (λv.x x v)) (λx.f (λv.x x v)) # Z (Z combinator, another fixed-point)
Ω = (λx.x x) (λx.x x)  # Ω (Omega, infinite loop)

# Pairs
pair = λx.λy.λf.f x y
first = λp.p (λx.λy.x)
second = λp.p (λx.λy.y)
swap = λp.p (λx.λy.y x) (λx.λy.x y)

# Lists
nil = λx.λy.x                           # Empty list
cons = λx.λy.λf.f x y                   # Create a list node with head x and tail y
head = λl.l (λx.λy.x)                   # Extract the first element
tail = λl.l (λx.λy.y)                   # Extract the rest of the list

# Higher-order list operations
append = λl1.λl2.l1 (λx.λy.cons x (append y l2)) l2   # Append l2 to l1
map = λf.λl.l (λx.λy.cons (f x) (map f y)) nil        # Apply f to each element
filter = λf.λl.l (λx.λy.if (f x) (cons x (filter f y)) (filter f y)) nil  # Keep elements satisfying f
foldr = λf.λz.λl.l (λx.λy.f x (foldr f z y)) z        # Fold from right with initial value z
foldl = λf.λz.λl.l (λx.λy.y (f z x)) z                # Fold from left with initial value z
length = λl.foldl (λx.λy.succ x) 0 l                  # Count elements
reverse = λl.foldl (λx.λy.cons y x) nil l             # Reverse list order

# Arithmetic functions (recursive)
fact = λn.if (iszero n) 1 (mult n (fact (pred n)))
fib = λn.if (iszero n) 0 (if (eq n 1) 1 (plus (fib (pred n)) (fib (pred (pred n)))))

# Fixed-point combinators and helpers
FIB = Y (λf.λn.if (iszero n) 0 (if (eq n 1) 1 (plus (f (pred n)) (f (pred (pred n))))))

# Utility and convenience functions
id-num = λn.n (λx.succ x) 0                # Identity for Church numerals
bool-to-num = λb.b 1 0                     # Boolean to Church numeral
ispos = λn.not (iszero n)                  # Is positive (n > 0)
isnil = λl.l (λx.λy.false) true             # Checks if a list is nil
singleton = λx.cons x nil                  # Singleton list
compose = λf.λg.λx.f (g x)                 # Function composition
flip = λf.λx.λy.f y x                      # Flip arguments
make-pair = pair                           # Alias for pair
swap-pair = swap                           # Alias for swap
sub = λm.λn.n pred m                       # Alias for minus
isone = λn.eq n 1                          # Is one predicate
map-pair = λf.λp.p (λx.λy.pair (f x) (f y)) # Map function over both elements of a pair

# Iterate n times to build up Fibonacci value
FIB_ITER_HELPER = λn.n (λp.pair (second p) (plus (first p) (second p))) (pair 0 1)
FIB_ITER = λn.first (FIB_ITER_HELPER n)

# Iterative factorial (like FIB_ITER)
FACT_ITER_HELPER = λp. pair (pred (first p)) (mult (first p) (second p))
FACT_ITER = λn. second (n FACT_ITER_HELPER (pair n 1))
