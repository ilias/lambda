# Church encoding of lambda calculus

# boolean
id = λx.x 
true = λx y.x 
false = λx y.y 
and = λp q.p q p 
not = λp.p false true 
or = λp q.p true q 
xor = λp q.p (not q) q 
if = λp a b.p a b 
eq-bool = λx y.x y (not y)

# Church numerals
zero = λf x.x
succ = λn f x.f (n f x)
pred = λn f x.n (λg h.h (g f)) (λu.x) (λu.u) 
plus = λm n f x.m f (n f x)
mult = λm n f.m (n f)    
iszero = λn.n (λx.false) true
exp = λm n.n m
minus = λm n.n pred m

# Division and Modulo (iterative implementation)
# Iterative division: repeatedly subtract divisor from dividend
# State: (quotient, remainder)
DIV_STEP = λn p.if (lt (second p) n) p (pair (succ (first p)) (minus (second p) n))
DIV_ITER_HELPER = λm n.m (DIV_STEP n) (pair 0 m)
div = λm n.first (DIV_ITER_HELPER m n)
mod = λm n.second (DIV_ITER_HELPER m n)

leq = λm n.iszero (minus m n)
eq = λm n.and (leq m n) (leq n m)
gt = λm n.not (leq m n)
geq = λm n.not (lt m n)
lt = λm n.and (leq m n) (not (eq m n))

# combinators
K = λx y.x
I = λx.x
S = λx y z.x z (y z)
B = λx y z.x (y z)
C = λx y z.x z y
Y = λf.(λx.f (x x)) (λx.f (x x))

# pair
pair = λx y f.f x y
first = λp.p (λx y.x)
second = λp.p (λx y.y)
swap = λp.p (λx y.y x) (λx y.x y)

# Basic list operations
nil = λf z.z                              # Empty list
cons = λx xs f z.f x (xs f z)             # Create a list node with head x and tail xs
head = λl.l (λx xs.x) nil                 # Extract the first element
tail = λl.l (λx xs.xs) nil                # Extract the rest of the list

# Higher-order list operations (iterative implementations)
# Append: directly use Church list structure - l1 applies cons to each element with l2 as base
append = λl1 l2.l1 cons l2

# Map: directly use Church list structure - apply f to each element and cons the results
map = λf l.l (λx rest.cons (f x) rest) nil

# Filter: directly use Church list structure - conditionally include elements
filter = λf l.l (λx rest.if (f x) (cons x rest) rest) nil

# Foldr: directly use Church list structure - this is the natural fold for Church lists
foldr = λf z l.l f z

# Foldl: convert foldr to foldl using function composition
foldl = λf z l.foldr (λx g acc.g (f acc x)) (λy.y) l z

# Length: count elements using foldr
length = λl.foldr (λx acc.succ acc) zero l

# Reverse: build reversed list using foldl  
reverse = λl.foldl (λacc x.cons x acc) nil l

# Helper that uses an accumulator for O(n) computation
FACT_HELPER = Y (λf n acc.if (iszero n) acc (f (pred n) (mult n acc)))
fact = λn.FACT_HELPER n 1

# Iterate n times to build up Fibonacci value
FIB_ITER_HELPER = λn.n (λp.pair (second p) (plus (first p) (second p))) (pair 0 1)
fib = λn.first (FIB_ITER_HELPER n)