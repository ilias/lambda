# Church encoding of lambda calculus

# boolean
id = λx.x 
true = λx y.x 
false = λx y.y 
and = λp q.p q p 
not = λp.p false true 
or = λp q.p true q 
xor = λp q.p (not q) q 
if = λp a b.p a b 
eq-bool = λx y.x y (not y)

# Church numerals
0 = λf x.x
zero = λf x.x
succ = λn f x.f (n f x)
pred = λn f x.n (λg h.h (g f)) (λu.x) (λu.u) 
plus = λm n f x.m f (n f x)
mult = λm n f.m (n f)    
iszero = λn.n (λx.false) true
exp = λm n.n m
minus = λm n.n pred m

# Division and Modulo (using Y combinator for recursion)
# Helper for division: rec m n = if (m < n) then 0 else 1 + rec(m-n, n)
DIV_HELPER = λrec m n.if (lt m n) 0 (succ (rec (minus m n) n))
div = Y DIV_HELPER

# Helper for modulo: rec m n = if (m < n) then m else rec(m-n, n)
MOD_HELPER = λrec m n.if (lt m n) m (rec (minus m n) n)
mod = Y MOD_HELPER

leq = λm n.iszero (minus m n)
eq = λm n.and (leq m n) (leq n m)
gt = λm n.not (leq m n)
geq = λm n.not (lt m n)
lt = λm n.and (leq m n) (not (eq m n))

# combinators
K = λx y.x
I = λx.x
S = λx y z.x z (y z)
B = λx y z.x (y z)
C = λx y z.x z y
Y = λf.(λx.f (x x)) (λx.f (x x))

# pair
pair = λx y f.f x y
first = λp.p (λx y.x)
second = λp.p (λx y.y)
swap = λp.p (λx y.y x) (λx y.x y)

# Basic list operations
nil = λx y.x                           # Empty list
cons = λx y f.f x y                   # Create a list node with head x and tail y
head = λl.l (λx y.x)                   # Extract the first element
tail = λl.l (λx y.y)                   # Extract the rest of the list

# Higher-order list operations
append = λl1 l2.l1 (λx y.cons x (append y l2)) l2   # Append l2 to l1
map = λf l.l (λx y.cons (f x) (map f y)) nil        # Apply f to each element
filter = λf l.l (λx y.if (f x) (cons x (filter f y)) (filter f y)) nil  # Keep elements satisfying f
foldr = λf z l.l (λx y.f x (foldr f z y)) z        # Fold from right with initial value z
foldl = λf z l.l (λx y.y (f z x)) z                # Fold from left with initial value z
length = λl.foldl (λx y.succ x) 0 l                  # Count elements
reverse = λl.foldl (λx y.cons y x) nil l             # Reverse list order

# arithmetic functions
fact = λn.if (iszero n) 1 (mult n (fact (pred n)))
fib = λn.if (iszero n) 0 (if (eq n 1) 1 (plus (fib (pred n)) (fib (pred (pred n)))))

# fixed-point combinators
FIB = Y (λf n.if (iszero n) 0 (if (eq n 1) 1 (plus (f (pred n)) (f (pred (pred n))))))
FACT = Y (λf n.if (iszero n) 1 (mult n (f (pred n))))

# Helper that uses an accumulator for O(n) computation
FACT_HELPER = Y (λf n acc.if (iszero n) acc (f (pred n) (mult n acc)))
# Tail-recursive factorial with accumulator
FACT_TR = λn.FACT_HELPER n 1

# Iterate n times to build up Fibonacci value
FIB_ITER_HELPER = λn.n (λp.pair (second p) (plus (first p) (second p))) (pair 0 1)
# Extract the result from the pair
FIB_ITER = λn.first (FIB_ITER_HELPER n)