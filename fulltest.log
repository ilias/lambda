[36mLoading commands from 'stdlib.lambda'[0m
[90mline 0 <<: [33m# =============================================================================[0m[0m
[90mline 1 <<: [33m# stdlib.lambda - Standard Library for Lambda Interpreter[0m[0m
[90mline 2 <<: [33m#[0m[0m
[90mline 3 <<: [33m# This library provides a comprehensive set of functions and utilities for[0m[0m
[90mline 4 <<: [33m# programming in the untyped lambda calculus. It includes everything from[0m[0m
[90mline 5 <<: [33m# basic boolean logic and Church numerals to advanced data structures,[0m[0m
[90mline 6 <<: [33m# functional programming utilities, and a macro system.[0m[0m
[90mline 7 <<: [33m# =============================================================================[0m[0m
[90mline 8 <<: [0m
[90mline 9 <<: [0m
[90mline 10 <<: [33m# =============================================================================[0m[0m
[90mline 11 <<: [33m# SECTION 1: CORE LANGUAGE CONSTRUCTS[0m[0m
[90mline 12 <<: [33m#[0m[0m
[90mline 13 <<: [33m# This section defines the fundamental building blocks of the language,[0m[0m
[90mline 14 <<: [33m# including core identity, boolean logic, and conditional expressions.[0m[0m
[90mline 15 <<: [33m# =============================================================================[0m[0m
[90mline 16 <<: [0m
[90mline 17 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 18 <<: [33m# 1.1. Core Identity and Combinators[0m[0m
[90mline 19 <<: [33m#[0m[0m
[90mline 20 <<: [33m# These are the fundamental building blocks of combinatory logic and lambda calculus.[0m[0m
[90mline 21 <<: [33m# They form the mathematical foundation for all higher-level programming constructs.[0m[0m
[90mline 22 <<: [33m#[0m[0m
[90mline 23 <<: [33m# THEORY:[0m[0m
[90mline 24 <<: [33m#   - I (Identity): The simplest combinator, returns its argument unchanged[0m[0m
[90mline 25 <<: [33m#   - K (Constant): Creates constant functions, foundation for Church booleans[0m[0m
[90mline 26 <<: [33m#   - S (Substitution): Most powerful combinator, can express any computable function[0m[0m
[90mline 27 <<: [33m#   - B (Composition): Function composition, essential for building complex functions[0m[0m
[90mline 28 <<: [33m#   - C (Flip): Argument order manipulation, useful for partial application[0m[0m
[90mline 29 <<: [33m#[0m[0m
[90mline 30 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 31 <<: [33m#   I 42          # Returns 42 (identity)[0m[0m
[90mline 32 <<: [33m#   K 1 2         # Returns 1 (constant function, ignores second argument)[0m[0m
[90mline 33 <<: [33m#   S plus mult 3 # Returns plus 3 (mult 3) = plus 3 (3*3) = plus 3 9 = 12[0m[0m
[90mline 34 <<: [33m#   B succ double 5 # Returns succ (double 5) = succ 10 = 11[0m[0m
[90mline 35 <<: [33m#   C minus 3 10  # Returns minus 10 3 = 7 (flipped arguments)[0m[0m
[90mline 36 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 37 <<: id       = Î»x.x[0m
[32m-> id = Î»x.x[0m
[0m [0m
[90mline 38 <<: [33m# Secondary identity & constant aliases used in tests[0m[0m
[90mline 39 <<: id2      = id[0m
[32m-> id2 = Î»x.x[0m
[0m [0m
[90mline 40 <<: const2   = K[0m
[32m-> const2 = K[0m
[0m [0m
[90mline 41 <<: K        = Î»x y.x[0m
[32m-> K = true[0m
[0m [0m
[90mline 42 <<: I        = Î»x.x[0m
[32m-> I = Î»x.x[0m
[0m [0m
[90mline 43 <<: S        = Î»x y z.x z (y z)[0m
[32m-> S = Î»x.Î»y.Î»z.x z (y z)[0m
[0m [0m
[90mline 44 <<: B        = Î»x y z.x (y z)[0m
[32m-> B = Î»x.Î»y.Î»z.x (y z)[0m
[0m [0m
[90mline 45 <<: C        = Î»x y z.x z y[0m
[32m-> C = Î»x.Î»y.Î»z.x z y[0m
[0m [0m
[90mline 46 <<: [33m# Y        = Î»f.(Î»x.f (x x)) (Î»x.f (x x)) # The Y combinator is defined natively by the interpreter for recursion.[0m[0m
[90mline 47 <<: [0m
[90mline 48 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 49 <<: [33m# 1.2. Boolean Logic and Conditionals[0m[0m
[90mline 50 <<: [33m#[0m[0m
[90mline 51 <<: [33m# Church booleans are the foundation of conditional logic in lambda calculus.[0m[0m
[90mline 52 <<: [33m# They are encoded as selector functions that choose between two alternatives.[0m[0m
[90mline 53 <<: [33m#[0m[0m
[90mline 54 <<: [33m# ENCODING:[0m[0m
[90mline 55 <<: [33m#   true  = Î»x y.x  (selects first argument)[0m[0m
[90mline 56 <<: [33m#   false = Î»x y.y  (selects second argument)[0m[0m
[90mline 57 <<: [33m#[0m[0m
[90mline 58 <<: [33m# This encoding makes conditionals natural: (condition then-branch else-branch)[0m[0m
[90mline 59 <<: [33m# [0m[0m
[90mline 60 <<: [33m# LOGIC OPERATIONS:[0m[0m
[90mline 61 <<: [33m#   - NOT: Flips the selector by swapping the arguments to true/false[0m[0m
[90mline 62 <<: [33m#   - AND: Returns second argument if first is true, otherwise false[0m[0m
[90mline 63 <<: [33m#   - OR: Returns true if first argument is true, otherwise second argument[0m[0m
[90mline 64 <<: [33m#   - XOR: Returns true if exactly one argument is true[0m[0m
[90mline 65 <<: [33m#[0m[0m
[90mline 66 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 67 <<: [33m#   true 1 0              # Returns 1 (selects first argument)[0m[0m
[90mline 68 <<: [33m#   false 1 0             # Returns 0 (selects second argument)[0m[0m
[90mline 69 <<: [33m#   if (gt 5 3) "yes" "no" # Returns "yes" (if 5 > 3 then "yes" else "no")[0m[0m
[0mPROGRESS::4[0m
[90mline 70 <<: [33m#   and true false        # Returns false[0m[0m
[90mline 71 <<: [33m#   or false true         # Returns true[0m[0m
[90mline 72 <<: [33m#   not true              # Returns false[0m[0m
[90mline 73 <<: [33m#   xor true true         # Returns false (both true, so XOR is false)[0m[0m
[90mline 74 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 75 <<: true     = Î»x y.x[0m
[32m-> true = true[0m
[0m [0m
[90mline 76 <<: false    = Î»x y.y[0m
[32m-> false = false[0m
[0m [0m
[90mline 77 <<: if       = Î»p a b.p a b[0m
[32m-> if = Î»p.Î»a.Î»b.p a b[0m
[0m [0m
[90mline 78 <<: cond     = if[0m
[32m-> cond = Î»p.Î»a.Î»b.p a b[0m
[0m [0m
[90mline 79 <<: not      = Î»p.p false true[0m
[32m-> not = Î»p.p false true[0m
[0m [0m
[90mline 80 <<: and      = Î»p q.p q false[0m
[32m-> and = Î»p.Î»q.p q false[0m
[0m [0m
[90mline 81 <<: or       = Î»p q.p true q[0m
[32m-> or = [true][0m
[0m [0m
[90mline 82 <<: xor      = Î»p q.p (not q) q[0m
[32m-> xor = [not q][0m
[0m [0m
[90mline 83 <<: eqBool   = Î»x y.x y (not y)[0m
[32m-> eqBool = Î»x.Î»y.x y (not y)[0m
[0m [0m
[90mline 84 <<: [0m
[90mline 85 <<: [33m# Conditional application utilities[0m[0m
[90mline 86 <<: when     = Î»p f x.if p (f x) x              [33m# Apply function conditionally[0m[0m
[32m-> when = Î»p.Î»f.Î»x.if p (f x) x[0m
[0m [0m
[90mline 87 <<: unless   = Î»p f x.if p x (f x)              [33m# Apply function unless condition[0m[0m
[32m-> unless = Î»p.Î»f.Î»x.if p x (f x)[0m
[0m [0m
[90mline 88 <<: [33m# cond     = Î»p t e.if p t e                  # (Now provided earlier as alias)[0m[0m
[90mline 89 <<: [0m
[90mline 90 <<: [0m
[90mline 91 <<: [33m# =============================================================================[0m[0m
[90mline 92 <<: [33m# SECTION 2: NUMERIC COMPUTATION[0m[0m
[90mline 93 <<: [33m#[0m[0m
[90mline 94 <<: [33m# This section covers all aspects of numeric computation using Church numerals.[0m[0m
[90mline 95 <<: [33m# It includes basic arithmetic, comparisons, advanced functions like GCD and[0m[0m
[90mline 96 <<: [33m# prime checking, and iterative helpers for performance.[0m[0m
[90mline 97 <<: [33m# =============================================================================[0m[0m
[90mline 98 <<: [0m
[90mline 99 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 100 <<: [33m# 2.1. Church Numerals and Basic Arithmetic[0m[0m
[90mline 101 <<: [33m#[0m[0m
[90mline 102 <<: [33m# Church numerals encode natural numbers as higher-order functions that represent[0m[0m
[90mline 103 <<: [33m# repeated function application. This encoding makes arithmetic operations natural[0m[0m
[90mline 104 <<: [33m# function compositions and provides the foundation for all numeric computation.[0m[0m
[90mline 105 <<: [33m#[0m[0m
[90mline 106 <<: [33m# ENCODING:[0m[0m
[90mline 107 <<: [33m#   Number n = Î»f.Î»x.f^n(x)  (apply function f exactly n times to x)[0m[0m
[90mline 108 <<: [33m#   0 = Î»f.Î»x.x              (apply f zero times: just return x)[0m[0m
[90mline 109 <<: [33m#   1 = Î»f.Î»x.f x            (apply f once)[0m[0m
[90mline 110 <<: [33m#   2 = Î»f.Î»x.f (f x)        (apply f twice)[0m[0m
[90mline 111 <<: [33m#   3 = Î»f.Î»x.f (f (f x))    (apply f three times)[0m[0m
[90mline 112 <<: [33m#[0m[0m
[90mline 113 <<: [33m# ARITHMETIC OPERATIONS:[0m[0m
[90mline 114 <<: [33m#   - Addition: Apply f m times, then n more times[0m[0m
[90mline 115 <<: [33m#   - Multiplication: Compose f with itself m*n times[0m[0m
[90mline 116 <<: [33m#   - Exponentiation: Apply the "multiply by base" function n times[0m[0m
[90mline 117 <<: [33m#   - Predecessor: Complex operation using pairs and projection[0m[0m
[90mline 118 <<: [33m#[0m[0m
[90mline 119 <<: [33m# PERFORMANCE NOTE: [0m[0m
[90mline 120 <<: [33m#   Enable native arithmetic with :native on for faster computation of large numbers.[0m[0m
[90mline 121 <<: [33m#[0m[0m
[90mline 122 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 123 <<: [33m#   plus 3 4        # Returns 7 (Church numeral for 7)[0m[0m
[90mline 124 <<: [33m#   mult 6 7        # Returns 42 (Church numeral for 42)[0m[0m
[90mline 125 <<: [33m#   exp 2 3         # Returns 8 (2^3 as Church numeral)[0m[0m
[90mline 126 <<: [33m#   iszero 0        # Returns true (Church boolean)[0m[0m
[90mline 127 <<: [33m#   succ 5          # Returns 6 (successor of 5)[0m[0m
[90mline 128 <<: [33m#   pred 3          # Returns 2 (predecessor of 3, pred 0 = 0)[0m[0m
[90mline 129 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 130 <<: zero     = Î»f x.x[0m
[32m-> zero = false[0m
[0m [0m
[90mline 131 <<: succ     = Î»n f x.f (n f x)[0m
[32m-> succ = Î»n.Î»f.Î»x.f (n f x)[0m
[0m [0m
[90mline 132 <<: pred     = Î»n f x.n (Î»g h.h (g f)) (Î»u.x) (Î»u.u)[0m
[32m-> pred = Î»n.Î»f.Î»x.n (Î»g.Î»h.h (g f)) (Î»u.x) (Î»u.u)[0m
[0m [0m
[90mline 133 <<: plus     = Î»m n f x.m f (n f x)[0m
[32m-> plus = Î»m.Î»n.Î»f.Î»x.m f (n f x)[0m
[0m [0m
[90mline 134 <<: minus    = Î»m n.n pred m[0m
[32m-> minus = Î»m.Î»n.n pred m[0m
[0m [0m
[90mline 135 <<: mult     = Î»m n f.m (n f)[0m
[32m-> mult = Î»m.Î»n.Î»f.m (n f)[0m
[0m [0m
[90mline 136 <<: exp      = Y (Î»f. Î»b n. if (iszero n) 1 (mult b (f b (pred n))))[0m
[32m-> exp = <thunk:(Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))) (Y (Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))))>[0m
[0m [0m
[90mline 137 <<: pow      = exp[0m
[32m-> pow = <thunk:(Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))) (Y (Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))))>[0m
[0m [0m
[90mline 138 <<: iszero   = Î»n.n (Î»x.false) true[0m
[32m-> iszero = Î»n.n (Î»x.false) true[0m
[0m [0m
[90mline 139 <<: [0m
[90mline 140 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 141 <<: [33m# 2.2. Division and Modulo[0m[0m
[90mline 142 <<: [33m#[0m[0m
[90mline 143 <<: [33m# Division and modulo are implemented using an iterative helper function that[0m[0m
[90mline 144 <<: [33m# repeatedly subtracts the divisor from the dividend while counting iterations.[0m[0m
[90mline 145 <<: [33m# The helper returns a pair (quotient, remainder) which is then destructured.[0m[0m
[90mline 146 <<: [33m#[0m[0m
[90mline 147 <<: [33m# ALGORITHM:[0m[0m
[90mline 148 <<: [33m#   1. Start with quotient = 0, remainder = dividend[0m[0m
[90mline 149 <<: [33m#   2. While remainder >= divisor:[0m[0m
[90mline 150 <<: [33m#      - Increment quotient[0m[0m
[90mline 151 <<: [33m#      - Subtract divisor from remainder[0m[0m
[90mline 152 <<: [33m#   3. Return (quotient, remainder)[0m[0m
[90mline 153 <<: [33m#[0m[0m
[90mline 154 <<: [33m# SAFETY: Division by zero returns 0 (handled by the lt comparison failing)[0m[0m
[90mline 155 <<: [33m#[0m[0m
[90mline 156 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 157 <<: [33m#   div 15 3        # Returns 5 (15 Ã· 3 = 5)[0m[0m
[0mPROGRESS::9[0m
[90mline 158 <<: [33m#   mod 17 5        # Returns 2 (17 mod 5 = 2)[0m[0m
[90mline 159 <<: [33m#   div 7 0         # Returns 0 (division by zero protection)[0m[0m
[90mline 160 <<: [33m#   mod 10 3        # Returns 1 (10 mod 3 = 1)[0m[0m
[90mline 161 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 162 <<: [33m# Iterative division helper. Returns a pair (quotient, remainder).[0m[0m
[90mline 163 <<: DIV_ITER = Y(Î»f. Î»q m n. \[0m
[90mline 164 <<:     if (lt m n) \[0m
[90mline 165 <<:         (pair q m)\[0m
[90mline 166 <<:         (f (succ q) (minus m n) n)\[0m
[90mline 167 <<: )[0m
[32m-> DIV_ITER = <thunk:(Î»f.Î»q.Î»m.Î»n.if (lt m n) (pair q m) (f (succ q) (minus m n) n)) (Y (Î»f.Î»q.Î»m.Î»n.if (lt m n) (pair q m) (f (succ q) (minus m n) n)))>[0m
[0m [0m
[90mline 168 <<: div = Î»m n. first (DIV_ITER 0 m n)[0m
[32m-> div = Î»m.Î»n.first (DIV_ITER false m n)[0m
[0m [0m
[90mline 169 <<: mod = Î»m n. second (DIV_ITER 0 m n)[0m
[32m-> mod = Î»m.Î»n.second (DIV_ITER false m n)[0m
[0m [0m
[90mline 170 <<: [0m
[90mline 171 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 172 <<: [33m# 2.3. Comparison Operations[0m[0m
[90mline 173 <<: [33m#[0m[0m
[90mline 174 <<: [33m# All comparison operations are built on Church numeral subtraction and the iszero[0m[0m
[90mline 175 <<: [33m# predicate. The foundation is the leq (â‰¤) operation, which checks if m-n equals zero.[0m[0m
[90mline 176 <<: [33m# All other comparisons are derived from this basic operation.[0m[0m
[90mline 177 <<: [33m#[0m[0m
[90mline 178 <<: [33m# IMPLEMENTATION STRATEGY:[0m[0m
[90mline 179 <<: [33m#   - leq m n: Check if (m - n) = 0, meaning m â‰¤ n[0m[0m
[90mline 180 <<: [33m#   - eq m n: Check if both m â‰¤ n AND n â‰¤ m[0m[0m
[90mline 181 <<: [33m#   - lt m n: Check if m â‰¤ n but NOT m = n[0m[0m
[90mline 182 <<: [33m#   - gt m n: Check if NOT m â‰¤ n[0m[0m
[90mline 183 <<: [33m#   - geq/neq: Logical negations of lt/eq respectively[0m[0m
[90mline 184 <<: [33m#[0m[0m
[90mline 185 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 186 <<: [33m#   leq 3 5         # Returns true (3 â‰¤ 5)[0m[0m
[90mline 187 <<: [33m#   eq 4 4          # Returns true (4 = 4)[0m[0m
[90mline 188 <<: [33m#   lt 2 2          # Returns false (2 is not < 2)[0m[0m
[90mline 189 <<: [33m#   gt 7 3          # Returns true (7 > 3)[0m[0m
[90mline 190 <<: [33m#   geq 5 5         # Returns true (5 â‰¥ 5)[0m[0m
[90mline 191 <<: [33m#   neq 3 8         # Returns true (3 â‰  8)[0m[0m
[90mline 192 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 193 <<: leq      = Î»m n.iszero (minus m n)[0m
[32m-> leq = Î»m.Î»n.iszero (minus m n)[0m
[0m [0m
[90mline 194 <<: eq       = Î»m n.and (leq m n) (leq n m)[0m
[32m-> eq = Î»m.Î»n.and (leq m n) (leq n m)[0m
[0m [0m
[90mline 195 <<: lt       = Î»m n.and (leq m n) (not (eq m n))[0m
[32m-> lt = Î»m.Î»n.and (leq m n) (not (eq m n))[0m
[0m [0m
[90mline 196 <<: gt       = Î»m n.not (leq m n)[0m
[32m-> gt = Î»m.Î»n.not (leq m n)[0m
[0m [0m
[90mline 197 <<: geq      = Î»m n.not (lt m n)[0m
[32m-> geq = Î»m.Î»n.not (lt m n)[0m
[0m [0m
[90mline 198 <<: neq      = Î»m n.not (eq m n)[0m
[32m-> neq = Î»m.Î»n.not (eq m n)[0m
[0m [0m
[90mline 199 <<: [0m
[90mline 200 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 201 <<: [33m# 2.4. Additional Numeric Operations and Predicates[0m[0m
[90mline 202 <<: [33m#[0m[0m
[90mline 203 <<: [33m# This collection provides common mathematical operations and numeric predicates[0m[0m
[90mline 204 <<: [33m# built on top of the basic Church numeral operations. These functions demonstrate[0m[0m
[90mline 205 <<: [33m# how complex mathematical concepts can be expressed in pure lambda calculus.[0m[0m
[90mline 206 <<: [33m#[0m[0m
[90mline 207 <<: [33m# MATHEMATICAL OPERATIONS:[0m[0m
[90mline 208 <<: [33m#   - square/double/triple/quadruple: Common multiplications[0m[0m
[90mline 209 <<: [33m#   - half: Integer division by 2[0m[0m
[90mline 210 <<: [33m#   - abs: Absolute value (no-op for Church numerals since they're non-negative)[0m[0m
[90mline 211 <<: [33m#   - max/min: Selection based on comparison[0m[0m
[90mline 212 <<: [33m#[0m[0m
[90mline 213 <<: [33m# PREDICATES:[0m[0m
[90mline 214 <<: [33m#   - even/odd: Based on modulo 2 operation[0m[0m
[90mline 215 <<: [33m#   - isone/istwo: Specific equality checks[0m[0m
[90mline 216 <<: [33m#   - ispositive: Non-zero check[0m[0m
[90mline 217 <<: [33m#[0m[0m
[90mline 218 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 219 <<: [33m#   square 7        # Returns 49 (7Â²)[0m[0m
[90mline 220 <<: [33m#   double 6        # Returns 12 (2 Ã— 6)[0m[0m
[90mline 221 <<: [33m#   half 10         # Returns 5 (10 Ã· 2)[0m[0m
[90mline 222 <<: [33m#   even 8          # Returns true (8 is even)[0m[0m
[90mline 223 <<: [33m#   odd 7           # Returns true (7 is odd)[0m[0m
[90mline 224 <<: [33m#   max 5 3         # Returns 5 (maximum of 5 and 3)[0m[0m
[90mline 225 <<: [33m#   min 5 3         # Returns 3 (minimum of 5 and 3)[0m[0m
[90mline 226 <<: [33m#   ispositive 0    # Returns false (0 is not positive)[0m[0m
[90mline 227 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 228 <<: square   = Î»n.mult n n[0m
[32m-> square = Î»n.mult n n[0m
[0m [0m
[90mline 229 <<: double   = Î»n.plus n n[0m
[32m-> double = Î»n.plus n n[0m
[0m [0m
[90mline 230 <<: half     = Î»n.div n 2[0m
[32m-> half = Î»n.div n 2[0m
[0m [0m
[90mline 231 <<: even     = Î»n.eq (mod n 2) zero[0m
[32m-> even = Î»n.eq (mod n 2) zero[0m
[0m [0m
[90mline 232 <<: odd      = Î»n.not (even n)[0m
[32m-> odd = Î»n.not (even n)[0m
[0m [0m
[90mline 233 <<: abs      = Î»n.n                               [33m# Church numerals are non-negative[0m[0m
[32m-> abs = Î»n.n[0m
[0m [0m
[90mline 234 <<: max      = Î»m n.if (geq m n) m n[0m
[32m-> max = Î»m.Î»n.if (geq m n) m n[0m
[0m [0m
[90mline 235 <<: min      = Î»m n.if (leq m n) m n[0m
[32m-> min = Î»m.Î»n.if (leq m n) m n[0m
[0m [0m
[90mline 236 <<: [33m# pow      = exp                              # Alias for exp[0m[0m
[90mline 237 <<: isone    = Î»n.eq n 1[0m
[32m-> isone = Î»n.eq n 1[0m
[0m [0m
[90mline 238 <<: istwo    = Î»n.eq n 2[0m
[32m-> istwo = Î»n.eq n 2[0m
[0m [0m
[90mline 239 <<: ispositive = Î»n.not (iszero n)[0m
[32m-> ispositive = Î»n.not (iszero n)[0m
[0m [0m
[90mline 240 <<: triple   = Î»n.plus n (plus n n)[0m
[32m-> triple = Î»n.plus n (plus n n)[0m
[0m [0m
[90mline 241 <<: quadruple = Î»n.plus (double n) (double n)[0m
[32m-> quadruple = Î»n.plus (double n) (double n)[0m
[0m [0m
[90mline 242 <<: [0m
[90mline 243 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 244 <<: [33m# 2.5. Advanced Numeric Algorithms[0m[0m
[0mPROGRESS::14[0m
[90mline 245 <<: [33m#[0m[0m
[90mline 246 <<: [33m# This section implements sophisticated mathematical algorithms using Church numerals[0m[0m
[90mline 247 <<: [33m# and lambda calculus techniques. These functions demonstrate how complex mathematics[0m[0m
[90mline 248 <<: [33m# can be expressed in pure functional form.[0m[0m
[90mline 249 <<: [33m#[0m[0m
[90mline 250 <<: [33m# ALGORITHMS IMPLEMENTED:[0m[0m
[90mline 251 <<: [33m#   - Iterative Factorial: Uses pair accumulation to avoid deep recursion[0m[0m
[90mline 252 <<: [33m#   - Iterative Fibonacci: Maintains (current, next) pair that shifts each iteration[0m[0m
[90mline 253 <<: [33m#   - Euclidean GCD: Classic algorithm using modulo and recursion[0m[0m
[90mline 254 <<: [33m#   - Newton's Method Square Root: Iterative approximation with convergence check[0m[0m
[90mline 255 <<: [33m#   - Trial Division Primality: Tests divisibility up to âˆšn for efficiency[0m[0m
[90mline 256 <<: [33m#   - Ackermann Function: Extremely fast-growing function (use small arguments!)[0m[0m
[90mline 257 <<: [33m#[0m[0m
[90mline 258 <<: [33m# PERFORMANCE NOTES:[0m[0m
[90mline 259 <<: [33m#   - Iterative versions (fact, fib) avoid stack overflow for large inputs[0m[0m
[90mline 260 <<: [33m#   - Square root uses 20 iterations maximum with Newton's method[0m[0m
[90mline 261 <<: [33m#   - Prime checking is optimized to test only up to âˆšn[0m[0m
[90mline 262 <<: [33m#   - GCD uses the efficient Euclidean algorithm[0m[0m
[90mline 263 <<: [33m#[0m[0m
[90mline 264 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 265 <<: [33m#   fact 5              # Returns 120 (5! = 5Ã—4Ã—3Ã—2Ã—1)[0m[0m
[90mline 266 <<: [33m#   fib 10              # Returns 55 (10th Fibonacci number)[0m[0m
[90mline 267 <<: [33m#   gcd 48 18           # Returns 6 (greatest common divisor)[0m[0m
[90mline 268 <<: [33m#   lcm 4 6             # Returns 12 (least common multiple)[0m[0m
[90mline 269 <<: [33m#   sqrt 25             # Returns 5 (integer square root)[0m[0m
[90mline 270 <<: [33m#   sqrt 26             # Returns 5 (integer square root, rounded down)[0m[0m
[90mline 271 <<: [33m#   isPrime 17          # Returns true (17 is prime)[0m[0m
[90mline 272 <<: [33m#   isPrime 15          # Returns false (15 = 3Ã—5, not prime)[0m[0m
[90mline 273 <<: [33m#   ackermann 3 2       # Returns 29 (grows very fast - keep arguments small!)[0m[0m
[90mline 274 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 275 <<: [33m# Iterative Factorial[0m[0m
[90mline 276 <<: FACT_ITER_HELPER = Î»n.n (Î»p.pair (succ (first p)) \[0m
[90mline 277 <<:                                   (mult (succ (first p)) (second p))) \[0m
[90mline 278 <<:                          (pair 0 1)[0m
[32m-> FACT_ITER_HELPER = Î»n.n (Î»p.pair (succ (first p)) (mult (succ (first p)) (second p))) (pair false 1)[0m
[0m [0m
[90mline 279 <<: fact             = Î»n.second (FACT_ITER_HELPER n)[0m
[32m-> fact = Î»n.second (FACT_ITER_HELPER n)[0m
[0m [0m
[90mline 280 <<: [0m
[90mline 281 <<: [33m# Iterative Fibonacci[0m[0m
[90mline 282 <<: FIB_ITER_HELPER  = Î»n.n (Î»p.pair (second p) \[0m
[90mline 283 <<:                                   (plus (first p) (second p))) \[0m
[90mline 284 <<:                          (pair 0 1)[0m
[32m-> FIB_ITER_HELPER = Î»n.n (Î»p.pair (second p) (plus (first p) (second p))) (pair false 1)[0m
[0m [0m
[90mline 285 <<: fib              = Î»n.first (FIB_ITER_HELPER n)[0m
[32m-> fib = Î»n.first (FIB_ITER_HELPER n)[0m
[0m [0m
[90mline 286 <<: [0m
[90mline 287 <<: [33m# GCD and LCM using Euclidean algorithm[0m[0m
[90mline 288 <<: gcd = Y (Î»g a b. if (iszero b) a (g b (mod a b)))[0m
[32m-> gcd = <thunk:(Î»g.Î»a.Î»b.if (iszero b) a (g b (mod a b))) (Y (Î»g.Î»a.Î»b.if (iszero b) a (g b (mod a b))))>[0m
[0m [0m
[90mline 289 <<: lcm = Î»a b. if (or (iszero a) (iszero b)) 0 (div (mult a b) (gcd a b))[0m
[32m-> lcm = Î»a.Î»b.if (or (iszero a) (iszero b)) false (div (mult a b) (gcd a b))[0m
[0m [0m
[90mline 290 <<: [0m
[90mline 291 <<: [33m# Square Root using Newton's method[0m[0m
[90mline 292 <<: SQRT_NEWTON_STEP = Î»n x. half (plus x (div n x))[0m
[32m-> SQRT_NEWTON_STEP = Î»n.Î»x.half (plus x (div n x))[0m
[0m [0m
[90mline 293 <<: SQRT_CONVERGED   = Î»n x. leq (abs (minus (mult x x) n)) 1[0m
[32m-> SQRT_CONVERGED = Î»n.Î»x.leq (abs (minus (mult x x) n)) 1[0m
[0m [0m
[90mline 294 <<: SQRT_ITER        = Y (Î»f n x iterations. \[0m
[90mline 295 <<:     if (or (SQRT_CONVERGED n x) (iszero iterations)) \[0m
[90mline 296 <<:         x \[0m
[90mline 297 <<:         (f n (SQRT_NEWTON_STEP n x) (pred iterations)) \[0m
[90mline 298 <<: )[0m
[32m-> SQRT_ITER = <thunk:(Î»f.Î»n.Î»x.Î»iterations.if (or (SQRT_CONVERGED n x) (iszero iterations)) x (f n (SQRT_NEWTON_STEP n x) (pred iterations))) (Y (Î»f.Î»n.Î»x.Î»iterations.if (or (SQRT_CONVERGED n x) (iszero iterations)) x (f n (SQRT_NEWTON_STEP n x) (pred iterations))))>[0m
[0m [0m
[90mline 299 <<: sqrt = Î»n. \[0m
[90mline 300 <<:     if (iszero n) zero \[0m
[90mline 301 <<:     (if (eq n 1) 1 \[0m
[90mline 302 <<:         (SQRT_ITER n (half (plus n 1)) 20))  [33m# Initial guess: (n+1)/2, 20 iterations[0m[0m
[32m-> sqrt = Î»n.if (iszero n) zero (if (eq n 1) 1 (SQRT_ITER n (half (plus n 1)) 20))[0m
[0m [0m
[90mline 303 <<: [0m
[90mline 304 <<: [33m# Prime number check via trial division[0m[0m
[90mline 305 <<: isPrime = Y (Î»f n. \[0m
[90mline 306 <<:     let iter = Y (Î»iter i. \[0m
[90mline 307 <<:         if (gt (mult i i) n) true \[0m
[90mline 308 <<:         (if (eq (mod n i) 0) false \[0m
[90mline 309 <<:             (iter (succ i))) \[0m
[90mline 310 <<:     ) in \[0m
[90mline 311 <<:     if (lt n 2) false (iter 2) \[0m
[90mline 312 <<: )[0m
[32m-> isPrime = <thunk:(Î»f.Î»n.(Î»iter.if (lt n 2) false (iter 2)) (Y (Î»iter.Î»i.if (gt (mult i i) n) true (if (eq (mod n i) false) false (iter (succ i)))))) (Y (Î»f.Î»n.(Î»iter.if (lt n 2) false (iter 2)) (Y (Î»iter.Î»i.if (gt (mult i i) n) true (if (eq (mod n i) false) false (iter (succ i)))))))>[0m
[0m [0m
[90mline 313 <<: [0m
[90mline 314 <<: [33m# Ackermann function[0m[0m
[90mline 315 <<: ackermann  = \p.(p (\a.\q.(a (q a 1))) succ)[0m
[32m-> ackermann = Î»p.p (Î»a.Î»q.a (q a 1)) succ[0m
[0m [0m
[90mline 316 <<: [0m
[90mline 317 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 318 <<: [33m# 2.6. Recursive Function Examples (using Y combinator)[0m[0m
[90mline 319 <<: [33m#[0m[0m
[90mline 320 <<: [33m# These are alternative, often less efficient, implementations provided for[0m[0m
[90mline 321 <<: [33m# educational purposes to demonstrate recursion with the Y combinator.[0m[0m
[90mline 322 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 323 <<: factRec    = Y (\f.\n. if (iszero n) 1 (mult n (f (pred n))))[0m
[32m-> factRec = <thunk:(Î»f.Î»n.if (iszero n) 1 (mult n (f (pred n)))) (Y (Î»f.Î»n.if (iszero n) 1 (mult n (f (pred n)))))>[0m
[0m [0m
[90mline 324 <<: fibRec     = Y (\f.\n. if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n)))))[0m
[32m-> fibRec = <thunk:(Î»f.Î»n.if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n))))) (Y (Î»f.Î»n.if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n))))))>[0m
[0m [0m
[90mline 325 <<: sumUptoRec = Y (\f.\n.if (iszero n) 0 (plus n (f (pred n))))[0m
[32m-> sumUptoRec = <thunk:(Î»f.Î»n.if (iszero n) false (plus n (f (pred n)))) (Y (Î»f.Î»n.if (iszero n) false (plus n (f (pred n)))))>[0m
[0m [0m
[90mline 326 <<: [0m
[90mline 327 <<: [0m
[90mline 328 <<: [33m# =============================================================================[0m[0m
[90mline 329 <<: [33m# SECTION 3: DATA STRUCTURES[0m[0m
[90mline 330 <<: [33m#[0m[0m
[90mline 331 <<: [33m# This section defines common data structures like pairs, lists, and trees,[0m[0m
[90mline 332 <<: [33m# along with a comprehensive suite of operations for each.[0m[0m
[0mPROGRESS::19[0m
[90mline 333 <<: [33m# =============================================================================[0m[0m
[90mline 334 <<: [0m
[90mline 335 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 336 <<: [33m# 3.1. Pairs[0m[0m
[90mline 337 <<: [33m#[0m[0m
[90mline 338 <<: [33m# Pairs are the fundamental data structure for combining two values in lambda calculus.[0m[0m
[90mline 339 <<: [33m# They are implemented using Church encoding where a pair is a function that takes[0m[0m
[90mline 340 <<: [33m# another function and applies it to the two stored values.[0m[0m
[90mline 341 <<: [33m#[0m[0m
[90mline 342 <<: [33m# ENCODING:[0m[0m
[90mline 343 <<: [33m#   pair x y = Î»f.f x y    (store x and y, apply function f to both)[0m[0m
[90mline 344 <<: [33m#   first p = p (Î»x y.x)   (apply pair to a function that selects first)[0m[0m
[90mline 345 <<: [33m#   second p = p (Î»x y.y)  (apply pair to a function that selects second)[0m[0m
[90mline 346 <<: [33m#[0m[0m
[90mline 347 <<: [33m# This encoding demonstrates the power of higher-order functions - data structures[0m[0m
[90mline 348 <<: [33m# become functions that can be manipulated through function application.[0m[0m
[90mline 349 <<: [33m#[0m[0m
[90mline 350 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 351 <<: [33m#   p = pair 10 20      # Create a pair containing 10 and 20[0m[0m
[90mline 352 <<: [33m#   first p             # Returns 10 (extract first element)[0m[0m
[90mline 353 <<: [33m#   second p            # Returns 20 (extract second element)[0m[0m
[90mline 354 <<: [33m#   swap p              # Returns pair 20 10 (swapped pair)[0m[0m
[90mline 355 <<: [33m#   pair 3 4 plus       # Returns 7 (apply plus to the pair elements)[0m[0m
[90mline 356 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 357 <<: pair     = Î»x y f.f x y[0m
[32m-> pair = Î»x.Î»y.Î»f.f x y[0m
[0m [0m
[90mline 358 <<: first    = Î»p.p (Î»x y.x)[0m
[32m-> first = Î»p.p (true)[0m
[0m [0m
[90mline 359 <<: second   = Î»p.p (Î»x y.y)[0m
[32m-> second = Î»p.p false[0m
[0m [0m
[90mline 360 <<: swap     = Î»p.Î»f.p (Î»x y.f y x)[0m
[32m-> swap = Î»p.Î»f.p (Î»x.Î»y.f y x)[0m
[0m [0m
[90mline 361 <<: [0m
[90mline 362 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 363 <<: [33m# 3.2. Lists - Core Operations[0m[0m
[90mline 364 <<: [33m#[0m[0m
[90mline 365 <<: [33m# Lists in lambda calculus are implemented using Church encoding with a cons/nil[0m[0m
[90mline 366 <<: [33m# structure similar to LISP. This encoding makes fold operations the natural way[0m[0m
[90mline 367 <<: [33m# to process lists, since the fold operation is built into the list structure itself.[0m[0m
[90mline 368 <<: [33m#[0m[0m
[90mline 369 <<: [33m# ENCODING:[0m[0m
[90mline 370 <<: [33m#   nil = Î»f z.z                    (empty list: return accumulator unchanged)[0m[0m
[90mline 371 <<: [33m#   cons x xs = Î»f z.f x (xs f z)   (prepend x: apply f to x and rest of list)[0m[0m
[90mline 372 <<: [33m#[0m[0m
[90mline 373 <<: [33m# The beauty of this encoding is that a list IS its own right fold function![0m[0m
[90mline 374 <<: [33m# When you call (list f z), you're performing foldr f z list.[0m[0m
[90mline 375 <<: [33m#[0m[0m
[90mline 376 <<: [33m# OPERATIONS:[0m[0m
[90mline 377 <<: [33m#   - isnil: Tests if list equals the nil function[0m[0m
[90mline 378 <<: [33m#   - head: Extracts first element using a selector function[0m[0m
[90mline 379 <<: [33m#   - tail: Complex operation using accumulator pairs to reconstruct list tail[0m[0m
[90mline 380 <<: [33m#[0m[0m
[90mline 381 <<: [33m# PERFORMANCE NOTES:[0m[0m
[90mline 382 <<: [33m#   - cons and head are O(1)[0m[0m
[90mline 383 <<: [33m#   - tail is O(n) due to the need to reconstruct the list[0m[0m
[90mline 384 <<: [33m#   - isnil is O(1) by testing list structure[0m[0m
[90mline 385 <<: [33m#[0m[0m
[90mline 386 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 387 <<: [33m#   l = cons 1 (cons 2 nil)     # Creates list [1, 2][0m[0m
[90mline 388 <<: [33m#   isnil nil                   # Returns true[0m[0m
[90mline 389 <<: [33m#   head l                      # Returns 1[0m[0m
[90mline 390 <<: [33m#   tail l                      # Returns [2] (the list containing just 2)[0m[0m
[90mline 391 <<: [33m#   isnil (tail (tail l))       # Returns true (tail of [2] is empty)[0m[0m
[90mline 392 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 393 <<: nil      = Î»f z.z[0m
[32m-> nil = false[0m
[0m [0m
[90mline 394 <<: cons     = Î»x xs f z.f x (xs f z)[0m
[32m-> cons = Î»x.Î»xs.Î»f.Î»z.f x (xs f z)[0m
[0m [0m
[90mline 395 <<: isnil    = Î»l.l (Î»x xs.false) true[0m
[32m-> isnil = Î»l.l (Î»x.Î»xs.false) true[0m
[0m [0m
[90mline 396 <<: head     = Î»l.l (Î»x xs.x) nil[0m
[32m-> head = Î»l.l (true) [][0m
[0m [0m
[90mline 397 <<: tail     = Î»l.first (l (Î»x p.pair (second p) (cons x (second p))) (pair nil nil))[0m
[32m-> tail = Î»l.first (l (Î»x.Î»p.pair (second p) (cons x (second p))) (pair [] []))[0m
[0m [0m
[90mline 398 <<: [33m# isempty  = isnil # Alias for isnil[0m[0m
[90mline 399 <<: [0m
[90mline 400 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 401 <<: [33m# 3.3. Lists - Higher-Order Functions[0m[0m
[90mline 402 <<: [33m#[0m[0m
[90mline 403 <<: [33m# These are the fundamental list processing functions in functional programming.[0m[0m
[90mline 404 <<: [33m# They operate on lists using higher-order functions (functions that take other[0m[0m
[90mline 405 <<: [33m# functions as arguments) to transform, filter, and aggregate data.[0m[0m
[90mline 406 <<: [33m#[0m[0m
[90mline 407 <<: [33m# The Church encoding of lists makes these operations natural:[0m[0m
[90mline 408 <<: [33m#   - map: Transform each element using function f[0m[0m
[90mline 409 <<: [33m#   - filter: Keep only elements satisfying predicate f[0m[0m
[90mline 410 <<: [33m#   - foldl: Left-associative fold ((((z op x1) op x2) op x3) ...)[0m[0m
[90mline 411 <<: [33m#   - foldr: Right-associative fold (x1 op (x2 op (x3 op ... z)))[0m[0m
[90mline 412 <<: [33m#[0m[0m
[90mline 413 <<: [33m# MATHEMATICAL FOUNDATION:[0m[0m
[90mline 414 <<: [33m#   These functions form a complete basis for list processing. Any list operation[0m[0m
[90mline 415 <<: [33m#   can be expressed in terms of these primitives, making them the building blocks[0m[0m
[90mline 416 <<: [33m#   of functional data processing.[0m[0m
[90mline 417 <<: [33m#[0m[0m
[90mline 418 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 419 <<: [33m#   map (mult 2) [1, 2, 3]      # Returns [2, 4, 6] (double each element)[0m[0m
[0mPROGRESS::24[0m
[90mline 420 <<: [33m#   filter even [1, 2, 3, 4]    # Returns [2, 4] (keep only even numbers)[0m[0m
[90mline 421 <<: [33m#   foldl plus 0 [1, 2, 3]      # Returns 6 (sum: ((0+1)+2)+3)[0m[0m
[90mline 422 <<: [33m#   foldr mult 1 [2, 3, 4]      # Returns 24 (product: 2*(3*(4*1)))[0m[0m
[90mline 423 <<: [33m#   foldr cons nil [1, 2, 3]    # Returns [1, 2, 3] (identity for lists)[0m[0m
[90mline 424 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 425 <<: map      = Î»f l.l (Î»x rest.cons (f x) rest) nil[0m
[32m-> map = Î»f.Î»l.l (Î»x.Î»rest.cons (f x) rest) [][0m
[0m [0m
[90mline 426 <<: filter   = Î»f l.l (Î»x rest.if (f x) (cons x rest) rest) nil[0m
[32m-> filter = Î»f.Î»l.l (Î»x.Î»rest.if (f x) (cons x rest) rest) [][0m
[0m [0m
[90mline 427 <<: [33m# NOTE: Original foldl was effectively a right-to-left fold (processing elements in reverse),[0m[0m
[90mline 428 <<: [33m# which made reverse become the identity. Correct left fold via CPS:[0m[0m
[90mline 429 <<: [33m# foldl f z [x1,x2,..,xn] = f (... (f (f z x1) x2) ...) xn[0m[0m
[90mline 430 <<: foldl    = Î»f z l.(l (Î»x k. Î»acc. k (f acc x)) (Î»acc.acc)) z[0m
[32m-> foldl = Î»f.Î»z.Î»l.l (Î»x.Î»k.Î»acc.k (f acc x)) (Î»acc.acc) z[0m
[0m [0m
[90mline 431 <<: foldr    = Î»f z l.l f z[0m
[32m-> foldr = Î»f.Î»z.Î»l.l f z[0m
[0m [0m
[90mline 432 <<: [0m
[90mline 433 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 434 <<: [33m# 3.4. Lists - Generation and Manipulation[0m[0m
[90mline 435 <<: [33m#[0m[0m
[90mline 436 <<: [33m# These functions provide essential list operations for building, combining,[0m[0m
[90mline 437 <<: [33m# and transforming lists. They build on the higher-order functions to provide[0m[0m
[90mline 438 <<: [33m# practical list manipulation capabilities.[0m[0m
[90mline 439 <<: [33m#[0m[0m
[90mline 440 <<: [33m# OPERATIONS:[0m[0m
[90mline 441 <<: [33m#   - append: Concatenates two lists using the foldr structure[0m[0m
[90mline 442 <<: [33m#   - reverse: Uses foldl to build reversed list by consing in opposite order[0m[0m
[90mline 443 <<: [33m#   - length: Counts elements by folding with successor function[0m[0m
[90mline 444 <<: [33m#   - take/drop: Extract prefix/suffix of specified length[0m[0m
[90mline 445 <<: [33m#   - range: Generates arithmetic sequences[0m[0m
[90mline 446 <<: [33m#   - enumeration: Creates lists of consecutive numbers[0m[0m
[90mline 447 <<: [33m#[0m[0m
[90mline 448 <<: [33m# COMPLEXITY ANALYSIS:[0m[0m
[90mline 449 <<: [33m#   - append: O(n) where n is length of first list[0m[0m
[90mline 450 <<: [33m#   - reverse: O(n) using foldl accumulation[0m[0m
[90mline 451 <<: [33m#   - length: O(n) by traversing entire list[0m[0m
[90mline 452 <<: [33m#   - take/drop: O(min(n, list_length))[0m[0m
[90mline 453 <<: [33m#   - range operations: O(n) where n is the count[0m[0m
[90mline 454 <<: [33m#[0m[0m
[90mline 455 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 456 <<: [33m#   append [1, 2] [3, 4]        # Returns [1, 2, 3, 4][0m[0m
[90mline 457 <<: [33m#   reverse [1, 2, 3]           # Returns [3, 2, 1][0m[0m
[90mline 458 <<: [33m#   length [1, 2, 3, 4, 5]      # Returns 5[0m[0m
[90mline 459 <<: [33m#   take 3 [1, 2, 3, 4, 5]      # Returns [1, 2, 3][0m[0m
[90mline 460 <<: [33m#   drop 2 [1, 2, 3, 4, 5]      # Returns [3, 4, 5][0m[0m
[90mline 461 <<: [33m#   range 5                     # Returns [0, 1, 2, 3, 4][0m[0m
[90mline 462 <<: [33m#   enumFromTo 3 7              # Returns [3, 4, 5, 6, 7][0m[0m
[90mline 463 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 464 <<: append   = Î»l1 l2.l1 cons l2[0m
[32m-> append = [cons][0m
[0m [0m
[90mline 465 <<: reverse  = Î»l.foldl (Î»acc x.cons x acc) nil l[0m
[32m-> reverse = Î»l.foldl (Î»acc.Î»x.cons x acc) [] l[0m
[0m [0m
[90mline 466 <<: length   = Î»l.foldr (Î»x acc.succ acc) zero l[0m
[32m-> length = Î»l.foldr (Î»x.Î»acc.succ acc) zero l[0m
[0m [0m
[90mline 467 <<: take     = Î»n l.n (Î»f prev.if (isnil prev) nil (cons (head prev) (f (tail prev)))) (Î»x.nil) l[0m
[32m-> take = Î»n.Î»l.n (Î»f.Î»prev.if (isnil prev) [] (cons (head prev) (f (tail prev)))) (Î»x.[]) l[0m
[0m [0m
[90mline 468 <<: drop     = Î»n l.n tail l[0m
[32m-> drop = [tail][0m
[0m [0m
[90mline 469 <<: concat   = Î»ll.foldr append nil ll[0m
[32m-> concat = Î»ll.foldr append [] ll[0m
[0m [0m
[90mline 470 <<: range    = Î»n. Y (Î»f k. if (eq k n) nil (cons k (f (succ k)))) 0[0m
[32m-> range = Î»n.Y (Î»f.Î»k.if (eq k n) [] (cons k (f (succ k)))) false[0m
[0m [0m
[90mline 471 <<: countdown = Î»n. Y (Î»f k. if (iszero k) (cons 0 nil) (cons k (f (pred k)))) n[0m
[32m-> countdown = Î»n.Y (Î»f.Î»k.if (iszero k) ([false]) (cons k (f (pred k)))) n[0m
[0m [0m
[90mline 472 <<: enumFromTo = Î»start end.map (plus start) (range (succ (minus end start)))[0m
[32m-> enumFromTo = Î»start.Î»end.map (plus start) (range (succ (minus end start)))[0m
[0m [0m
[90mline 473 <<: enumFrom   = Î»start n.map (plus start) (range n)[0m
[32m-> enumFrom = Î»start.Î»n.map (plus start) (range n)[0m
[0m [0m
[90mline 474 <<: primes     = Î»n.filter isPrime (enumFromTo 2 n)[0m
[32m-> primes = Î»n.filter isPrime (enumFromTo 2 n)[0m
[0m [0m
[90mline 475 <<: repeat     = Î»n x.n (Î»acc.cons x acc) nil[0m
[32m-> repeat = Î»n.Î»x.n (Î»acc.cons x acc) [][0m
[0m [0m
[90mline 476 <<: iota       = range [33m# Alias for range[0m[0m
[32m-> iota = Î»n.Y (Î»f.Î»k.if (eq k n) [] (cons k (f (succ k)))) false[0m
[0m [0m
[90mline 477 <<: replicate  = Î»n x.n (Î»acc.cons x acc) nil[0m
[32m-> replicate = Î»n.Î»x.n (Î»acc.cons x acc) [][0m
[0m [0m
[90mline 478 <<: [0m
[90mline 479 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 480 <<: [33m# 3.5. Lists - Element Access and Querying[0m[0m
[90mline 481 <<: [33m#[0m[0m
[90mline 482 <<: [33m# These functions provide ways to access specific elements and query properties[0m[0m
[90mline 483 <<: [33m# of lists. They demonstrate how higher-order functions can be used to implement[0m[0m
[90mline 484 <<: [33m# complex queries and searches over list structures.[0m[0m
[90mline 485 <<: [33m#[0m[0m
[90mline 486 <<: [33m# ELEMENT ACCESS:[0m[0m
[90mline 487 <<: [33m#   - nth: Random access to list elements (O(n) due to linear structure)[0m[0m
[90mline 488 <<: [33m#   - last/init: Access to end of list (requires full traversal)[0m[0m
[90mline 489 <<: [33m#   - elem/notElem: Membership testing using linear search[0m[0m
[90mline 490 <<: [33m#[0m[0m
[90mline 491 <<: [33m# PREDICATES AND AGGREGATIONS:[0m[0m
[90mline 492 <<: [33m#   - any/all: Universal and existential quantification over predicates[0m[0m
[90mline 493 <<: [33m#   - find: First element satisfying a condition[0m[0m
[90mline 494 <<: [33m#   - sum/product/max/min: Numeric aggregations using foldr[0m[0m
[90mline 495 <<: [33m#[0m[0m
[90mline 496 <<: [33m# PERFORMANCE NOTES:[0m[0m
[90mline 497 <<: [33m#   - nth, last, init are O(n) due to list traversal requirements[0m[0m
[90mline 498 <<: [33m#   - elem/notElem are O(n) worst case (linear search)[0m[0m
[90mline 499 <<: [33m#   - any/all can short-circuit in some lambda calculus implementations[0m[0m
[90mline 500 <<: [33m#   - sum/product/max/min are O(n) aggregations over entire list[0m[0m
[90mline 501 <<: [33m#[0m[0m
[90mline 502 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 503 <<: [33m#   nth 2 [10, 20, 30, 40]      # Returns 30 (0-indexed access)[0m[0m
[90mline 504 <<: [33m#   last [1, 2, 3, 4]           # Returns 4 (last element)[0m[0m
[90mline 505 <<: [33m#   init [1, 2, 3, 4]           # Returns [1, 2, 3] (all but last)[0m[0m
[90mline 506 <<: [33m#   elem 3 [1, 2, 3, 4]         # Returns true (3 is in the list)[0m[0m
[90mline 507 <<: [33m#   any even [1, 3, 4, 5]       # Returns true (4 is even)[0m[0m
[0mPROGRESS::29[0m
[90mline 508 <<: [33m#   all positive [1, 2, 3]      # Returns true (all elements > 0)[0m[0m
[90mline 509 <<: [33m#   find even [1, 3, 4, 5]      # Returns 4 (first even number)[0m[0m
[90mline 510 <<: [33m#   sum [1, 2, 3, 4]            # Returns 10 (1+2+3+4)[0m[0m
[90mline 511 <<: [33m#   maximum [3, 1, 4, 1, 5]     # Returns 5 (largest element)[0m[0m
[90mline 512 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 513 <<: nth      = Î»n l.head (drop n l)[0m
[32m-> nth = Î»n.Î»l.head (drop n l)[0m
[0m [0m
[90mline 514 <<: last     = Î»l.head (reverse l)[0m
[32m-> last = Î»l.head (reverse l)[0m
[0m [0m
[90mline 515 <<: init     = Î»l.reverse (tail (reverse l))[0m
[32m-> init = Î»l.reverse (tail (reverse l))[0m
[0m [0m
[90mline 516 <<: elem     = Î»x l.any (eq x) l[0m
[32m-> elem = Î»x.Î»l.any (eq x) l[0m
[0m [0m
[90mline 517 <<: notElem  = Î»x l.not (elem x l)[0m
[32m-> notElem = Î»x.Î»l.not (elem x l)[0m
[0m [0m
[90mline 518 <<: any      = Î»p l.foldr (Î»x acc.or (p x) acc) false l[0m
[32m-> any = Î»p.Î»l.foldr (Î»x.Î»acc.or (p x) acc) false l[0m
[0m [0m
[90mline 519 <<: all      = Î»p l.foldr (Î»x acc.and (p x) acc) true l[0m
[32m-> all = Î»p.Î»l.foldr (Î»x.Î»acc.and (p x) acc) true l[0m
[0m [0m
[90mline 520 <<: find     = Î»p l.foldl (Î»acc x.if (and (isnil acc) (p x)) x acc) nil l[0m
[32m-> find = Î»p.Î»l.foldl (Î»acc.Î»x.if (and (isnil acc) (p x)) x acc) [] l[0m
[0m [0m
[90mline 521 <<: sum      = Î»l.foldr plus zero l[0m
[32m-> sum = Î»l.foldr plus zero l[0m
[0m [0m
[90mline 522 <<: product  = Î»l.foldr mult 1 l[0m
[32m-> product = Î»l.foldr mult 1 l[0m
[0m [0m
[90mline 523 <<: maximum  = Î»l.foldr (Î»x acc.if (gt x acc) x acc) zero l[0m
[32m-> maximum = Î»l.foldr (Î»x.Î»acc.if (gt x acc) x acc) zero l[0m
[0m [0m
[90mline 524 <<: minimum  = Î»l.foldr (Î»x acc.if (lt x acc) x acc) (head l) (tail l)[0m
[32m-> minimum = Î»l.foldr (Î»x.Î»acc.if (lt x acc) x acc) (head l) (tail l)[0m
[0m [0m
[90mline 525 <<: [0m
[90mline 526 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 527 <<: [33m# 3.6. Lists - Advanced Utilities[0m[0m
[90mline 528 <<: [33m#[0m[0m
[90mline 529 <<: [33m# These sophisticated list operations combine multiple basic operations to provide[0m[0m
[90mline 530 <<: [33m# powerful data processing capabilities. They represent common patterns in[0m[0m
[90mline 531 <<: [33m# functional programming and demonstrate the composability of simple operations.[0m[0m
[90mline 532 <<: [33m#[0m[0m
[90mline 533 <<: [33m# COMBINING LISTS:[0m[0m
[90mline 534 <<: [33m#   - zip: Combines two lists element-wise into pairs[0m[0m
[90mline 535 <<: [33m#   - zipWith: Combines two lists using a binary function[0m[0m
[90mline 536 <<: [33m#   - unzip: Separates a list of pairs into two lists[0m[0m
[90mline 537 <<: [33m#[0m[0m
[90mline 538 <<: [33m# SCANNING AND ACCUMULATION:[0m[0m
[90mline 539 <<: [33m#   - scanl/scanr: Like fold, but returns all intermediate results[0m[0m
[90mline 540 <<: [33m#   - These show the step-by-step progression of an accumulation[0m[0m
[90mline 541 <<: [33m#[0m[0m
[90mline 542 <<: [33m# FILTERING AND PARTITIONING:[0m[0m
[90mline 543 <<: [33m#   - nub/unique: Remove duplicate elements (O(nÂ²) with linear search)[0m[0m
[90mline 544 <<: [33m#   - partition: Split list into elements satisfying/not satisfying predicate[0m[0m
[90mline 545 <<: [33m#[0m[0m
[90mline 546 <<: [33m# MATHEMATICAL FOUNDATION:[0m[0m
[90mline 547 <<: [33m#   These operations preserve important algebraic properties and can be[0m[0m
[90mline 548 <<: [33m#   composed to create complex data transformations while maintaining[0m[0m
[90mline 549 <<: [33m#   referential transparency.[0m[0m
[90mline 550 <<: [33m#[0m[0m
[90mline 551 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 552 <<: [33m#   zip [1, 2, 3] [a, b, c]         # Returns [(1,a), (2,b), (3,c)][0m[0m
[90mline 553 <<: [33m#   zipWith plus [1, 2] [3, 4]      # Returns [4, 6] (element-wise addition)[0m[0m
[90mline 554 <<: [33m#   scanl plus 0 [1, 2, 3]          # Returns [0, 1, 3, 6] (running sums)[0m[0m
[90mline 555 <<: [33m#   scanr mult 1 [2, 3, 4]          # Returns [24, 12, 4, 1] (running products)[0m[0m
[90mline 556 <<: [33m#   nub [1, 2, 2, 3, 1]             # Returns [3, 2, 1] (duplicates removed)[0m[0m
[90mline 557 <<: [33m#   partition even [1, 2, 3, 4]     # Returns ([2, 4], [1, 3]) (evens, odds)[0m[0m
[90mline 558 <<: [33m#   unzip [(1,a), (2,b)]            # Returns ([1, 2], [a, b]) (separate pairs)[0m[0m
[90mline 559 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 560 <<: zip     = Y (Î»zip l1 l2.if (or (isnil l1) (isnil l2)) nil (cons (pair (head l1) (head l2)) (zip (tail l1) (tail l2))))[0m
[32m-> zip = <thunk:(Î»zip.Î»l1.Î»l2.if (or (isnil l1) (isnil l2)) [] (cons (pair (head l1) (head l2)) (zip (tail l1) (tail l2)))) (Y (Î»zip.Î»l1.Î»l2.if (or (isnil l1) (isnil l2)) [] (cons (pair (head l1) (head l2)) (zip (tail l1) (tail l2)))))>[0m
[0m [0m
[90mline 561 <<: zipWith = Y (Î»zipWith f l1 l2.if (or (isnil l1) (isnil l2)) nil (cons (f (head l1) (head l2)) (zipWith f (tail l1) (tail l2))))[0m
[32m-> zipWith = <thunk:(Î»zipWith.Î»f.Î»l1.Î»l2.if (or (isnil l1) (isnil l2)) [] (cons (f (head l1) (head l2)) (zipWith f (tail l1) (tail l2)))) (Y (Î»zipWith.Î»f.Î»l1.Î»l2.if (or (isnil l1) (isnil l2)) [] (cons (f (head l1) (head l2)) (zipWith f (tail l1) (tail l2)))))>[0m
[0m [0m
[90mline 562 <<: scanl    = Î»f z l.reverse (foldl (Î»acc x.cons (f (head acc) x) acc) (cons z nil) l)[0m
[32m-> scanl = Î»f.Î»z.Î»l.reverse (foldl (Î»acc.Î»x.cons (f (head acc) x) acc) ([z]) l)[0m
[0m [0m
[90mline 563 <<: scanr    = Î»f z l.foldr (Î»x acc.cons (f x (head acc)) acc) (cons z nil) l[0m
[32m-> scanr = Î»f.Î»z.Î»l.foldr (Î»x.Î»acc.cons (f x (head acc)) acc) ([z]) l[0m
[0m [0m
[90mline 564 <<: unzip   = Î»l.pair (map first l) (map second l)[0m
[32m-> unzip = Î»l.pair (map first l) (map second l)[0m
[0m [0m
[90mline 565 <<: nub     = Î»l.foldl (Î»acc x.if (elem x acc) acc (cons x acc)) nil l[0m
[32m-> nub = Î»l.foldl (Î»acc.Î»x.if (elem x acc) acc (cons x acc)) [] l[0m
[0m [0m
[90mline 566 <<: unique = nub[0m
[32m-> unique = Î»l.foldl (Î»acc.Î»x.if (elem x acc) acc (cons x acc)) [] l[0m
[0m [0m
[90mline 567 <<: partition = Î»p l.pair (filter p l) (filter (Î»x.not (p x)) l)[0m
[32m-> partition = Î»p.Î»l.pair (filter p l) (filter (Î»x.not (p x)) l)[0m
[0m [0m
[90mline 568 <<: splitAt = Î»n l.pair (take n l) (drop n l)[0m
[32m-> splitAt = Î»n.Î»l.pair (take n l) (drop n l)[0m
[0m [0m
[90mline 569 <<: [0m
[90mline 570 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 571 <<: [33m# 3.7. Set Operations on Lists[0m[0m
[90mline 572 <<: [33m#[0m[0m
[90mline 573 <<: [33m# These operations treat lists as mathematical sets, focusing on membership[0m[0m
[90mline 574 <<: [33m# and set relationships rather than order or duplicates. Note that these[0m[0m
[90mline 575 <<: [33m# implementations are not optimized for large sets since they use linear search.[0m[0m
[90mline 576 <<: [33m#[0m[0m
[90mline 577 <<: [33m# SET OPERATIONS:[0m[0m
[90mline 578 <<: [33m#   - union: All elements that appear in either set[0m[0m
[90mline 579 <<: [33m#   - intersect: Elements that appear in both sets[0m[0m
[90mline 580 <<: [33m#   - difference: Elements in first set but not in second[0m[0m
[90mline 581 <<: [33m#   - isSubset/isSuperset: Test containment relationships[0m[0m
[90mline 582 <<: [33m#[0m[0m
[90mline 583 <<: [33m# COMPLEXITY: All operations are O(nÃ—m) where n and m are the list lengths,[0m[0m
[90mline 584 <<: [33m# due to the use of linear membership testing.[0m[0m
[90mline 585 <<: [33m#[0m[0m
[90mline 586 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 587 <<: [33m#   union [1, 2] [2, 3, 4]          # Returns [1, 2, 3, 4] (all elements)[0m[0m
[90mline 588 <<: [33m#   intersect [1, 2, 3] [2, 3, 4]   # Returns [2, 3] (common elements)[0m[0m
[90mline 589 <<: [33m#   difference [1, 2, 3] [2, 4]     # Returns [1, 3] (in first, not second)[0m[0m
[90mline 590 <<: [33m#   isSubset [1, 2] [1, 2, 3]       # Returns true ([1,2] âŠ† [1,2,3])[0m[0m
[90mline 591 <<: [33m#   isSuperset [1, 2, 3] [1, 2]     # Returns true ([1,2,3] âŠ‡ [1,2])[0m[0m
[90mline 592 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 593 <<: union      = Î»l1 l2.append l1 (filter (Î»x.notElem x l1) l2)[0m
[32m-> union = Î»l1.Î»l2.append l1 (filter (Î»x.notElem x l1) l2)[0m
[0m [0m
[90mline 594 <<: intersect  = Î»l1 l2.filter (Î»x.elem x l2) l1[0m
[32m-> intersect = Î»l1.Î»l2.filter (Î»x.elem x l2) l1[0m
[0m [0m
[0mPROGRESS::34[0m
[90mline 595 <<: difference = Î»l1 l2.filter (Î»x.notElem x l2) l1[0m
[32m-> difference = Î»l1.Î»l2.filter (Î»x.notElem x l2) l1[0m
[0m [0m
[90mline 596 <<: isSubset   = Î»l1 l2.all (Î»x.elem x l2) l1[0m
[32m-> isSubset = Î»l1.Î»l2.all (Î»x.elem x l2) l1[0m
[0m [0m
[90mline 597 <<: isSuperset = Î»l1 l2.isSubset l2 l1[0m
[32m-> isSuperset = Î»l1.Î»l2.isSubset l2 l1[0m
[0m [0m
[90mline 598 <<: [0m
[90mline 599 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 600 <<: [33m# 3.8. Tree Data Structures (Binary Trees)[0m[0m
[90mline 601 <<: [33m#[0m[0m
[90mline 602 <<: [33m# A basic implementation of binary trees using Church encoding. Trees are[0m[0m
[90mline 603 <<: [33m# represented as pairs where the first element is the value and the second[0m[0m
[90mline 604 <<: [33m# element is a pair of (left_subtree, right_subtree).[0m[0m
[90mline 605 <<: [33m#[0m[0m
[90mline 606 <<: [33m# ENCODING:[0m[0m
[90mline 607 <<: [33m#   leaf v = (v, (nil, nil))        - A leaf node with value v and no children[0m[0m
[90mline 608 <<: [33m#   node v l r = (v, (l, r))        - Internal node with value v and subtrees l, r[0m[0m
[90mline 609 <<: [33m#[0m[0m
[90mline 610 <<: [33m# TREE OPERATIONS:[0m[0m
[90mline 611 <<: [33m#   - Accessor functions: treeValue, treeLeft, treeRight[0m[0m
[90mline 612 <<: [33m#   - Predicate: isLeaf (checks if both subtrees are nil)[0m[0m
[90mline 613 <<: [33m#   - Traversals: inOrder, preOrder, postOrder (visit nodes in different orders)[0m[0m
[90mline 614 <<: [33m#   - Metrics: treeSize (count nodes), treeDepth (maximum path length)[0m[0m
[90mline 615 <<: [33m#[0m[0m
[90mline 616 <<: [33m# PERFORMANCE WARNING:[0m[0m
[90mline 617 <<: [33m#   Keep trees small to avoid deep recursion that might cause stack overflow.[0m[0m
[90mline 618 <<: [33m#   These implementations use explicit recursion which can be expensive.[0m[0m
[90mline 619 <<: [33m#[0m[0m
[90mline 620 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 621 <<: [33m#   tree = node 5 (leaf 3) (leaf 7)     # Binary tree: 3 <- 5 -> 7[0m[0m
[90mline 622 <<: [33m#   treeValue tree                       # Returns 5 (root value)[0m[0m
[90mline 623 <<: [33m#   treeLeft tree                        # Returns leaf 3 (left subtree)[0m[0m
[90mline 624 <<: [33m#   isLeaf (treeLeft tree)               # Returns true (leaf 3 has no children)[0m[0m
[90mline 625 <<: [33m#   inOrder tree                         # Returns [3, 5, 7] (left-root-right)[0m[0m
[90mline 626 <<: [33m#   preOrder tree                        # Returns [5, 3, 7] (root-left-right)[0m[0m
[90mline 627 <<: [33m#   treeSize tree                        # Returns 3 (total nodes)[0m[0m
[90mline 628 <<: [33m#   treeDepth tree                       # Returns 2 (maximum depth)[0m[0m
[90mline 629 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 630 <<: leaf      = Î»v.pair v (pair nil nil)[0m
[32m-> leaf = Î»v.pair v (pair [] [])[0m
[0m [0m
[90mline 631 <<: node      = Î»v l r.pair v (pair l r)[0m
[32m-> node = Î»v.Î»l.Î»r.pair v (pair l r)[0m
[0m [0m
[90mline 632 <<: treeValue = first[0m
[32m-> treeValue = Î»p.p (true)[0m
[0m [0m
[90mline 633 <<: treeLeft  = Î»t.first (second t)[0m
[32m-> treeLeft = Î»t.first (second t)[0m
[0m [0m
[90mline 634 <<: treeRight = Î»t.second (second t)[0m
[32m-> treeRight = Î»t.second (second t)[0m
[0m [0m
[90mline 635 <<: isLeaf    = Î»t.and (isnil (treeLeft t)) (isnil (treeRight t))[0m
[32m-> isLeaf = Î»t.and (isnil (treeLeft t)) (isnil (treeRight t))[0m
[0m [0m
[90mline 636 <<: [33m# Simplified traversals to avoid recursion[0m[0m
[90mline 637 <<: inOrder   = Y (Î»f t.if (isnil t) nil (append (f (treeLeft t)) (cons (treeValue t) (f (treeRight t)))))[0m
[32m-> inOrder = <thunk:(Î»f.Î»t.if (isnil t) [] (append (f (treeLeft t)) (cons (treeValue t) (f (treeRight t))))) (Y (Î»f.Î»t.if (isnil t) [] (append (f (treeLeft t)) (cons (treeValue t) (f (treeRight t))))))>[0m
[0m [0m
[90mline 638 <<: preOrder  = Y (Î»f t.if (isnil t) nil (cons (treeValue t) (append (f (treeLeft t)) (f (treeRight t)))))[0m
[32m-> preOrder = <thunk:(Î»f.Î»t.if (isnil t) [] (cons (treeValue t) (append (f (treeLeft t)) (f (treeRight t))))) (Y (Î»f.Î»t.if (isnil t) [] (cons (treeValue t) (append (f (treeLeft t)) (f (treeRight t))))))>[0m
[0m [0m
[90mline 639 <<: postOrder = Y (Î»f t.if (isnil t) nil (append (f (treeLeft t)) (append (f (treeRight t)) (cons (treeValue t) nil))))[0m
[32m-> postOrder = <thunk:(Î»f.Î»t.if (isnil t) [] (append (f (treeLeft t)) (append (f (treeRight t)) ([treeValue t])))) (Y (Î»f.Î»t.if (isnil t) [] (append (f (treeLeft t)) (append (f (treeRight t)) ([treeValue t])))))>[0m
[0m [0m
[90mline 640 <<: [0m
[90mline 641 <<: treeSize  = Î»t.if (isnil t) 0 (succ (plus (treeSize (treeLeft t)) (treeSize (treeRight t))))[0m
[32m-> treeSize = Î»t.if (isnil t) false (succ (plus (treeSize (treeLeft t)) (treeSize (treeRight t))))[0m
[0m [0m
[90mline 642 <<: treeDepth = Î»t.if (isnil t) 0 (succ (max (treeDepth (treeLeft t)) (treeDepth (treeRight t))))[0m
[32m-> treeDepth = Î»t.if (isnil t) false (succ (max (treeDepth (treeLeft t)) (treeDepth (treeRight t))))[0m
[0m [0m
[90mline 643 <<: [0m
[90mline 644 <<: [0m
[90mline 645 <<: [33m# =============================================================================[0m[0m
[90mline 646 <<: [33m# SECTION 4: FUNCTIONAL PROGRAMMING UTILITIES[0m[0m
[90mline 647 <<: [33m#[0m[0m
[90mline 648 <<: [33m# This section provides higher-order functions, combinators, and utilities[0m[0m
[90mline 649 <<: [33m# that are common in functional programming. These build on the basic[0m[0m
[90mline 650 <<: [33m# combinators to provide more sophisticated function manipulation capabilities.[0m[0m
[90mline 651 <<: [33m# =============================================================================[0m[0m
[90mline 652 <<: [0m
[90mline 653 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 654 <<: [33m# 4.1. Function Composition and Application[0m[0m
[90mline 655 <<: [33m#[0m[0m
[90mline 656 <<: [33m# These fundamental operations form the backbone of functional programming style.[0m[0m
[90mline 657 <<: [33m# They allow building complex functions from simpler ones through composition[0m[0m
[90mline 658 <<: [33m# and provide various ways to apply functions to arguments.[0m[0m
[90mline 659 <<: [33m#[0m[0m
[90mline 660 <<: [33m# COMPOSITION THEORY:[0m[0m
[90mline 661 <<: [33m#   Function composition (âˆ˜) is associative: (f âˆ˜ g) âˆ˜ h = f âˆ˜ (g âˆ˜ h)[0m[0m
[90mline 662 <<: [33m#   This allows building complex transformations from simple building blocks.[0m[0m
[90mline 663 <<: [33m#[0m[0m
[90mline 664 <<: [33m# APPLICATION PATTERNS:[0m[0m
[90mline 665 <<: [33m#   - apply: Explicit function application (mostly for clarity)[0m[0m
[90mline 666 <<: [33m#   - compose: Creates new functions by chaining operations[0m[0m
[90mline 667 <<: [33m#   - flip: Changes argument order for partial application[0m[0m
[90mline 668 <<: [33m#   - on: Applies a binary operation to the results of a unary function[0m[0m
[90mline 669 <<: [33m#   - iterate: Repeated function application[0m[0m
[90mline 670 <<: [33m#   - times: Point-free style repeated application[0m[0m
[90mline 671 <<: [33m#[0m[0m
[90mline 672 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 673 <<: [33m#   (compose succ double) 5      # Returns 11 (succ(double(5)) = succ(10) = 11)[0m[0m
[90mline 674 <<: [33m#   flip minus 3 10             # Returns 7 (minus 10 3 = 7, arguments flipped)[0m[0m
[90mline 675 <<: [33m#   iterate succ 3 0            # Returns 3 (apply succ three times: 0â†’1â†’2â†’3)[0m[0m
[90mline 676 <<: [33m#   on plus double 3 4          # Returns 14 (plus(double(3), double(4)) = 6+8)[0m[0m
[90mline 677 <<: [33m#   times 5 succ 0              # Returns 5 (apply succ five times to 0)[0m[0m
[90mline 678 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 679 <<: apply    = Î»f x.f x[0m
[32m-> apply = 1[0m
[0m [0m
[90mline 680 <<: compose  = B[0m
[32m-> compose = Î»x.Î»y.Î»z.x (y z)[0m
[0m [0m
[90mline 681 <<: flip     = C[0m
[32m-> flip = Î»x.Î»y.Î»z.x z y[0m
[0m [0m
[90mline 682 <<: on       = Î»op f x y.op (f x) (f y)[0m
[32m-> on = Î»op.Î»f.Î»x.Î»y.op (f x) (f y)[0m
[0m [0m
[0mPROGRESS::39[0m
[90mline 683 <<: iterate  = Î»f n x.n f x[0m
[32m-> iterate = Î»f.[f][0m
[0m [0m
[90mline 684 <<: times    = Î»n.Î»f.Î»x.n f x[0m
[32m-> times = Î»n.Î»f.Î»x.n f x[0m
[0m [0m
[90mline 685 <<: [0m
[90mline 686 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 687 <<: [33m# 4.2. Currying and Partial Application[0m[0m
[90mline 688 <<: [33m#[0m[0m
[90mline 689 <<: [33m# These functions manipulate function arity and argument application patterns.[0m[0m
[90mline 690 <<: [33m# Currying transforms functions to take arguments one at a time, while partial[0m[0m
[90mline 691 <<: [33m# application fixes some arguments to create specialized functions.[0m[0m
[90mline 692 <<: [33m#[0m[0m
[90mline 693 <<: [33m# MATHEMATICAL FOUNDATION:[0m[0m
[90mline 694 <<: [33m#   Currying establishes an isomorphism between:[0m[0m
[90mline 695 <<: [33m#   - Functions of type (A Ã— B) â†’ C[0m[0m
[90mline 696 <<: [33m#   - Functions of type A â†’ (B â†’ C)[0m[0m
[90mline 697 <<: [33m#   This allows treating multi-argument functions as chains of single-argument functions.[0m[0m
[90mline 698 <<: [33m#[0m[0m
[90mline 699 <<: [33m# PRACTICAL APPLICATIONS:[0m[0m
[90mline 700 <<: [33m#   - curry: Converts pair-taking functions to curried form[0m[0m
[90mline 701 <<: [33m#   - uncurry: Converts curried functions to pair-taking form[0m[0m
[90mline 702 <<: [33m#   - partial: Creates specialized functions by fixing arguments[0m[0m
[90mline 703 <<: [33m#   - partial2: Fixes first two arguments of a three-argument function[0m[0m
[90mline 704 <<: [33m#[0m[0m
[90mline 705 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 706 <<: [33m#   add_pair = Î»p.plus (first p) (second p)  # Function taking a pair[0m[0m
[90mline 707 <<: [33m#   add_curried = curry add_pair              # Now takes two separate arguments[0m[0m
[90mline 708 <<: [33m#   add_curried 3 4                          # Returns 7[0m[0m
[90mline 709 <<: [33m#   [0m[0m
[90mline 710 <<: [33m#   add5 = partial plus 5                    # Function that adds 5[0m[0m
[90mline 711 <<: [33m#   add5 10                                  # Returns 15[0m[0m
[90mline 712 <<: [33m#   [0m[0m
[90mline 713 <<: [33m#   mult_with_pair = uncurry mult            # Takes pair instead of two args[0m[0m
[90mline 714 <<: [33m#   mult_with_pair (pair 3 4)                # Returns 12[0m[0m
[90mline 715 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 716 <<: curry    = Î»f x y.f (pair x y)[0m
[32m-> curry = Î»f.Î»x.Î»y.f (pair x y)[0m
[0m [0m
[90mline 717 <<: uncurry  = Î»f p.f (first p) (second p)[0m
[32m-> uncurry = Î»f.Î»p.f (first p) (second p)[0m
[0m [0m
[90mline 718 <<: partial  = Î»f x.Î»y.f x y[0m
[32m-> partial = Î»f.Î»x.Î»y.f x y[0m
[0m [0m
[90mline 719 <<: partial2 = Î»f x y.Î»z.f x y z[0m
[32m-> partial2 = Î»f.Î»x.Î»y.Î»z.f x y z[0m
[0m [0m
[90mline 720 <<: [33m# 3-arity curry helpers used in tests[0m[0m
[90mline 721 <<: curry3   = Î»f x y z.f (pair x (pair y z))[0m
[32m-> curry3 = Î»f.Î»x.Î»y.Î»z.f (pair x (pair y z))[0m
[0m [0m
[90mline 722 <<: uncurry3 = Î»f p.f (first p) (first (second p)) (second (second p))[0m
[32m-> uncurry3 = Î»f.Î»p.f (first p) (first (second p)) (second (second p))[0m
[0m [0m
[90mline 723 <<: [0m
[90mline 724 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 725 <<: [33m# 4.3. Additional Combinators[0m[0m
[90mline 726 <<: [33m#[0m[0m
[90mline 727 <<: [33m# These are classic combinators from combinatory logic, many with bird names[0m[0m
[90mline 728 <<: [33m# from Raymond Smullyan's "To Mock a Mockingbird". They provide alternative[0m[0m
[90mline 729 <<: [33m# ways to express common functional programming patterns.[0m[0m
[90mline 730 <<: [33m#[0m[0m
[90mline 731 <<: [33m# BIRD NAMES AND THEIR MEANINGS:[0m[0m
[90mline 732 <<: [33m#   - Mockingbird (Ï‰): Self-application, foundation of recursion[0m[0m
[90mline 733 <<: [33m#   - Thrush (T): Reverse application, useful for data flow[0m[0m
[90mline 734 <<: [33m#   - Cardinal (C): Argument flipping, enables partial application patterns[0m[0m
[90mline 735 <<: [33m#   - Bluebird (B): Function composition, building complex functions[0m[0m
[90mline 736 <<: [33m#   - Kestrel (K): Constant functions, basis for conditional logic[0m[0m
[90mline 737 <<: [33m#   - Warbler (W): Duplication combinator, applies function to same argument twice[0m[0m
[90mline 738 <<: [33m#   - Starling (S): Most powerful combinator, can express any computable function[0m[0m
[90mline 739 <<: [33m#[0m[0m
[90mline 740 <<: [33m# THEORETICAL IMPORTANCE:[0m[0m
[90mline 741 <<: [33m#   These combinators form a complete basis for computation - any computable[0m[0m
[90mline 742 <<: [33m#   function can be expressed using just S and K combinators.[0m[0m
[90mline 743 <<: [33m#[0m[0m
[90mline 744 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 745 <<: [33m#   omega plus                   # Returns plus plus (self-application)[0m[0m
[90mline 746 <<: [33m#   thrush 42 succ               # Returns 43 (apply succ to 42)[0m[0m
[90mline 747 <<: [33m#   warbler plus 5               # Returns 10 (plus 5 5)[0m[0m
[90mline 748 <<: [33m#   cardinal minus 3 10          # Returns 7 (minus with flipped arguments)[0m[0m
[90mline 749 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 750 <<: const    = K[0m
[32m-> const = K[0m
[0m [0m
[90mline 751 <<: omega    = Î»x.x x[0m
[32m-> omega = Î»x.x x[0m
[0m [0m
[90mline 752 <<: mockingbird = omega[0m
[32m-> mockingbird = Î»x.x x[0m
[0m [0m
[90mline 753 <<: thrush   = Î»x f.f x[0m
[32m-> thrush = Î»x.Î»f.f x[0m
[0m [0m
[90mline 754 <<: cardinal = flip[0m
[32m-> cardinal = Î»x.Î»y.Î»z.x z y[0m
[0m [0m
[90mline 755 <<: bluebird = compose[0m
[32m-> bluebird = Î»x.Î»y.Î»z.x (y z)[0m
[0m [0m
[90mline 756 <<: kestrel  = const[0m
[32m-> kestrel = K[0m
[0m [0m
[90mline 757 <<: warbler  = Î»f x.f x x[0m
[32m-> warbler = [x][0m
[0m [0m
[90mline 758 <<: starling = S[0m
[32m-> starling = Î»x.Î»y.Î»z.x z (y z)[0m
[0m [0m
[90mline 759 <<: [0m
[90mline 760 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 761 <<: [33m# 4.4. Looping Constructs[0m[0m
[90mline 762 <<: [33m#[0m[0m
[90mline 763 <<: [33m# These combinators provide imperative-style looping in a purely functional way.[0m[0m
[90mline 764 <<: [33m# The WHILE combinator demonstrates how iteration can be expressed through[0m[0m
[90mline 765 <<: [33m# recursion and conditional application.[0m[0m
[90mline 766 <<: [33m#[0m[0m
[90mline 767 <<: [33m# WHILE LOOP SEMANTICS:[0m[0m
[90mline 768 <<: [33m#   WHILE condition body state repeatedly applies body to state while[0m[0m
[90mline 769 <<: [33m#   condition(state) returns true. This provides familiar iterative patterns[0m[0m
[0mPROGRESS::44[0m
[90mline 770 <<: [33m#   within the pure functional paradigm.[0m[0m
[90mline 771 <<: [33m#[0m[0m
[90mline 772 <<: [33m# IMPLEMENTATION STRATEGY:[0m[0m
[90mline 773 <<: [33m#   Uses the Y combinator for recursion with conditional termination.[0m[0m
[90mline 774 <<: [33m#   The loop continues by recursively calling itself with the updated state,[0m[0m
[90mline 775 <<: [33m#   or terminates by returning the final state.[0m[0m
[90mline 776 <<: [33m#[0m[0m
[90mline 777 <<: [33m# SAFETY WARNING:[0m[0m
[90mline 778 <<: [33m#   Infinite loops are possible if the condition never becomes false![0m[0m
[90mline 779 <<: [33m#   Always ensure the body function eventually leads to condition failure.[0m[0m
[90mline 780 <<: [33m#[0m[0m
[90mline 781 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 782 <<: [33m#   # Count down from 5 to 0[0m[0m
[90mline 783 <<: [33m#   countdown_from_5 = WHILE (Î»n.gt n 0) pred 5    # Returns 0[0m[0m
[90mline 784 <<: [33m#   [0m[0m
[90mline 785 <<: [33m#   # Alternative GCD implementation using WHILE[0m[0m
[90mline 786 <<: [33m#   gcd1 12 8                                      # Returns 4[0m[0m
[90mline 787 <<: [33m#   [0m[0m
[90mline 788 <<: [33m#   # Custom iteration: multiply by 2 until > 100[0m[0m
[90mline 789 <<: [33m#   grow = WHILE (Î»n.leq n 100) (mult 2) 1         # Returns 128[0m[0m
[90mline 790 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 791 <<: [33m# A general-purpose WHILE loop combinator[0m[0m
[90mline 792 <<: WHILE = Y (Î»loop. Î»cond body state. if (cond state) (loop cond body (body state)) state)[0m
[32m-> WHILE = <thunk:(Î»loop.Î»cond.Î»body.Î»state.if (cond state) (loop cond body (body state)) state) (Y (Î»loop.Î»cond.Î»body.Î»state.if (cond state) (loop cond body (body state)) state))>[0m
[0m [0m
[90mline 793 <<: [0m
[90mline 794 <<: [33m# Example of using WHILE for GCD (less efficient than the recursive version)[0m[0m
[90mline 795 <<: GCD_STEP = Î»p. if (gt (first p) (second p)) \[0m
[90mline 796 <<:                  (pair (minus (first p) (second p)) (second p)) \[0m
[90mline 797 <<:                  (pair (first p) (minus (second p) (first p)))[0m
[32m-> GCD_STEP = Î»p.if (gt (first p) (second p)) (pair (minus (first p) (second p)) (second p)) (pair (first p) (minus (second p) (first p)))[0m
[0m [0m
[90mline 798 <<: gcd1 = Î»m n. if (or (iszero m) (iszero n)) (if (iszero m) n m) \[0m
[90mline 799 <<:     (first (WHILE (Î»p. neq (first p) (second p)) GCD_STEP (pair m n)))[0m
[32m-> gcd1 = Î»m.Î»n.if (or (iszero m) (iszero n)) (if (iszero m) n m) (first (WHILE (Î»p.neq (first p) (second p)) GCD_STEP (pair m n)))[0m
[0m [0m
[90mline 800 <<: [0m
[90mline 801 <<: [0m
[90mline 802 <<: [33m# =============================================================================[0m[0m
[90mline 803 <<: [33m# SECTION 5: ALGEBRAIC DATA TYPES[0m[0m
[90mline 804 <<: [33m#[0m[0m
[90mline 805 <<: [33m# This section defines common algebraic data types like Maybe (Optional) and[0m[0m
[90mline 806 <<: [33m# Either, which are useful for handling computations that can fail or have[0m[0m
[90mline 807 <<: [33m# alternative results.[0m[0m
[90mline 808 <<: [33m# =============================================================================[0m[0m
[90mline 809 <<: [0m
[90mline 810 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 811 <<: [33m# 5.1. Maybe (Optional) Type[0m[0m
[90mline 812 <<: [33m#[0m[0m
[90mline 813 <<: [33m# The Maybe type is a foundational algebraic data type that safely represents[0m[0m
[90mline 814 <<: [33m# the presence or absence of a value. This eliminates the need for null[0m[0m
[90mline 815 <<: [33m# references and provides a principled way to handle optional values.[0m[0m
[90mline 816 <<: [33m#[0m[0m
[90mline 817 <<: [33m# ENCODING:[0m[0m
[90mline 818 <<: [33m#   nothing = nil                   # Represents absence of value[0m[0m
[90mline 819 <<: [33m#   just x = pair true x           # Represents presence of value x[0m[0m
[90mline 820 <<: [33m#[0m[0m
[90mline 821 <<: [33m# TYPE THEORY:[0m[0m
[90mline 822 <<: [33m#   Maybe A = Nothing | Just A[0m[0m
[90mline 823 <<: [33m#   This creates a sum type that extends any type A with a "null" value.[0m[0m
[90mline 824 <<: [33m#   The encoding uses Church pairs where the first element indicates presence.[0m[0m
[90mline 825 <<: [33m#[0m[0m
[90mline 826 <<: [33m# SAFETY BENEFITS:[0m[0m
[90mline 827 <<: [33m#   - No null pointer exceptions or undefined behavior[0m[0m
[90mline 828 <<: [33m#   - Explicit handling of absent values in the type system[0m[0m
[90mline 829 <<: [33m#   - Compositional operations that preserve safety[0m[0m
[90mline 830 <<: [33m#[0m[0m
[90mline 831 <<: [33m# FUNCTIONAL PATTERNS:[0m[0m
[90mline 832 <<: [33m#   - maybe: Eliminates the Maybe with a default and transformation function[0m[0m
[90mline 833 <<: [33m#   - maybeMap: Applies a function only if value is present (functor law)[0m[0m
[90mline 834 <<: [33m#   - Chaining: Sequence operations that might fail[0m[0m
[90mline 835 <<: [33m#[0m[0m
[90mline 836 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 837 <<: [33m#   value1 = just 42              # Contains the value 42[0m[0m
[90mline 838 <<: [33m#   value2 = nothing              # Contains no value[0m[0m
[90mline 839 <<: [33m#   [0m[0m
[90mline 840 <<: [33m#   fromMaybe 0 value1            # Returns 42[0m[0m
[90mline 841 <<: [33m#   fromMaybe 0 value2            # Returns 0 (default)[0m[0m
[90mline 842 <<: [33m#   [0m[0m
[90mline 843 <<: [33m#   maybe "empty" show value1     # Returns "42" (converted to string)[0m[0m
[90mline 844 <<: [33m#   maybe "empty" show value2     # Returns "empty"[0m[0m
[90mline 845 <<: [33m#   [0m[0m
[90mline 846 <<: [33m#   maybeMap (mult 2) value1      # Returns just 84[0m[0m
[90mline 847 <<: [33m#   maybeMap (mult 2) value2      # Returns nothing[0m[0m
[90mline 848 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 849 <<: nothing   = nil[0m
[32m-> nothing = false[0m
[0m [0m
[90mline 850 <<: just      = Î»x.pair true x[0m
[32m-> just = Î»x.pair true x[0m
[0m [0m
[90mline 851 <<: isNothing = isnil[0m
[32m-> isNothing = Î»l.l (Î»x.Î»xs.false) true[0m
[0m [0m
[90mline 852 <<: isJust    = Î»m.not (isNothing m)[0m
[32m-> isJust = Î»m.not (isNothing m)[0m
[0m [0m
[90mline 853 <<: fromJust  = second[0m
[32m-> fromJust = Î»p.p false[0m
[0m [0m
[90mline 854 <<: maybe     = Î»def f m.if (isNothing m) def (f (fromJust m))[0m
[32m-> maybe = Î»def.Î»f.Î»m.if (isNothing m) def (f (fromJust m))[0m
[0m [0m
[90mline 855 <<: fromMaybe = Î»def m.if (isNothing m) def (fromJust m)[0m
[32m-> fromMaybe = Î»def.Î»m.if (isNothing m) def (fromJust m)[0m
[0m [0m
[90mline 856 <<: [0m
[90mline 857 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[0mPROGRESS::49[0m
[90mline 858 <<: [33m# 5.2. Either Type[0m[0m
[90mline 859 <<: [33m#[0m[0m
[90mline 860 <<: [33m# The Either type represents a value that can be one of two types, commonly[0m[0m
[90mline 861 <<: [33m# used for error handling where Left contains an error and Right contains[0m[0m
[90mline 862 <<: [33m# a successful result. This provides structured error handling without exceptions.[0m[0m
[90mline 863 <<: [33m#[0m[0m
[90mline 864 <<: [33m# ENCODING:[0m[0m
[90mline 865 <<: [33m#   left x = pair false x         # Left value (typically error)[0m[0m
[90mline 866 <<: [33m#   right x = pair true x         # Right value (typically success)[0m[0m
[90mline 867 <<: [33m#[0m[0m
[90mline 868 <<: [33m# ERROR HANDLING PATTERN:[0m[0m
[90mline 869 <<: [33m#   Either Error Success[0m[0m
[90mline 870 <<: [33m#   - Left contains error information[0m[0m
[90mline 871 <<: [33m#   - Right contains successful computation result[0m[0m
[90mline 872 <<: [33m#   - Operations can be chained, short-circuiting on first error[0m[0m
[90mline 873 <<: [33m#[0m[0m
[90mline 874 <<: [33m# BIAS TOWARDS RIGHT:[0m[0m
[90mline 875 <<: [33m#   By convention, Either is "right-biased" - operations like map apply[0m[0m
[90mline 876 <<: [33m#   to Right values and preserve Left values unchanged.[0m[0m
[90mline 877 <<: [33m#[0m[0m
[90mline 878 <<: [33m# COMPARISON WITH MAYBE:[0m[0m
[90mline 879 <<: [33m#   Maybe: Presence/absence with no error information[0m[0m
[90mline 880 <<: [33m#   Either: Choice between two values, with error context[0m[0m
[90mline 881 <<: [33m#[0m[0m
[90mline 882 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 883 <<: [33m#   success = right 42            # Successful computation[0m[0m
[90mline 884 <<: [33m#   error = left "division by zero"  # Error with message[0m[0m
[90mline 885 <<: [33m#   [0m[0m
[90mline 886 <<: [33m#   either show id success        # Returns 42 (right side)[0m[0m
[90mline 887 <<: [33m#   either show id error          # Returns "division by zero" (left side)[0m[0m
[90mline 888 <<: [33m#   [0m[0m
[90mline 889 <<: [33m#   # Error handling in division[0m[0m
[90mline 890 <<: [33m#   divide = Î»a b.if (iszero b) (left "divide by zero") (right (div a b))[0m[0m
[90mline 891 <<: [33m#   divide 10 2                   # Returns right 5[0m[0m
[90mline 892 <<: [33m#   divide 10 0                   # Returns left "divide by zero"[0m[0m
[90mline 893 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 894 <<: left      = Î»x.pair false x[0m
[32m-> left = Î»x.pair false x[0m
[0m [0m
[90mline 895 <<: right     = Î»x.pair true x[0m
[32m-> right = Î»x.pair true x[0m
[0m [0m
[90mline 896 <<: isLeft    = Î»e.not (first e)[0m
[32m-> isLeft = Î»e.not (first e)[0m
[0m [0m
[90mline 897 <<: isRight   = first[0m
[32m-> isRight = Î»p.p (true)[0m
[0m [0m
[90mline 898 <<: fromLeft  = second[0m
[32m-> fromLeft = Î»p.p false[0m
[0m [0m
[90mline 899 <<: fromRight = second[0m
[32m-> fromRight = Î»p.p false[0m
[0m [0m
[90mline 900 <<: either    = Î»f g e.if (isLeft e) (f (fromLeft e)) (g (fromRight e))[0m
[32m-> either = Î»f.Î»g.Î»e.if (isLeft e) (f (fromLeft e)) (g (fromRight e))[0m
[0m [0m
[90mline 901 <<: [0m
[90mline 902 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 903 <<: [33m# 5.3. Safe Operations using Maybe[0m[0m
[90mline 904 <<: [33m#[0m[0m
[90mline 905 <<: [33m# These functions demonstrate how Maybe types enable safe operations on[0m[0m
[90mline 906 <<: [33m# potentially dangerous computations. Instead of crashing or returning[0m[0m
[90mline 907 <<: [33m# invalid results, they return structured optional values.[0m[0m
[90mline 908 <<: [33m#[0m[0m
[90mline 909 <<: [33m# SAFETY PATTERN:[0m[0m
[90mline 910 <<: [33m#   Traditional: f(x) â†’ crash if x invalid[0m[0m
[90mline 911 <<: [33m#   Safe: safef(x) â†’ nothing if x invalid, just result if x valid[0m[0m
[90mline 912 <<: [33m#[0m[0m
[90mline 913 <<: [33m# COMPOSITION SAFETY:[0m[0m
[90mline 914 <<: [33m#   Safe operations can be chained using monadic bind patterns,[0m[0m
[90mline 915 <<: [33m#   automatically handling the failure cases throughout the chain.[0m[0m
[90mline 916 <<: [33m#[0m[0m
[90mline 917 <<: [33m# EXAMPLES OF SAFETY:[0m[0m
[90mline 918 <<: [33m#   - safehead: No crash on empty lists[0m[0m
[90mline 919 <<: [33m#   - safediv: No division by zero[0m[0m
[90mline 920 <<: [33m#   - safenth: No index out of bounds[0m[0m
[90mline 921 <<: [33m#   - safeMinimum/Maximum: No crash on empty collections[0m[0m
[90mline 922 <<: [33m#[0m[0m
[90mline 923 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 924 <<: [33m#   safehead (cons 1 (cons 2 nil))    # Returns just 1[0m[0m
[90mline 925 <<: [33m#   safehead nil                      # Returns nothing[0m[0m
[90mline 926 <<: [33m#   [0m[0m
[90mline 927 <<: [33m#   safediv 10 2                      # Returns just 5[0m[0m
[90mline 928 <<: [33m#   safediv 10 0                      # Returns nothing[0m[0m
[90mline 929 <<: [33m#   [0m[0m
[90mline 930 <<: [33m#   safenth 0 (cons 'a' (cons 'b' nil))  # Returns just 'a'[0m[0m
[90mline 931 <<: [33m#   safenth 5 (cons 'a' nil)             # Returns nothing[0m[0m
[90mline 932 <<: [33m#   [0m[0m
[90mline 933 <<: [33m#   # Chaining safe operations[0m[0m
[90mline 934 <<: [33m#   processFirst = Î»l.maybeMap (mult 2) (safehead l)[0m[0m
[90mline 935 <<: [33m#   processFirst (cons 5 nil)         # Returns just 10[0m[0m
[90mline 936 <<: [33m#   processFirst nil                  # Returns nothing[0m[0m
[90mline 937 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 938 <<: safehead = Î»l.if (isnil l) nothing (just (head l))[0m
[32m-> safehead = Î»l.if (isnil l) nothing (just (head l))[0m
[0m [0m
[90mline 939 <<: safetail = Î»l.if (isnil l) nothing (just (tail l))[0m
[32m-> safetail = Î»l.if (isnil l) nothing (just (tail l))[0m
[0m [0m
[90mline 940 <<: safenth  = Î»n l.if (gt n (pred (length l))) nothing (just (nth n l))[0m
[32m-> safenth = Î»n.Î»l.if (gt n (pred (length l))) nothing (just (nth n l))[0m
[0m [0m
[90mline 941 <<: [33m# safediv: legacy lowercase naming kept for backward compatibility.[0m[0m
[90mline 942 <<: [33m# Prefer using safeDiv (alias) for consistency with other safe* functions.[0m[0m
[90mline 943 <<: safediv  = Î»a b.if (iszero b) nothing (just (div a b))[0m
[32m-> safediv = Î»a.Î»b.if (iszero b) nothing (just (div a b))[0m
[0m [0m
[90mline 944 <<: [33m# Alias with preferred casing[0m[0m
[0mPROGRESS::54[0m
[90mline 945 <<: safeDiv  = safediv[0m
[32m-> safeDiv = Î»a.Î»b.if (iszero b) nothing (just (div a b))[0m
[0m [0m
[90mline 946 <<: safeMinimum = Î»l.if (isnil l) nothing (just (minimum l))[0m
[32m-> safeMinimum = Î»l.if (isnil l) nothing (just (minimum l))[0m
[0m [0m
[90mline 947 <<: safeMaximum = Î»l.if (isnil l) nothing (just (maximum l))[0m
[32m-> safeMaximum = Î»l.if (isnil l) nothing (just (maximum l))[0m
[0m [0m
[90mline 948 <<: [33m# safeInit[0m[0m
[90mline 949 <<: [33m# Returns the list without its last element (or nil if empty/singleton).[0m[0m
[90mline 950 <<: [33m# NOTE: Unlike other safe* functions this returns a plain list, NOT a Maybe.[0m[0m
[90mline 951 <<: [33m# Use safeInitMaybe if you need a Maybe-encoded result.[0m[0m
[90mline 952 <<: safeInit = Î»l.if (or (isnil l) (isnil (tail l))) nil (reverse (tail (reverse l)))[0m
[32m-> safeInit = Î»l.if (or (isnil l) (isnil (tail l))) [] (reverse (tail (reverse l)))[0m
[0m [0m
[90mline 953 <<: [0m
[90mline 954 <<: [33m# Maybe-encoded variant for consistency with safehead/safetail/etc.[0m[0m
[90mline 955 <<: safeInitMaybe = Î»l.if (or (isnil l) (isnil (tail l))) nothing (just (reverse (tail (reverse l))))[0m
[32m-> safeInitMaybe = Î»l.if (or (isnil l) (isnil (tail l))) nothing (just (reverse (tail (reverse l))))[0m
[0m [0m
[90mline 956 <<: maybeMap = Î»f m.if (isNothing m) nothing (just (f (fromJust m)))[0m
[32m-> maybeMap = Î»f.Î»m.if (isNothing m) nothing (just (f (fromJust m)))[0m
[0m [0m
[90mline 957 <<: [0m
[90mline 958 <<: [0m
[90mline 959 <<: [33m# =============================================================================[0m[0m
[90mline 960 <<: [33m# SECTION 6: STATE AND I/O[0m[0m
[90mline 961 <<: [33m#[0m[0m
[90mline 962 <<: [33m# This section provides utilities for managing state and simulating I/O in a[0m[0m
[90mline 963 <<: [33m# purely functional way. These patterns demonstrate how imperative concepts[0m[0m
[90mline 964 <<: [33m# can be expressed through pure functional programming using monadic patterns.[0m[0m
[90mline 965 <<: [33m#[0m[0m
[90mline 966 <<: [33m# STATE MONAD CONCEPT:[0m[0m
[90mline 967 <<: [33m#   The State monad encapsulates stateful computations as functions that[0m[0m
[90mline 968 <<: [33m#   take an initial state and return both a result and a new state.[0m[0m
[90mline 969 <<: [33m#   This allows for stateful programming without mutable variables.[0m[0m
[90mline 970 <<: [33m#[0m[0m
[90mline 971 <<: [33m# I/O SIMULATION:[0m[0m
[90mline 972 <<: [33m#   Since pure lambda calculus has no I/O primitives, we simulate I/O[0m[0m
[90mline 973 <<: [33m#   operations using list transformations and stream processing patterns.[0m[0m
[90mline 974 <<: [33m#[0m[0m
[90mline 975 <<: [33m# MONADIC LAWS:[0m[0m
[90mline 976 <<: [33m#   These combinators follow the monadic laws for composition:[0m[0m
[90mline 977 <<: [33m#   - Left identity: returnState >=> f â‰¡ f[0m[0m
[90mline 978 <<: [33m#   - Right identity: f >=> returnState â‰¡ f  [0m[0m
[90mline 979 <<: [33m#   - Associativity: (f >=> g) >=> h â‰¡ f >=> (g >=> h)[0m[0m
[90mline 980 <<: [33m# =============================================================================[0m[0m
[90mline 981 <<: [0m
[90mline 982 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 983 <<: [33m# 6.1. State Monad Helpers[0m[0m
[90mline 984 <<: [33m#[0m[0m
[90mline 985 <<: [33m# The State monad allows for stateful computations in pure functional programming.[0m[0m
[90mline 986 <<: [33m# A stateful computation is represented as a function: State â†’ (Result, NewState)[0m[0m
[90mline 987 <<: [33m#[0m[0m
[90mline 988 <<: [33m# MONAD OPERATIONS:[0m[0m
[90mline 989 <<: [33m#   returnState: Wraps a pure value in the state monad[0m[0m
[90mline 990 <<: [33m#   bindState: Sequences stateful computations (monadic bind)[0m[0m
[90mline 991 <<: [33m#   getState: Reads the current state[0m[0m
[90mline 992 <<: [33m#   putState: Sets a new state[0m[0m
[90mline 993 <<: [33m#   runState: Executes a stateful computation with initial state[0m[0m
[90mline 994 <<: [33m#[0m[0m
[90mline 995 <<: [33m# COMPUTATIONAL PATTERN:[0m[0m
[90mline 996 <<: [33m#   - Each operation takes state and returns (value, new_state)[0m[0m
[90mline 997 <<: [33m#   - bindState threads state through computations automatically[0m[0m
[90mline 998 <<: [33m#   - Provides illusion of mutable state in pure functional setting[0m[0m
[90mline 999 <<: [33m#[0m[0m
[90mline 1000 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1001 <<: [33m#   # Simple counter that increments state[0m[0m
[90mline 1002 <<: [33m#   increment = Î»s.pair (plus s 1) (plus s 1)[0m[0m
[90mline 1003 <<: [33m#   [0m[0m
[90mline 1004 <<: [33m#   # Stateful computation that doubles then increments[0m[0m
[90mline 1005 <<: [33m#   doubleInc = bindState (Î»x.returnState (mult x 2)) [0m[0m
[90mline 1006 <<: [33m#                        (Î»y.Î»s.pair (plus y 1) (plus s 1))[0m[0m
[90mline 1007 <<: [33m#   [0m[0m
[90mline 1008 <<: [33m#   runState increment 5          # Returns pair 6 6[0m[0m
[90mline 1009 <<: [33m#   runState getState 42          # Returns pair 42 42[0m[0m
[90mline 1010 <<: [33m#   runState (putState 100) 42    # Returns pair nil 100[0m[0m
[90mline 1011 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1012 <<: returnState = Î»x s.pair x s[0m
[32m-> returnState = Î»x.Î»s.pair x s[0m
[0m [0m
[90mline 1013 <<: bindState   = Î»m f s.f (first (m s)) (second (m s))[0m
[32m-> bindState = Î»m.Î»f.Î»s.f (first (m s)) (second (m s))[0m
[0m [0m
[90mline 1014 <<: getState    = Î»s.pair s s[0m
[32m-> getState = Î»s.pair s s[0m
[0m [0m
[90mline 1015 <<: putState    = Î»s.Î»_.pair nil s[0m
[32m-> putState = Î»s.Î»_placeholder1.pair [] s[0m
[0m [0m
[90mline 1016 <<: runState    = Î»m s.m s[0m
[32m-> runState = 1[0m
[0m [0m
[90mline 1017 <<: [0m
[90mline 1018 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1019 <<: [33m# 6.2. I/O Simulation[0m[0m
[90mline 1020 <<: [33m#[0m[0m
[90mline 1021 <<: [33m# These functions simulate I/O by treating lists of characters (numbers) as[0m[0m
[90mline 1022 <<: [33m# input/output streams. This demonstrates how imperative I/O can be modeled[0m[0m
[90mline 1023 <<: [33m# functionally using stream transformations.[0m[0m
[90mline 1024 <<: [33m#[0m[0m
[90mline 1025 <<: [33m# STREAM-BASED I/O MODEL:[0m[0m
[90mline 1026 <<: [33m#   Input: Stream of characters (list of ASCII codes)[0m[0m
[90mline 1027 <<: [33m#   Output: Stream of characters being produced[0m[0m
[90mline 1028 <<: [33m#   Operations transform or consume these streams[0m[0m
[90mline 1029 <<: [33m#[0m[0m
[90mline 1030 <<: [33m# CHARACTER REPRESENTATION:[0m[0m
[90mline 1031 <<: [33m#   Characters are represented as Church numerals corresponding to ASCII codes:[0m[0m
[90mline 1032 <<: [33m#   'A' = 65, 'a' = 97, '0' = 48, space = 32, newline = 10[0m[0m
[0mPROGRESS::59[0m
[90mline 1033 <<: [33m#[0m[0m
[90mline 1034 <<: [33m# FUNCTIONAL I/O PRINCIPLES:[0m[0m
[90mline 1035 <<: [33m#   - No side effects: I/O operations return new streams[0m[0m
[90mline 1036 <<: [33m#   - Composable: Operations can be chained and combined[0m[0m
[90mline 1037 <<: [33m#   - Referentially transparent: Same input always produces same output[0m[0m
[90mline 1038 <<: [33m#[0m[0m
[90mline 1039 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1040 <<: [33m#   # Output a character to stream[0m[0m
[90mline 1041 <<: [33m#   output1 = putChar 65 nil              # Outputs 'A'[0m[0m
[90mline 1042 <<: [33m#   output2 = putChar 66 output1          # Outputs "BA"[0m[0m
[90mline 1043 <<: [33m#   [0m[0m
[90mline 1044 <<: [33m#   # Read first character from input[0m[0m
[90mline 1045 <<: [33m#   input = cons 72 (cons 105 nil)        # "Hi"[0m[0m
[90mline 1046 <<: [33m#   firstChar = getChar input             # Returns 72 ('H')[0m[0m
[90mline 1047 <<: [33m#   [0m[0m
[90mline 1048 <<: [33m#   # Append strings[0m[0m
[90mline 1049 <<: [33m#   hello = cons 72 (cons 101 (cons 108 (cons 108 (cons 111 nil))))  # "Hello"[0m[0m
[90mline 1050 <<: [33m#   world = cons 87 (cons 111 (cons 114 (cons 108 (cons 100 nil))))  # "World"[0m[0m
[90mline 1051 <<: [33m#   greeting = putStr hello world         # "HelloWorld"[0m[0m
[90mline 1052 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1053 <<: putChar = Î»c.cons c[0m
[32m-> putChar = Î»c.cons c[0m
[0m [0m
[90mline 1054 <<: getChar = head[0m
[32m-> getChar = Î»l.l (true) [][0m
[0m [0m
[90mline 1055 <<: putStr  = append[0m
[32m-> putStr = [cons][0m
[0m [0m
[90mline 1056 <<: getLine = Î»l.filter (neq 10) l [33m# Simplified: take until newline[0m[0m
[32m-> getLine = Î»l.filter (neq 10) l[0m
[0m [0m
[90mline 1057 <<: [0m
[90mline 1058 <<: [0m
[90mline 1059 <<: [33m# =============================================================================[0m[0m
[90mline 1060 <<: [33m# SECTION 7: STRING AND CHARACTER SIMULATION[0m[0m
[90mline 1061 <<: [33m#[0m[0m
[90mline 1062 <<: [33m# This section provides utilities for working with "strings" and "characters,"[0m[0m
[90mline 1063 <<: [33m# which are represented as lists of numbers (ASCII codes). This demonstrates[0m[0m
[90mline 1064 <<: [33m# how higher-level data types can be built from primitive Church encodings.[0m[0m
[90mline 1065 <<: [33m#[0m[0m
[90mline 1066 <<: [33m# STRING REPRESENTATION:[0m[0m
[90mline 1067 <<: [33m#   Strings are lists of Church numerals representing ASCII character codes.[0m[0m
[90mline 1068 <<: [33m#   This encoding allows for uniform treatment of textual and numeric data[0m[0m
[90mline 1069 <<: [33m#   while maintaining the pure functional paradigm.[0m[0m
[90mline 1070 <<: [33m#[0m[0m
[90mline 1071 <<: [33m# ASCII ENCODING FOUNDATION:[0m[0m
[90mline 1072 <<: [33m#   - Printable characters: 32-126[0m[0m
[90mline 1073 <<: [33m#   - Digits: 48-57 ('0'-'9')[0m[0m
[90mline 1074 <<: [33m#   - Uppercase: 65-90 ('A'-'Z') [0m[0m
[90mline 1075 <<: [33m#   - Lowercase: 97-122 ('a'-'z')[0m[0m
[90mline 1076 <<: [33m#   - Whitespace: space(32), tab(9), newline(10)[0m[0m
[90mline 1077 <<: [33m#[0m[0m
[90mline 1078 <<: [33m# CHARACTER CLASSIFICATION:[0m[0m
[90mline 1079 <<: [33m#   Predicate functions test character properties using ASCII code ranges.[0m[0m
[90mline 1080 <<: [33m#   These enable parsing and text processing operations.[0m[0m
[90mline 1081 <<: [33m#[0m[0m
[90mline 1082 <<: [33m# TEXT PROCESSING CAPABILITIES:[0m[0m
[90mline 1083 <<: [33m#   - Case conversion (upper/lower)[0m[0m
[90mline 1084 <<: [33m#   - Character type testing (digit, alpha, etc.)[0m[0m
[90mline 1085 <<: [33m#   - String manipulation through list operations[0m[0m
[90mline 1086 <<: [33m#   - Text parsing and formatting[0m[0m
[90mline 1087 <<: [33m# =============================================================================[0m[0m
[90mline 1088 <<: [0m
[90mline 1089 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1090 <<: [33m# 7.1. ASCII Constants and Predicates[0m[0m
[90mline 1091 <<: [33m#[0m[0m
[90mline 1092 <<: [33m# These constants and predicates provide the foundation for character-based[0m[0m
[90mline 1093 <<: [33m# text processing. They define important ASCII values and classification[0m[0m
[90mline 1094 <<: [33m# functions for different character types.[0m[0m
[90mline 1095 <<: [33m#[0m[0m
[90mline 1096 <<: [33m# ASCII CONSTANTS:[0m[0m
[90mline 1097 <<: [33m#   Critical whitespace and control characters used in text processing.[0m[0m
[90mline 1098 <<: [33m#   These form the basis for parsing and formatting operations.[0m[0m
[90mline 1099 <<: [33m#[0m[0m
[90mline 1100 <<: [33m# PREDICATE FUNCTIONS:[0m[0m
[90mline 1101 <<: [33m#   Character classification functions that test properties of ASCII codes.[0m[0m
[90mline 1102 <<: [33m#   These enable sophisticated text parsing and validation.[0m[0m
[90mline 1103 <<: [33m#[0m[0m
[90mline 1104 <<: [33m# RANGE-BASED CLASSIFICATION:[0m[0m
[90mline 1105 <<: [33m#   Uses numerical comparisons on ASCII codes to determine character types.[0m[0m
[90mline 1106 <<: [33m#   This approach is efficient and leverages the ordered nature of ASCII.[0m[0m
[90mline 1107 <<: [33m#[0m[0m
[90mline 1108 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1109 <<: [33m#   isdigit 48                    # Returns true ('0')[0m[0m
[90mline 1110 <<: [33m#   isdigit 65                    # Returns false ('A')[0m[0m
[90mline 1111 <<: [33m#   [0m[0m
[90mline 1112 <<: [33m#   islower 97                    # Returns true ('a')[0m[0m
[90mline 1113 <<: [33m#   isupper 97                    # Returns false ('a')[0m[0m
[90mline 1114 <<: [33m#   isupper 65                    # Returns true ('A')[0m[0m
[90mline 1115 <<: [33m#   [0m[0m
[90mline 1116 <<: [33m#   isalpha 65                    # Returns true ('A')[0m[0m
[90mline 1117 <<: [33m#   isalpha 48                    # Returns false ('0')[0m[0m
[90mline 1118 <<: [33m#   [0m[0m
[90mline 1119 <<: [33m#   isalnum 48                    # Returns true ('0')[0m[0m
[0mPROGRESS::64[0m
[90mline 1120 <<: [33m#   isalnum 65                    # Returns true ('A')[0m[0m
[90mline 1121 <<: [33m#   isalnum 32                    # Returns false (space)[0m[0m
[90mline 1122 <<: [33m#   [0m[0m
[90mline 1123 <<: [33m#   isspace 32                    # Returns true (space)[0m[0m
[90mline 1124 <<: [33m#   isspace 9                     # Returns true (tab)[0m[0m
[90mline 1125 <<: [33m#   isspace 65                    # Returns false ('A')[0m[0m
[90mline 1126 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1127 <<: space    = 32[0m
[32m-> space = 32[0m
[0m [0m
[90mline 1128 <<: newline  = 10[0m
[32m-> newline = 10[0m
[0m [0m
[90mline 1129 <<: tab      = 9[0m
[32m-> tab = 9[0m
[0m [0m
[90mline 1130 <<: [33m# null     = 0 # Redundant with zero[0m[0m
[90mline 1131 <<: isspace  = Î»c.or (eq c space) (or (eq c tab) (eq c newline))[0m
[32m-> isspace = Î»c.or (eq c space) (or (eq c tab) (eq c newline))[0m
[0m [0m
[90mline 1132 <<: isdigit  = Î»c.and (geq c 48) (leq c 57)[0m
[32m-> isdigit = Î»c.and (geq c 48) (leq c 57)[0m
[0m [0m
[90mline 1133 <<: islower  = Î»c.and (geq c 97) (leq c 122)[0m
[32m-> islower = Î»c.and (geq c 97) (leq c 122)[0m
[0m [0m
[90mline 1134 <<: isupper  = Î»c.and (geq c 65) (leq c 90)[0m
[32m-> isupper = Î»c.and (geq c 65) (leq c 90)[0m
[0m [0m
[90mline 1135 <<: isalpha  = Î»c.or (islower c) (isupper c)[0m
[32m-> isalpha = Î»c.or (islower c) (isupper c)[0m
[0m [0m
[90mline 1136 <<: isalnum  = Î»c.or (isalpha c) (isdigit c)[0m
[32m-> isalnum = Î»c.or (isalpha c) (isdigit c)[0m
[0m [0m
[90mline 1137 <<: [0m
[90mline 1138 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1139 <<: [33m# 7.2. Character and String Operations[0m[0m
[90mline 1140 <<: [33m#[0m[0m
[90mline 1141 <<: [33m# These functions provide character case conversion and demonstrate how[0m[0m
[90mline 1142 <<: [33m# string operations can be implemented through ASCII code manipulation.[0m[0m
[90mline 1143 <<: [33m#[0m[0m
[90mline 1144 <<: [33m# CASE CONVERSION ALGORITHM:[0m[0m
[90mline 1145 <<: [33m#   ASCII encoding places uppercase and lowercase letters exactly 32 positions[0m[0m
[90mline 1146 <<: [33m#   apart: 'A'(65) vs 'a'(97), 'B'(66) vs 'b'(98), etc.[0m[0m
[90mline 1147 <<: [33m#   Conversion involves adding/subtracting 32 based on current case.[0m[0m
[90mline 1148 <<: [33m#[0m[0m
[90mline 1149 <<: [33m# CONDITIONAL CONVERSION:[0m[0m
[90mline 1150 <<: [33m#   Only converts characters that are actually letters, leaving other[0m[0m
[90mline 1151 <<: [33m#   characters unchanged. This prevents corruption of numbers and symbols.[0m[0m
[90mline 1152 <<: [33m#[0m[0m
[90mline 1153 <<: [33m# STRING OPERATION ALIASES:[0m[0m
[90mline 1154 <<: [33m#   Some functions provide familiar names for existing list operations,[0m[0m
[90mline 1155 <<: [33m#   demonstrating how strings are just specialized lists of characters.[0m[0m
[90mline 1156 <<: [33m#[0m[0m
[90mline 1157 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1158 <<: [33m#   tolower 65                    # Returns 97 ('A' â†’ 'a')[0m[0m
[90mline 1159 <<: [33m#   tolower 97                    # Returns 97 ('a' â†’ 'a', no change)[0m[0m
[90mline 1160 <<: [33m#   tolower 48                    # Returns 48 ('0' â†’ '0', not a letter)[0m[0m
[90mline 1161 <<: [33m#   [0m[0m
[90mline 1162 <<: [33m#   toupper 97                    # Returns 65 ('a' â†’ 'A')[0m[0m
[90mline 1163 <<: [33m#   toupper 65                    # Returns 65 ('A' â†’ 'A', no change)[0m[0m
[90mline 1164 <<: [33m#   toupper 33                    # Returns 33 ('!' â†’ '!', not a letter)[0m[0m
[90mline 1165 <<: [33m#   [0m[0m
[90mline 1166 <<: [33m#   # Converting entire strings (lists of characters)[0m[0m
[90mline 1167 <<: [33m#   hello = cons 72 (cons 101 (cons 108 (cons 108 (cons 111 nil))))  # "Hello"[0m[0m
[90mline 1168 <<: [33m#   upper_hello = map toupper hello    # "HELLO"[0m[0m
[90mline 1169 <<: [33m#   lower_hello = map tolower hello    # "hello"[0m[0m
[90mline 1170 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1171 <<: tolower  = Î»c.if (isupper c) (plus c 32) c[0m
[32m-> tolower = Î»c.if (isupper c) (plus c 32) c[0m
[0m [0m
[90mline 1172 <<: toupper  = Î»c.if (islower c) (minus c 32) c[0m
[32m-> toupper = Î»c.if (islower c) (minus c 32) c[0m
[0m [0m
[90mline 1173 <<: [33m# strlen   = length # Alias for length[0m[0m
[90mline 1174 <<: [33m# strcat   = append # Alias for append[0m[0m
[90mline 1175 <<: [33m# strrev   = reverse # Alias for reverse[0m[0m
[90mline 1176 <<: words    = Î»l.filter (Î»w.not (isnil w)) (break isspace l)[0m
[32m-> words = Î»l.filter (Î»w.not (isnil w)) (break isspace l)[0m
[0m [0m
[90mline 1177 <<: lines    = Î»l.filter (Î»w.not (isnil w)) (break (eq newline) l)[0m
[32m-> lines = Î»l.filter (Î»w.not (isnil w)) (break (eq newline) l)[0m
[0m [0m
[90mline 1178 <<: unwords  = intercalate (cons space nil)[0m
[32m-> unwords = intercalate (Î»f.Î»z.f 32 (false f z))[0m
[0m [0m
[90mline 1179 <<: unlines  = intercalate (cons newline nil)[0m
[32m-> unlines = intercalate (Î»f.Î»z.f 10 (false f z))[0m
[0m [0m
[90mline 1180 <<: break    = Î»p l.foldl (Î»acc x.if (p x) acc (pair (cons x (first acc)) (second acc))) (pair nil l) l[0m
[32m-> break = Î»p.Î»l.foldl (Î»acc.Î»x.if (p x) acc (pair (cons x (first acc)) (second acc))) (pair [] l) l[0m
[0m [0m
[90mline 1181 <<: intercalate = Î»sep l.if (isnil l) nil (if (isnil (tail l)) (head l) (foldr (Î»x acc.if (isnil acc) x (append x (cons sep acc))) nil l))[0m
[32m-> intercalate = Î»sep.Î»l.if (isnil l) [] (if (isnil (tail l)) (head l) (foldr (Î»x.Î»acc.if (isnil acc) x (append x (cons sep acc))) [] l))[0m
[0m [0m
[90mline 1182 <<: [0m
[90mline 1183 <<: [0m
[90mline 1184 <<: [33m# =============================================================================[0m[0m
[90mline 1185 <<: [33m# SECTION 8: DEBUGGING, ERRORS, AND PERFORMANCE[0m[0m
[90mline 1186 <<: [33m#[0m[0m
[90mline 1187 <<: [33m# This section provides utilities for debugging, error handling, and[0m[0m
[90mline 1188 <<: [33m# performance analysis in the lambda calculus. These tools help developers[0m[0m
[90mline 1189 <<: [33m# understand program behavior and optimize computational efficiency.[0m[0m
[90mline 1190 <<: [33m#[0m[0m
[90mline 1191 <<: [33m# ERROR HANDLING PHILOSOPHY:[0m[0m
[90mline 1192 <<: [33m#   Since lambda calculus lacks exceptions, errors are represented as[0m[0m
[90mline 1193 <<: [33m#   divergent computations (infinite loops) or special values that can[0m[0m
[90mline 1194 <<: [33m#   be detected by the runtime environment.[0m[0m
[90mline 1195 <<: [33m#[0m[0m
[90mline 1196 <<: [33m# DEBUGGING STRATEGY:[0m[0m
[90mline 1197 <<: [33m#   Functional debugging relies on tracing values through computations[0m[0m
[90mline 1198 <<: [33m#   rather than traditional step-through debugging. The trace function[0m[0m
[90mline 1199 <<: [33m#   provides a hook for observing intermediate values.[0m[0m
[90mline 1200 <<: [33m#[0m[0m
[90mline 1201 <<: [33m# PERFORMANCE CONSIDERATIONS:[0m[0m
[90mline 1202 <<: [33m#   Pure functional programming enables certain optimizations like[0m[0m
[90mline 1203 <<: [33m#   memoization and lazy evaluation, though their effectiveness depends[0m[0m
[90mline 1204 <<: [33m#   on the implementation environment.[0m[0m
[90mline 1205 <<: [33m# =============================================================================[0m[0m
[90mline 1206 <<: [0m
[90mline 1207 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[0mPROGRESS::69[0m
[90mline 1208 <<: [33m# 8.1. Debugging and Error Handling[0m[0m
[90mline 1209 <<: [33m#[0m[0m
[90mline 1210 <<: [33m# These functions provide mechanisms for program debugging and error[0m[0m
[90mline 1211 <<: [33m# representation in the pure functional paradigm.[0m[0m
[90mline 1212 <<: [33m#[0m[0m
[90mline 1213 <<: [33m# TRACE FUNCTION:[0m[0m
[90mline 1214 <<: [33m#   The trace function is designed to log or display debugging information[0m[0m
[90mline 1215 <<: [33m#   while returning its argument unchanged. In this implementation, it's[0m[0m
[90mline 1216 <<: [33m#   a no-op, but in a full system it would output the message.[0m[0m
[90mline 1217 <<: [33m#[0m[0m
[90mline 1218 <<: [33m# ERROR REPRESENTATION:[0m[0m
[90mline 1219 <<: [33m#   Errors are represented as divergent computations using fixed-point[0m[0m
[90mline 1220 <<: [33m#   combinators. When an error occurs, the computation enters an infinite[0m[0m
[90mline 1221 <<: [33m#   loop rather than returning a value.[0m[0m
[90mline 1222 <<: [33m#[0m[0m
[90mline 1223 <<: [33m# ERROR TYPES:[0m[0m
[90mline 1224 <<: [33m#   Different error conditions are represented by specific error constants:[0m[0m
[90mline 1225 <<: [33m#   - divByZero: Division by zero errors[0m[0m
[90mline 1226 <<: [33m#   - indexError: Array/list index out of bounds[0m[0m
[90mline 1227 <<: [33m#   - typeError: Type mismatch errors[0m[0m
[90mline 1228 <<: [33m#[0m[0m
[90mline 1229 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1230 <<: [33m#   # Debugging (conceptual - actual implementation may vary)[0m[0m
[90mline 1231 <<: [33m#   trace "computing factorial" (factorial 5)[0m[0m
[90mline 1232 <<: [33m#   [0m[0m
[90mline 1233 <<: [33m#   # Error conditions[0m[0m
[90mline 1234 <<: [33m#   divide = Î»a b.if (iszero b) divByZero (div a b)[0m[0m
[90mline 1235 <<: [33m#   divide 10 2       # Returns 5[0m[0m
[90mline 1236 <<: [33m#   divide 10 0       # Triggers divByZero (infinite loop)[0m[0m
[90mline 1237 <<: [33m#   [0m[0m
[90mline 1238 <<: [33m#   # Safe indexing[0m[0m
[90mline 1239 <<: [33m#   safeIndex = Î»n l.if (geq n (length l)) indexError (nth n l)[0m[0m
[90mline 1240 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1241 <<: trace     = Î»msg x.x[0m
[32m-> trace = false[0m
[0m [0m
[90mline 1242 <<: [33m# debug     = trace # Alias for trace[0m[0m
[90mline 1243 <<: undefined = Y I[0m
[32m-> undefined = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1244 <<: error     = undefined[0m
[32m-> error = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1245 <<: [33m# Error types for safe operations[0m[0m
[90mline 1246 <<: divByZero  = undefined[0m
[32m-> divByZero = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1247 <<: indexError = undefined[0m
[32m-> indexError = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1248 <<: typeError  = undefined[0m
[32m-> typeError = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1249 <<: [0m
[90mline 1250 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1251 <<: [33m# 8.2. Performance and Optimization[0m[0m
[90mline 1252 <<: [33m#[0m[0m
[90mline 1253 <<: [33m# These functions provide tools for measuring and optimizing performance[0m[0m
[90mline 1254 <<: [33m# in functional programs.[0m[0m
[90mline 1255 <<: [33m#[0m[0m
[90mline 1256 <<: [33m# BENCHMARKING:[0m[0m
[90mline 1257 <<: [33m#   The benchmark function repeatedly applies a function to measure[0m[0m
[90mline 1258 <<: [33m#   performance characteristics. This helps identify computational[0m[0m
[90mline 1259 <<: [33m#   bottlenecks and compare algorithm efficiency.[0m[0m
[90mline 1260 <<: [33m#[0m[0m
[90mline 1261 <<: [33m# MEMOIZATION:[0m[0m
[90mline 1262 <<: [33m#   In pure functional programming, memoization can cache function results[0m[0m
[90mline 1263 <<: [33m#   to avoid recomputation. This implementation is a placeholder since[0m[0m
[90mline 1264 <<: [33m#   true memoization requires mutable state.[0m[0m
[90mline 1265 <<: [33m#[0m[0m
[90mline 1266 <<: [33m# LAZY EVALUATION:[0m[0m
[90mline 1267 <<: [33m#   Delay and force implement a basic form of lazy evaluation where[0m[0m
[90mline 1268 <<: [33m#   computations are deferred until their results are needed.[0m[0m
[90mline 1269 <<: [33m#   This can improve performance by avoiding unnecessary calculations.[0m[0m
[90mline 1270 <<: [33m#[0m[0m
[90mline 1271 <<: [33m# OPTIMIZATION STRATEGIES:[0m[0m
[90mline 1272 <<: [33m#   - Use tail recursion when possible to avoid stack overflow[0m[0m
[90mline 1273 <<: [33m#   - Consider memoization for expensive recursive functions[0m[0m
[90mline 1274 <<: [33m#   - Employ lazy evaluation for potentially infinite data structures[0m[0m
[90mline 1275 <<: [33m#   - Benchmark different algorithms to choose the most efficient[0m[0m
[90mline 1276 <<: [33m#[0m[0m
[90mline 1277 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1278 <<: [33m#   # Benchmarking factorial computation[0m[0m
[90mline 1279 <<: [33m#   benchmark 1000 factorial 10    # Runs factorial(10) 1000 times[0m[0m
[90mline 1280 <<: [33m#   [0m[0m
[90mline 1281 <<: [33m#   # Lazy evaluation of expensive computation[0m[0m
[90mline 1282 <<: [33m#   expensiveCalc = delay (factorial 100)[0m[0m
[90mline 1283 <<: [33m#   result = force expensiveCalc    # Only computed when forced[0m[0m
[90mline 1284 <<: [33m#   [0m[0m
[90mline 1285 <<: [33m#   # Memoized function (conceptual)[0m[0m
[90mline 1286 <<: [33m#   fastFib = memoize fibonacci     # Caches previous results[0m[0m
[90mline 1287 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1288 <<: benchmark = Î»n f x.times n (Î»_.f x) x[0m
[32m-> benchmark = Î»n.Î»f.Î»x.times n (Î»_placeholder1.f x) x[0m
[0m [0m
[90mline 1289 <<: [33m# timeIt    = benchmark # Alias for benchmark[0m[0m
[90mline 1290 <<: [33m# Memoization is a no-op without mutation, included for concept[0m[0m
[90mline 1291 <<: memoize   = Î»f.f[0m
[32m-> memoize = Î»f.f[0m
[0m [0m
[90mline 1292 <<: [33m# Lazy evaluation helpers[0m[0m
[90mline 1293 <<: delay     = Î»x.Î»f.f x[0m
[32m-> delay = Î»x.Î»f.f x[0m
[0m [0m
[90mline 1294 <<: force     = Î»thunk.thunk I[0m
[32m-> force = Î»thunk.thunk I[0m
[0m [0m
[0mPROGRESS::74[0m
[90mline 1295 <<: [0m
[90mline 1296 <<: [0m
[90mline 1297 <<: [33m# =============================================================================[0m[0m
[90mline 1298 <<: [33m# 8.3. STRUCTURAL EQUALITY HELPERS[0m[0m
[90mline 1299 <<: [33m#[0m[0m
[90mline 1300 <<: [33m# Primitive eq only handles numerals (using order). For composite structures[0m[0m
[90mline 1301 <<: [33m# we supply parametric structural equality combinators. They take an element[0m[0m
[90mline 1302 <<: [33m# equality (or two, for Either) so callers choose how to compare leaves.[0m[0m
[90mline 1303 <<: [33m# We intentionally do NOT redefine eq globally to avoid ambiguity between[0m[0m
[90mline 1304 <<: [33m# 0 / nil / nothing, which all share the same Church encoding here.[0m[0m
[90mline 1305 <<: [33m#[0m[0m
[90mline 1306 <<: [33m# listEq   eqE l1 l2    : deep equality on lists[0m[0m
[90mline 1307 <<: [33m# pairEq   eqA eqB p q  : product equality[0m[0m
[90mline 1308 <<: [33m# maybeEq  eqA m1 m2    : optional equality[0m[0m
[90mline 1309 <<: [33m# eitherEq eqL eqR e1 e2: sum equality[0m[0m
[90mline 1310 <<: [33m#[0m[0m
[90mline 1311 <<: [33m# Example convenience macros (added later) will allow: test-list, test-pairâ€¦[0m[0m
[90mline 1312 <<: [33m#[0m[0m
[90mline 1313 <<: [33m# NOTE: For nested structures use partial application: (listEq (listEq eq) a b)[0m[0m
[90mline 1314 <<: [33m# =============================================================================[0m[0m
[90mline 1315 <<: [33m# Equality Guide[0m[0m
[90mline 1316 <<: [33m# eq            : primitive / numeric equality on Church numerals, booleans, chars[0m[0m
[90mline 1317 <<: [33m# isStructEqual : full structural + alpha equivalence (normalizes expressions)[0m[0m
[90mline 1318 <<: [33m# listEq/...Eq  : deep equality for specific encodings using a provided element eq[0m[0m
[90mline 1319 <<: [33m#[0m[0m
[90mline 1320 <<: [33m# Use hierarchy:[0m[0m
[90mline 1321 <<: [33m#  1. For user data structures (lists/pairs/maybe/either): use listEq etc. with element eq.[0m[0m
[90mline 1322 <<: [33m#  2. For general lambda expressions where structure matters: isStructEqual.[0m[0m
[90mline 1323 <<: [33m#  3. For numerals/booleans/chars inside algorithms: eq.[0m[0m
[90mline 1324 <<: [33m# listEq et al do NOT normalize arbitrary expressions[0m[0m[32m;[0m[90m element eq should align with eq semantics.[0m
[90mline 1325 <<: listEq   = Y (Î»self.Î»eqE.Î»l1.Î»l2. \[0m
[90mline 1326 <<:                                 if (and (isnil l1) (isnil l2)) true ( \[0m
[90mline 1327 <<:                                     if (or (isnil l1) (isnil l2)) false ( \[0m
[90mline 1328 <<:                                         and (eqE (head l1) (head l2)) (self eqE (tail l1) (tail l2)))))[0m
[32m-> listEq = <thunk:(Î»self.Î»eqE.Î»l1.Î»l2.if (and (isnil l1) (isnil l2)) true (if (or (isnil l1) (isnil l2)) false (and (eqE (head l1) (head l2)) (self eqE (tail l1) (tail l2))))) (Y (Î»self.Î»eqE.Î»l1.Î»l2.if (and (isnil l1) (isnil l2)) true (if (or (isnil l1) (isnil l2)) false (and (eqE (head l1) (head l2)) (self eqE (tail l1) (tail l2))))))>[0m
[0m [0m
[90mline 1329 <<: pairEq   = Î»eqA.Î»eqB.Î»p1.Î»p2.and (eqA (first p1) (first p2)) (eqB (second p1) (second p2))[0m
[32m-> pairEq = Î»eqA.Î»eqB.Î»p1.Î»p2.and (eqA (first p1) (first p2)) (eqB (second p1) (second p2))[0m
[0m [0m
[90mline 1330 <<: maybeEq  = Î»eqA.Î»m1.Î»m2.if (and (isNothing m1) (isNothing m2)) true ( \[0m
[90mline 1331 <<:                                             if (or (isNothing m1) (isNothing m2)) false ( \[0m
[90mline 1332 <<:                                                 eqA (fromJust m1) (fromJust m2)))[0m
[32m-> maybeEq = Î»eqA.Î»m1.Î»m2.if (and (isNothing m1) (isNothing m2)) true (if (or (isNothing m1) (isNothing m2)) false (eqA (fromJust m1) (fromJust m2)))[0m
[0m [0m
[90mline 1333 <<: eitherEq = Î»eqL.Î»eqR.Î»e1.Î»e2.if (and (isLeft e1) (isLeft e2)) (eqL (fromLeft e1) (fromLeft e2)) ( \[0m
[90mline 1334 <<:                                                     if (and (isRight e1) (isRight e2)) (eqR (fromRight e1) (fromRight e2)) false)[0m
[32m-> eitherEq = Î»eqL.Î»eqR.Î»e1.Î»e2.if (and (isLeft e1) (isLeft e2)) (eqL (fromLeft e1) (fromLeft e2)) (if (and (isRight e1) (isRight e2)) (eqR (fromRight e1) (fromRight e2)) false)[0m
[0m [0m
[90mline 1335 <<: [0m
[90mline 1336 <<: [0m
[90mline 1337 <<: [33m# =============================================================================[0m[0m
[90mline 1338 <<: [33m# SECTION 9: MACRO SYSTEM[0m[0m
[90mline 1339 <<: [33m#[0m[0m
[90mline 1340 <<: [33m# This section defines a set of macros to provide syntactic sugar and simplify[0m[0m
[90mline 1341 <<: [33m# common programming patterns in the lambda calculus. Macros enable more[0m[0m
[90mline 1342 <<: [33m# readable and maintainable code by abstracting complex lambda expressions.[0m[0m
[90mline 1343 <<: [33m#[0m[0m
[90mline 1344 <<: [33m# MACRO PHILOSOPHY:[0m[0m
[90mline 1345 <<: [33m#   Macros transform source code at parse time, expanding into underlying[0m[0m
[90mline 1346 <<: [33m#   lambda expressions. They provide familiar syntax while maintaining[0m[0m
[90mline 1347 <<: [33m#   the pure functional foundation.[0m[0m
[90mline 1348 <<: [33m#[0m[0m
[90mline 1349 <<: [33m# MACRO SYNTAX:[0m[0m
[90mline 1350 <<: [33m#   :macro (pattern) => (expansion)[0m[0m
[90mline 1351 <<: [33m#   Variables in patterns are prefixed with $ and substituted in expansion.[0m[0m
[90mline 1352 <<: [33m#[0m[0m
[90mline 1353 <<: [33m# CATEGORIES OF MACROS:[0m[0m
[90mline 1354 <<: [33m#   1. Control flow: letbind, when, unless, for, iff[0m[0m
[90mline 1355 <<: [33m#   2. Mathematical: square, cube, inc, dec, min2, max2[0m[0m
[90mline 1356 <<: [33m#   3. Logical: nand, nor with list utilities[0m[0m
[90mline 1357 <<: [33m#   4. Function composition: compose, apply_twice, apply_n[0m[0m
[90mline 1358 <<: [33m#   5. Development aids: assert, test for validation[0m[0m
[90mline 1359 <<: [33m#[0m[0m
[90mline 1360 <<: [33m# BENEFITS:[0m[0m
[90mline 1361 <<: [33m#   - More readable code with familiar syntax[0m[0m
[90mline 1362 <<: [33m#   - Reduced boilerplate for common patterns[0m[0m
[90mline 1363 <<: [33m#   - Type-safe transformations at compile time[0m[0m
[90mline 1364 <<: [33m#   - Easier maintenance and refactoring[0m[0m
[90mline 1365 <<: [33m# =============================================================================[0m[0m
[90mline 1366 <<: [0m
[90mline 1367 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1368 <<: [33m# 9.1. Core and Conditional Macros[0m[0m
[90mline 1369 <<: [33m#[0m[0m
[90mline 1370 <<: [33m# These macros provide essential control flow and binding constructs that[0m[0m
[90mline 1371 <<: [33m# make lambda calculus programming more intuitive and readable.[0m[0m
[90mline 1372 <<: [33m#[0m[0m
[90mline 1373 <<: [33m# LETBIND MACRO:[0m[0m
[90mline 1374 <<: [33m#   Creates local variable bindings using lambda abstraction and application.[0m[0m
[90mline 1375 <<: [33m#   letbind x 5 (+ x 2) expands to ((Î»x.(+ x 2)) 5)[0m[0m
[90mline 1376 <<: [33m#[0m[0m
[90mline 1377 <<: [33m# CONDITIONAL MACROS:[0m[0m
[90mline 1378 <<: [33m#   - when: Executes expression only if condition is true[0m[0m
[90mline 1379 <<: [33m#   - unless: Executes expression only if condition is false[0m[0m
[90mline 1380 <<: [33m#   - iff: Alternative syntax for if-then-else with clearer semantics[0m[0m
[90mline 1381 <<: [33m#[0m[0m
[90mline 1382 <<: [33m# ITERATION MACRO:[0m[0m
[0mPROGRESS::79[0m
[90mline 1383 <<: [33m#   for loops transform into map operations, embracing functional iteration[0m[0m
[90mline 1384 <<: [33m#   over imperative looping constructs.[0m[0m
[90mline 1385 <<: [33m#[0m[0m
[90mline 1386 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1387 <<: [33m#   letbind x 10 (mult x x)               # Local binding: x = 10, returns 100[0m[0m
[90mline 1388 <<: [33m#   when (gt x 0) (display "positive")    # Conditional execution[0m[0m
[90mline 1389 <<: [33m#   unless (iszero x) (div 100 x)         # Negative conditional[0m[0m
[90mline 1390 <<: [33m#   for i at mylist do (mult i 2)         # Functional iteration[0m[0m
[90mline 1391 <<: [33m#   iff (even x) then "even" else "odd"   # Clear conditional syntax[0m[0m
[90mline 1392 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1393 <<: [38;5;205m:macro (letbind $var $val $expr) => ((Î»$var.$expr) $val)[0m[0m
[34mMacro 'letbind' defined successfully[0m
[0m [0m
[90mline 1394 <<: [38;5;205m:macro (when $cond $expr) => (if $cond $expr I)[0m[0m
[34mMacro 'when' defined successfully[0m
[0m [0m
[90mline 1395 <<: [38;5;205m:macro (unless $cond $expr) => (if $cond I $expr)[0m[0m
[34mMacro 'unless' defined successfully[0m
[0m [0m
[90mline 1396 <<: [38;5;205m:macro (for $var at $list do $body) => (map (Î»$var.$body) $list)[0m[0m
[34mMacro 'for' defined successfully[0m
[0m [0m
[90mline 1397 <<: [38;5;205m:macro (iff $p then $then else $else) => if $p $then $else[0m[0m
[34mMacro 'iff' defined successfully[0m
[0m [0m
[90mline 1398 <<: [0m
[90mline 1399 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1400 <<: [33m# 9.2. Math and Comparison Macros[0m[0m
[90mline 1401 <<: [33m#[0m[0m
[90mline 1402 <<: [33m# These macros provide convenient mathematical operations and comparisons[0m[0m
[90mline 1403 <<: [33m# that would otherwise require more verbose lambda expressions.[0m[0m
[90mline 1404 <<: [33m#[0m[0m
[90mline 1405 <<: [33m# MATHEMATICAL OPERATIONS:[0m[0m
[90mline 1406 <<: [33m#   - square, cube: Common polynomial operations[0m[0m
[90mline 1407 <<: [33m#   - inc, dec: Increment and decrement (aliases for succ/pred)[0m[0m
[90mline 1408 <<: [33m#   - min2, max2: Binary minimum and maximum functions[0m[0m
[90mline 1409 <<: [33m#[0m[0m
[90mline 1410 <<: [33m# RANGE OPERATIONS:[0m[0m
[90mline 1411 <<: [33m#   between macro tests if a value falls within a specified range,[0m[0m
[90mline 1412 <<: [33m#   combining multiple comparisons into a single readable expression.[0m[0m
[90mline 1413 <<: [33m#[0m[0m
[90mline 1414 <<: [33m# EFFICIENCY CONSIDERATIONS:[0m[0m
[90mline 1415 <<: [33m#   These macros expand to efficient lambda expressions that avoid[0m[0m
[90mline 1416 <<: [33m#   redundant computation while maintaining mathematical correctness.[0m[0m
[90mline 1417 <<: [33m#[0m[0m
[90mline 1418 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1419 <<: [33m#   square 5                           # Returns 25[0m[0m
[90mline 1420 <<: [33m#   cube 3                             # Returns 27[0m[0m
[90mline 1421 <<: [33m#   inc 10                             # Returns 11[0m[0m
[90mline 1422 <<: [33m#   dec 10                             # Returns 9[0m[0m
[90mline 1423 <<: [33m#   between 5 1 10                     # Returns true (1 â‰¤ 5 â‰¤ 10)[0m[0m
[90mline 1424 <<: [33m#   between 15 1 10                    # Returns false (15 > 10)[0m[0m
[90mline 1425 <<: [33m#   min2 7 3                           # Returns 3[0m[0m
[90mline 1426 <<: [33m#   max2 7 3                           # Returns 7[0m[0m
[90mline 1427 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1428 <<: [38;5;205m:macro (square $x) => (mult $x $x)[0m[0m
[34mMacro 'square' defined successfully[0m
[0m [0m
[90mline 1429 <<: [38;5;205m:macro (cube $x) => (mult $x (mult $x $x))[0m[0m
[34mMacro 'cube' defined successfully[0m
[0m [0m
[90mline 1430 <<: [38;5;205m:macro (inc $x) => (succ $x)[0m[0m
[34mMacro 'inc' defined successfully[0m
[0m [0m
[90mline 1431 <<: [38;5;205m:macro (dec $x) => (pred $x)[0m[0m
[34mMacro 'dec' defined successfully[0m
[0m [0m
[90mline 1432 <<: [38;5;205m:macro (between $x $low $high) => (and (geq $x $low) (leq $x $high))[0m[0m
[34mMacro 'between' defined successfully[0m
[0m [0m
[90mline 1433 <<: [38;5;205m:macro (min2 $a $b) => (if (leq $a $b) $a $b)[0m[0m
[34mMacro 'min2' defined successfully[0m
[0m [0m
[90mline 1434 <<: [38;5;205m:macro (max2 $a $b) => (if (geq $a $b) $a $b)[0m[0m
[34mMacro 'max2' defined successfully[0m
[0m [0m
[90mline 1435 <<: [0m
[90mline 1436 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1437 <<: [33m# 9.3. Boolean and List Macros[0m[0m
[90mline 1438 <<: [33m#[0m[0m
[90mline 1439 <<: [33m# These macros extend boolean logic and provide convenient list operations[0m[0m
[90mline 1440 <<: [33m# with more intuitive naming conventions.[0m[0m
[90mline 1441 <<: [33m#[0m[0m
[90mline 1442 <<: [33m# EXTENDED BOOLEAN LOGIC:[0m[0m
[90mline 1443 <<: [33m#   nand and nor provide the remaining basic boolean operations,[0m[0m
[90mline 1444 <<: [33m#   completing the set of fundamental logical operators.[0m[0m
[90mline 1445 <<: [33m#   These are derived from existing and/or operations with negation.[0m[0m
[90mline 1446 <<: [33m#[0m[0m
[90mline 1447 <<: [33m# LIST CONVENIENCE MACROS:[0m[0m
[90mline 1448 <<: [33m#   - empty?: More intuitive name for testing empty lists[0m[0m
[90mline 1449 <<: [33m#   - first/rest: Alternative names following Lisp conventions[0m[0m
[90mline 1450 <<: [33m#   - These provide familiar vocabulary for list processing[0m[0m
[90mline 1451 <<: [33m#[0m[0m
[90mline 1452 <<: [33m# NAMING CONVENTIONS:[0m[0m
[90mline 1453 <<: [33m#   The macros follow common functional programming conventions:[0m[0m
[90mline 1454 <<: [33m#   - Predicate functions end with '?'[0m[0m
[90mline 1455 <<: [33m#   - first/rest mirror head/tail semantics[0m[0m
[90mline 1456 <<: [33m#   - Boolean operations use standard logical names[0m[0m
[90mline 1457 <<: [33m#[0m[0m
[90mline 1458 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1459 <<: [33m#   nand true false                    # Returns true (not (and true false))[0m[0m
[90mline 1460 <<: [33m#   nor false false                    # Returns false (not (or false false))[0m[0m
[90mline 1461 <<: [33m#   empty? nil                         # Returns true[0m[0m
[90mline 1462 <<: [33m#   empty? (cons 1 nil)                # Returns false[0m[0m
[90mline 1463 <<: [33m#   first (cons 1 (cons 2 nil))        # Returns 1[0m[0m
[90mline 1464 <<: [33m#   rest (cons 1 (cons 2 nil))         # Returns (cons 2 nil)[0m[0m
[90mline 1465 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1466 <<: [38;5;205m:macro (nand $a $b) => (not (and $a $b))[0m[0m
[34mMacro 'nand' defined successfully[0m
[0m [0m
[90mline 1467 <<: [38;5;205m:macro (nor $a $b) => (not (or $a $b))[0m[0m
[34mMacro 'nor' defined successfully[0m
[0m [0m
[90mline 1468 <<: [38;5;205m:macro (empty? $list) => (isnil $list) [0m[0m
[34mMacro 'empty?' defined successfully[0m
[0m [0m
[90mline 1469 <<: [38;5;205m:macro (rest $list) => (tail $list)[0m[0m
[34mMacro 'rest' defined successfully[0m
[0m [0m
[0mPROGRESS::84[0m
[90mline 1470 <<: [0m
[90mline 1471 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1472 <<: [33m# 9.4. Function Application Macros[0m[0m
[90mline 1473 <<: [33m#[0m[0m
[90mline 1474 <<: [33m# These macros provide convenient ways to compose and apply functions,[0m[0m
[90mline 1475 <<: [33m# fundamental operations in functional programming.[0m[0m
[90mline 1476 <<: [33m#[0m[0m
[90mline 1477 <<: [33m# FUNCTION COMPOSITION:[0m[0m
[90mline 1478 <<: [33m#   The compose macro creates function pipelines where the output of one[0m[0m
[90mline 1479 <<: [33m#   function becomes the input of another. This enables building complex[0m[0m
[90mline 1480 <<: [33m#   operations from simple components.[0m[0m
[90mline 1481 <<: [33m#[0m[0m
[90mline 1482 <<: [33m# REPEATED APPLICATION:[0m[0m
[90mline 1483 <<: [33m#   - apply_twice: Applies a function twice to its argument[0m[0m
[90mline 1484 <<: [33m#   - apply_n: Applies a function n times, enabling iteration patterns[0m[0m
[90mline 1485 <<: [33m#[0m[0m
[90mline 1486 <<: [33m# FUNCTIONAL PROGRAMMING PATTERNS:[0m[0m
[90mline 1487 <<: [33m#   These macros embody core functional programming principles:[0m[0m
[90mline 1488 <<: [33m#   - Composition over inheritance[0m[0m
[90mline 1489 <<: [33m#   - Building complexity through function combination[0m[0m
[90mline 1490 <<: [33m#   - Avoiding explicit iteration through repeated application[0m[0m
[90mline 1491 <<: [33m#[0m[0m
[90mline 1492 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1493 <<: [33m#   compose succ succ 5                # Returns 7 (increment twice)[0m[0m
[90mline 1494 <<: [33m#   apply_twice succ 5                 # Returns 7 (same as above)[0m[0m
[90mline 1495 <<: [33m#   apply_n succ 3 5                   # Returns 8 (increment three times)[0m[0m
[90mline 1496 <<: [33m#   [0m[0m
[90mline 1497 <<: [33m#   # More complex compositions[0m[0m
[90mline 1498 <<: [33m#   compose (mult 2) succ 5            # Returns 12 (succ(5) * 2)[0m[0m
[90mline 1499 <<: [33m#   apply_n (mult 2) 3 1               # Returns 8 (multiply by 2 three times)[0m[0m
[90mline 1500 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1501 <<: [38;5;205m:macro (compose $f $g $x) => ($f ($g $x))[0m[0m
[34mMacro 'compose' defined successfully[0m
[0m [0m
[90mline 1502 <<: [38;5;205m:macro (apply_twice $f $x) => ($f ($f $x))[0m[0m
[34mMacro 'apply_twice' defined successfully[0m
[0m [0m
[90mline 1503 <<: [38;5;205m:macro (apply_n $f $n $x) => (times $n $f $x)[0m[0m
[34mMacro 'apply_n' defined successfully[0m
[0m [0m
[90mline 1504 <<: [0m
[90mline 1505 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1506 <<: [33m# 9.5. Debugging and Assertion Macros[0m[0m
[90mline 1507 <<: [33m#[0m[0m
[90mline 1508 <<: [33m# These macros provide essential development and testing utilities for[0m[0m
[90mline 1509 <<: [33m# ensuring program correctness and facilitating debugging.[0m[0m
[90mline 1510 <<: [33m#[0m[0m
[90mline 1511 <<: [33m# ASSERTION MACRO:[0m[0m
[90mline 1512 <<: [33m#   The assert macro implements precondition checking by returning the value[0m[0m
[90mline 1513 <<: [33m#   if the condition is true, or triggering an error if false. This provides[0m[0m
[90mline 1514 <<: [33m#   runtime validation of program invariants.[0m[0m
[90mline 1515 <<: [33m#[0m[0m
[90mline 1516 <<: [33m# TESTING MACRO:[0m[0m
[90mline 1517 <<: [33m#   The test macro compares an expression result with an expected value,[0m[0m
[90mline 1518 <<: [33m#   forming the basis for unit testing in functional programs.[0m[0m
[90mline 1519 <<: [33m#[0m[0m
[90mline 1520 <<: [33m# DEVELOPMENT WORKFLOW:[0m[0m
[90mline 1521 <<: [33m#   These macros support test-driven development and defensive programming:[0m[0m
[90mline 1522 <<: [33m#   - Assertions catch invalid states early[0m[0m
[90mline 1523 <<: [33m#   - Tests verify function behavior[0m[0m
[90mline 1524 <<: [33m#   - Both provide documentation of expected behavior[0m[0m
[90mline 1525 <<: [33m#[0m[0m
[90mline 1526 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1527 <<: [33m#   assert (gt x 0) x                  # Ensures x is positive before using[0m[0m
[90mline 1528 <<: [33m#   assert (not (isnil l)) (head l)    # Ensures list not empty before head[0m[0m
[90mline 1529 <<: [33m#   [0m[0m
[90mline 1530 <<: [33m#   test (plus 2 3) 5                  # Returns true (2 + 3 = 5)[0m[0m
[90mline 1531 <<: [33m#   test (mult 4 5) 19                 # Returns false (4 * 5 â‰  19)[0m[0m
[90mline 1532 <<: [33m#   [0m[0m
[90mline 1533 <<: [33m#   # Function testing[0m[0m
[90mline 1534 <<: [33m#   test (factorial 5) 120             # Verify factorial correctness[0m[0m
[90mline 1535 <<: [33m#   test (fibonacci 7) 13              # Verify fibonacci correctness[0m[0m
[90mline 1536 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1537 <<: [38;5;205m:macro (assert $condition $value) => (if $condition $value error)[0m[0m
[34mMacro 'assert' defined successfully[0m
[0m [0m
[90mline 1538 <<: [38;5;205m:macro (test $expr $expected) => (eq $expr $expected)[0m[0m
[34mMacro 'test' defined successfully[0m
[0m [0m
[90mline 1539 <<: [0m
[90mline 1540 <<: [33m# Structural test macros (list, pair, maybe, either)[0m[0m
[90mline 1541 <<: [33m# These dispatch to the structural equality helpers with numeric element eq.[0m[0m
[90mline 1542 <<: [33m# For custom element equality supply your own macro or call helpers directly.[0m[0m
[90mline 1543 <<: [33m## NOTE: Hyphens in macro names can clash with minus parsing[0m[0m[32m;[0m[90m prefer camelCase.[0m
[90mline 1544 <<: [38;5;205m:macro (testList $a $b) => (listEq eq $a $b)[0m[0m
[34mMacro 'testList' defined successfully[0m
[0m [0m
[90mline 1545 <<: [38;5;205m:macro (testPair $a $b) => (pairEq eq eq $a $b)[0m[0m
[34mMacro 'testPair' defined successfully[0m
[0m [0m
[90mline 1546 <<: [38;5;205m:macro (testMaybe $a $b) => (maybeEq eq $a $b)[0m[0m
[34mMacro 'testMaybe' defined successfully[0m
[0m [0m
[90mline 1547 <<: [38;5;205m:macro (testEither $a $b) => (eitherEq eq eq $a $b)[0m[0m
[34mMacro 'testEither' defined successfully[0m
[0m [0m
[90mline 1548 <<: [0m
[90mline 1549 <<: [33m# Variants allowing custom element equality (supply eq function first)[0m[0m
[90mline 1550 <<: [38;5;205m:macro (testListBy $eqE $a $b) => (listEq $eqE $a $b)[0m[0m
[34mMacro 'testListBy' defined successfully[0m
[0m [0m
[90mline 1551 <<: [38;5;205m:macro (testPairBy $eqA $eqB $a $b) => (pairEq $eqA $eqB $a $b)[0m[0m
[34mMacro 'testPairBy' defined successfully[0m
[0m [0m
[90mline 1552 <<: [38;5;205m:macro (testMaybeBy $eqA $a $b) => (maybeEq $eqA $a $b)[0m[0m
[34mMacro 'testMaybeBy' defined successfully[0m
[0m [0m
[90mline 1553 <<: [38;5;205m:macro (testEitherBy $eqL $eqR $a $b) => (eitherEq $eqL $eqR $a $b)[0m[0m
[34mMacro 'testEitherBy' defined successfully[0m
[0m [0m
[90mline 1554 <<: [0m
[90mline 1555 <<: [0m
[90mline 1556 <<: [33m# =============================================================================[0m[0m
[90mline 1557 <<: [33m# SECTION 10: INFIX OPERATORS[0m[0m
[0mPROGRESS::89[0m
[90mline 1558 <<: [33m#[0m[0m
[90mline 1559 <<: [33m# This section defines infix operators for common arithmetic and logical[0m[0m
[90mline 1560 <<: [33m# operations to allow for more conventional mathematical notation.[0m[0m
[90mline 1561 <<: [33m# These operators transform lambda calculus into a more familiar syntax[0m[0m
[90mline 1562 <<: [33m# while maintaining the underlying functional semantics.[0m[0m
[90mline 1563 <<: [33m#[0m[0m
[90mline 1564 <<: [33m# INFIX NOTATION BENEFITS:[0m[0m
[90mline 1565 <<: [33m#   - Familiar mathematical syntax: 2 + 3 instead of (plus 2 3)[0m[0m
[90mline 1566 <<: [33m#   - Operator precedence: 2 + 3 * 4 correctly parsed as 2 + (3 * 4)[0m[0m
[90mline 1567 <<: [33m#   - Associativity rules: 2 - 3 - 4 correctly parsed as (2 - 3) - 4[0m[0m
[90mline 1568 <<: [33m#   - Improved readability for mathematical expressions[0m[0m
[90mline 1569 <<: [33m#[0m[0m
[90mline 1570 <<: [33m# PRECEDENCE LEVELS:[0m[0m
[90mline 1571 <<: [33m#   Higher numbers bind tighter (evaluated first):[0m[0m
[90mline 1572 <<: [33m#   8: ^ (exponentiation)[0m[0m
[90mline 1573 <<: [33m#   7: *, /, % (multiplication, division, modulo)[0m[0m
[90mline 1574 <<: [33m#   6: +, - (addition, subtraction)[0m[0m
[90mline 1575 <<: [33m#   5: <, <=, >, >= (comparisons)[0m[0m
[90mline 1576 <<: [33m#   4: ==, != (equality tests)[0m[0m
[90mline 1577 <<: [33m#   3: && (logical and)[0m[0m
[90mline 1578 <<: [33m#   2: || (logical or)[0m[0m
[90mline 1579 <<: [33m#[0m[0m
[90mline 1580 <<: [33m# ASSOCIATIVITY:[0m[0m
[90mline 1581 <<: [33m#   - left: Operations associate left-to-right[0m[0m
[90mline 1582 <<: [33m#   - right: Operations associate right-to-left (only ^ in this set)[0m[0m
[90mline 1583 <<: [33m# =============================================================================[0m[0m
[90mline 1584 <<: [0m
[90mline 1585 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1586 <<: [33m# 10.1. Arithmetic Infix Operators[0m[0m
[90mline 1587 <<: [33m#[0m[0m
[90mline 1588 <<: [33m# These operators provide standard mathematical notation for arithmetic[0m[0m
[90mline 1589 <<: [33m# operations, making mathematical expressions more intuitive and readable.[0m[0m
[90mline 1590 <<: [33m#[0m[0m
[90mline 1591 <<: [33m# OPERATOR DEFINITIONS:[0m[0m
[90mline 1592 <<: [33m#   Each operator is defined as an alias to the corresponding function:[0m[0m
[90mline 1593 <<: [33m#   + maps to plus, - to minus, * to mult, / to div, etc.[0m[0m
[90mline 1594 <<: [33m#[0m[0m
[90mline 1595 <<: [33m# PRECEDENCE AND ASSOCIATIVITY:[0m[0m
[90mline 1596 <<: [33m#   - Exponentiation (^): Highest precedence (8), right-associative[0m[0m
[90mline 1597 <<: [33m#   - Multiplication/Division/Modulo (*, /, %): Precedence 7, left-associative[0m[0m
[90mline 1598 <<: [33m#   - Addition/Subtraction (+, -): Precedence 6, left-associative[0m[0m
[90mline 1599 <<: [33m#[0m[0m
[90mline 1600 <<: [33m# MATHEMATICAL CORRECTNESS:[0m[0m
[90mline 1601 <<: [33m#   The precedence rules follow standard mathematical conventions:[0m[0m
[90mline 1602 <<: [33m#   2 + 3 * 4^2 evaluates as 2 + (3 * (4^2)) = 2 + (3 * 16) = 50[0m[0m
[90mline 1603 <<: [33m#[0m[0m
[90mline 1604 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1605 <<: [33m#   3 + 4 * 5                          # Returns 23 (not 35)[0m[0m
[90mline 1606 <<: [33m#   2^3^2                              # Returns 512 (2^(3^2) = 2^9)[0m[0m
[90mline 1607 <<: [33m#   10 / 2 + 3                         # Returns 8 ((10/2) + 3)[0m[0m
[90mline 1608 <<: [33m#   15 % 4 * 2                         # Returns 6 ((15%4) * 2)[0m[0m
[90mline 1609 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1610 <<: + = plus[0m
[32m-> + = Î»m.Î»n.Î»f.Î»x.m f (n f x)[0m
[0m [0m
[90mline 1611 <<: - = minus[0m
[32m-> - = Î»m.Î»n.n pred m[0m
[0m [0m
[90mline 1612 <<: * = mult[0m
[32m-> * = Î»m.Î»n.Î»f.m (n f)[0m
[0m [0m
[90mline 1613 <<: / = div[0m
[32m-> / = Î»m.Î»n.first (DIV_ITER false m n)[0m
[0m [0m
[90mline 1614 <<: ^ = exp[0m
[32m-> ^ = <thunk:(Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))) (Y (Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))))>[0m
[0m [0m
[90mline 1615 <<: % = mod[0m
[32m-> % = Î»m.Î»n.second (DIV_ITER false m n)[0m
[0m [0m
[90mline 1616 <<: [38;5;205m:infix + 6 left[0m[0m
[0mInfix operator '+' defined with precedence 6 and left associativity[0m
[0m [0m
[90mline 1617 <<: [38;5;205m:infix - 6 left[0m[0m
[0mInfix operator '-' defined with precedence 6 and left associativity[0m
[0m [0m
[90mline 1618 <<: [38;5;205m:infix * 7 left[0m[0m
[0mInfix operator '*' defined with precedence 7 and left associativity[0m
[0m [0m
[90mline 1619 <<: [38;5;205m:infix / 7 left[0m[0m
[0mInfix operator '/' defined with precedence 7 and left associativity[0m
[0m [0m
[90mline 1620 <<: [38;5;205m:infix % 7 left[0m[0m
[0mInfix operator '%' defined with precedence 7 and left associativity[0m
[0m [0m
[90mline 1621 <<: [38;5;205m:infix ^ 8 right[0m[0m
[0mInfix operator '^' defined with precedence 8 and right associativity[0m
[0m [0m
[90mline 1622 <<: [0m
[90mline 1623 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1624 <<: [33m# 10.2. Logical and Comparison Infix Operators[0m[0m
[90mline 1625 <<: [33m#[0m[0m
[90mline 1626 <<: [33m# These operators provide familiar syntax for logical operations and[0m[0m
[90mline 1627 <<: [33m# comparisons, essential for conditional logic and control flow.[0m[0m
[90mline 1628 <<: [33m#[0m[0m
[90mline 1629 <<: [33m# LOGICAL OPERATORS:[0m[0m
[90mline 1630 <<: [33m#   && (and) and || (or) provide short-circuit boolean evaluation[0m[0m
[90mline 1631 <<: [33m#   with appropriate precedence (and binds tighter than or).[0m[0m
[90mline 1632 <<: [33m#[0m[0m
[90mline 1633 <<: [33m# COMPARISON OPERATORS:[0m[0m
[90mline 1634 <<: [33m#   ==, !=, <, <=, >, >= provide the complete set of comparison operations[0m[0m
[90mline 1635 <<: [33m#   with consistent precedence and left-associativity.[0m[0m
[90mline 1636 <<: [33m#[0m[0m
[90mline 1637 <<: [33m# PRECEDENCE RATIONALE:[0m[0m
[90mline 1638 <<: [33m#   The precedence follows programming language conventions:[0m[0m
[90mline 1639 <<: [33m#   - Comparisons bind tighter than logical operations[0m[0m
[90mline 1640 <<: [33m#   - And binds tighter than or (mimicking mathematical convention)[0m[0m
[90mline 1641 <<: [33m#   - Equality tests bind tighter than logical operations[0m[0m
[90mline 1642 <<: [33m#[0m[0m
[90mline 1643 <<: [33m# CHAINING COMPARISONS:[0m[0m
[90mline 1644 <<: [33m#   While syntactically possible, chaining comparisons like x < y < z[0m[0m
[0mPROGRESS::94[0m
[90mline 1645 <<: [33m#   may not behave as mathematically expected due to left-associativity.[0m[0m
[90mline 1646 <<: [33m#[0m[0m
[90mline 1647 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1648 <<: [33m#   x > 0 && x < 10                    # Range check[0m[0m
[90mline 1649 <<: [33m#   a == b || a == c                   # Multiple equality[0m[0m
[90mline 1650 <<: [33m#   x != 0 && y / x > 5                # Safe division with check[0m[0m
[90mline 1651 <<: [33m#   age >= 18 && age <= 65             # Age validation[0m[0m
[90mline 1652 <<: [33m#   isValid && count > 0               # Compound conditions[0m[0m
[90mline 1653 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1654 <<: && = and[0m
[32m-> && = Î»p.Î»q.p q false[0m
[0m [0m
[90mline 1655 <<: || = or[0m
[32m-> || = [true][0m
[0m [0m
[90mline 1656 <<: == = eq[0m
[32m-> == = Î»m.Î»n.and (leq m n) (leq n m)[0m
[0m [0m
[90mline 1657 <<: != = neq[0m
[32m-> != = Î»m.Î»n.not (eq m n)[0m
[0m [0m
[90mline 1658 <<: <  = lt[0m
[32m-> < = Î»m.Î»n.and (leq m n) (not (eq m n))[0m
[0m [0m
[90mline 1659 <<: <= = leq[0m
[32m-> <= = Î»m.Î»n.iszero (minus m n)[0m
[0m [0m
[90mline 1660 <<: >  = gt[0m
[32m-> > = Î»m.Î»n.not (leq m n)[0m
[0m [0m
[90mline 1661 <<: >= = geq[0m
[32m-> >= = Î»m.Î»n.not (lt m n)[0m
[0m [0m
[90mline 1662 <<: [38;5;205m:infix && 3 left[0m[0m
[0mInfix operator '&&' defined with precedence 3 and left associativity[0m
[0m [0m
[90mline 1663 <<: [38;5;205m:infix || 2 left[0m[0m
[0mInfix operator '||' defined with precedence 2 and left associativity[0m
[0m [0m
[90mline 1664 <<: [38;5;205m:infix == 4 left[0m[0m
[0mInfix operator '==' defined with precedence 4 and left associativity[0m
[0m [0m
[90mline 1665 <<: [38;5;205m:infix != 4 left[0m[0m
[0mInfix operator '!=' defined with precedence 4 and left associativity[0m
[0m [0m
[90mline 1666 <<: [38;5;205m:infix <  5 left[0m[0m
[0mInfix operator '<' defined with precedence 5 and left associativity[0m
[0m [0m
[90mline 1667 <<: [38;5;205m:infix <= 5 left[0m[0m
[0mInfix operator '<=' defined with precedence 5 and left associativity[0m
[0m [0m
[90mline 1668 <<: [38;5;205m:infix >  5 left[0m[0m
[0mInfix operator '>' defined with precedence 5 and left associativity[0m
[0m [0m
[90mline 1669 <<: [38;5;205m:infix >= 5 left[0m[0m
[0mInfix operator '>=' defined with precedence 5 and left associativity[0m
[0m [0m
[90mline 1670 <<: [0m
[90mline 1671 <<: [0m
[90mline 1672 <<: [33m# =============================================================================[0m[0m
[90mline 1673 <<: [33m# SECTION 11: DEPRECATED AND ALIASED FUNCTIONS[0m[0m
[90mline 1674 <<: [33m#[0m[0m
[90mline 1675 <<: [33m# This section contains functions that are duplicates, aliases, or less[0m[0m
[90mline 1676 <<: [33m# efficient versions of other functions in the library. They are commented out[0m[0m
[90mline 1677 <<: [33m# to reduce clutter but are kept for historical or educational reference.[0m[0m
[90mline 1678 <<: [33m#[0m[0m
[90mline 1679 <<: [33m# PURPOSE OF THIS SECTION:[0m[0m
[90mline 1680 <<: [33m#   - Historical preservation of alternative implementations[0m[0m
[90mline 1681 <<: [33m#   - Educational examples showing different approaches to same problems[0m[0m
[90mline 1682 <<: [33m#   - Aliases that provide familiar names from other programming languages[0m[0m
[90mline 1683 <<: [33m#   - Less efficient but more explicit implementations for learning[0m[0m
[90mline 1684 <<: [33m#[0m[0m
[90mline 1685 <<: [33m# CATEGORIES:[0m[0m
[90mline 1686 <<: [33m#   1. Aliases: Alternative names for existing functions[0m[0m
[90mline 1687 <<: [33m#   2. Redundant functions: Multiple implementations of same functionality[0m[0m
[90mline 1688 <<: [33m#   3. Y-combinator examples: Explicit recursive implementations[0m[0m
[90mline 1689 <<: [33m#   4. Less efficient versions: Direct but slower implementations[0m[0m
[90mline 1690 <<: [33m#[0m[0m
[90mline 1691 <<: [33m# EDUCATIONAL VALUE:[0m[0m
[90mline 1692 <<: [33m#   These implementations demonstrate:[0m[0m
[90mline 1693 <<: [33m#   - Multiple ways to solve the same problem[0m[0m
[90mline 1694 <<: [33m#   - Trade-offs between clarity and efficiency[0m[0m
[90mline 1695 <<: [33m#   - Evolution of function design and optimization[0m[0m
[90mline 1696 <<: [33m#   - Different naming conventions across programming paradigms[0m[0m
[90mline 1697 <<: [33m#[0m[0m
[90mline 1698 <<: [33m# USAGE NOTE:[0m[0m
[90mline 1699 <<: [33m#   These functions are commented out to avoid namespace pollution.[0m[0m
[90mline 1700 <<: [33m#   Uncomment individual functions if needed for specific use cases.[0m[0m
[90mline 1701 <<: [33m# =============================================================================[0m[0m
[90mline 1702 <<: [0m
[90mline 1703 <<: [33m# --- Aliases ---[0m[0m
[90mline 1704 <<: [33m# factorial = fact[0m[0m
[90mline 1705 <<: [33m# fibonacci = fib[0m[0m
[90mline 1706 <<: [33m# contains = elem[0m[0m
[90mline 1707 <<: [33m# indexOf  = elemIndex[0m[0m
[90mline 1708 <<: clamp    = Î»min max x.if (lt x min) min (if (gt x max) max x)[0m
[32m-> clamp = Î»min.Î»max.Î»x.if (lt x min) min (if (gt x max) max x)[0m
[0m [0m
[90mline 1709 <<: [33m# bounded  = clamp[0m[0m
[90mline 1710 <<: [33m# inrange  = between[0m[0m
[90mline 1711 <<: [33m# pow2     = Î»n.exp 2 n[0m[0m
[90mline 1712 <<: [33m# pow10    = Î»n.exp 10 n[0m[0m
[90mline 1713 <<: [0m
[90mline 1714 <<: [33m# --- Redundant or Less-Used ---[0m[0m
[90mline 1715 <<: [33m# second   = Î»l.head (tail l)[0m[0m
[90mline 1716 <<: [33m# third    = Î»l.head (tail (tail l))[0m[0m
[90mline 1717 <<: [33m# butlast  = Î»l.reverse (tail (reverse l))[0m[0m
[90mline 1718 <<: [33m# removeFirst = Î»x l.filter (Î»y.not (eq x y)) l[0m[0m
[90mline 1719 <<: [33m# count    = Î»x l.length (filter (eq x) l)[0m[0m
[90mline 1720 <<: [33m# singleton = Î»x.cons x nil[0m[0m
[90mline 1721 <<: [33m# doubleton = Î»x y.cons x (cons y nil)[0m[0m
[90mline 1722 <<: [33m# tripleton = Î»x y z.cons x (cons y (cons z nil))[0m[0m
[90mline 1723 <<: [33m# issingle = Î»l.and (not (isnil l)) (isnil (tail l))[0m[0m
[90mline 1724 <<: [33m# isdouble = Î»l.and (not (isnil l)) (and (not (isnil (tail l))) (isnil (tail (tail l))))[0m[0m
[90mline 1725 <<: [33m# scanl    = Î»f z l.reverse (foldl (Î»acc x.cons (f (head acc) x) acc) (cons z nil) l)[0m[0m
[90mline 1726 <<: [33m# scanr    = Î»f z l.foldr (Î»x acc.cons (f x (head acc)) acc) (cons z nil) l[0m[0m
[90mline 1727 <<: [33m# findIndex = Î»p l.foldl (Î»acc x.if (and (isnil acc) (p x)) (cons (length acc) nil) acc) nil l[0m[0m
[90mline 1728 <<: [33m# elemIndex = Î»x l.findIndex (eq x) l[0m[0m
[90mline 1729 <<: [33m# safeInit = Î»l.if (isnil l) nil (reverse (tail (reverse l)))[0m[0m
[90mline 1730 <<: [0m
[90mline 1731 <<: [33m# --- Recursive examples using Y-combinator and infix operators (less efficient) ---[0m[0m
[90mline 1732 <<: fibY       = Y (\f. \n. if (n <= 2) 1 ((f (n - 1)) + (f (n - 2))))[0m
[32m-> fibY = <thunk:(Î»f.Î»n.if (<= n 2) 1 (+ (f (- n 1)) (f (- n 2)))) (Y (Î»f.Î»n.if (<= n 2) 1 (+ (f (- n 1)) (f (- n 2)))))>[0m
[0m [0m
[0mPROGRESS::99[0m
[90mline 1733 <<: factY      = Y (\f. \n. if (n == 0) 1 (n * (f (n - 1))))[0m
[32m-> factY = <thunk:(Î»f.Î»n.if (== n false) 1 (* n (f (- n 1)))) (Y (Î»f.Î»n.if (== n false) 1 (* n (f (- n 1)))))>[0m
[0m [0m
[90mline 1734 <<: sumUptoY   = Y (\f. \n. if (n == 0) 0 (n + (f (n - 1))))[0m
[32m-> sumUptoY = <thunk:(Î»f.Î»n.if (== n false) false (+ n (f (- n 1)))) (Y (Î»f.Î»n.if (== n false) false (+ n (f (- n 1)))))>[0m
[0m [0m
[90mline 1735 <<: expY       = Y (\f. \b n. if (n == 0) 1 (b * (f b (n - 1))))[0m
[32m-> expY = <thunk:(Î»f.Î»b.Î»n.if (== n false) 1 (* b (f b (- n 1)))) (Y (Î»f.Î»b.Î»n.if (== n false) 1 (* b (f b (- n 1)))))>[0m
[0m [0m
[90mline 1736 <<: rangeY     = \n. Y (\f k. if (k == n) nil (cons k (f (k + 1)))) 0[0m
[32m-> rangeY = Î»n.Y (Î»f.Î»k.if (== k n) [] (cons k (f (+ k 1)))) false[0m
[0m [0m
[90mline 1737 <<: countdownY = \n. Y (\f k. if (k == 0) (cons 0 nil) (cons k (f (k - 1)))) n[0m
[32m-> countdownY = Î»n.Y (Î»f.Î»k.if (== k false) ([false]) (cons k (f (- k 1)))) n[0m
[0m [0m
[90mline 1738 <<: gcdY       = Y (\f. \a b. if (b == 0) a (f b (a % b)))[0m
[32m-> gcdY = <thunk:(Î»f.Î»a.Î»b.if (== b false) a (f b (% a b))) (Y (Î»f.Î»a.Î»b.if (== b false) a (f b (% a b))))>[0m
[0m [0m
[90mline 1739 <<: lcmY       = Y (\f. \a b. if (a == 0 || b == 0) 0 ((a * b) / (gcdY a b)))[0m
[32m-> lcmY = <thunk:(Î»f.Î»a.Î»b.if (|| (== a false) (== b false)) false (/ (* a b) (gcdY a b))) (Y (Î»f.Î»a.Î»b.if (|| (== a false) (== b false)) false (/ (* a b) (gcdY a b))))>[0m
[0m [0m
[90mline 1740 <<: mapY       = Y (\f. \g l. if (isnil l) nil (cons (g (head l)) (f g (tail l))))[0m
[32m-> mapY = <thunk:(Î»f.Î»g.Î»l.if (isnil l) [] (cons (g (head l)) (f g (tail l)))) (Y (Î»f.Î»g.Î»l.if (isnil l) [] (cons (g (head l)) (f g (tail l)))))>[0m
[0m [0m
[90mline 1741 <<: filterY    = Y (\f. \p l. if (isnil l) nil (if (p (head l)) (cons (head l) (f p (tail l))) (f p (tail l))))[0m
[32m-> filterY = <thunk:(Î»f.Î»p.Î»l.if (isnil l) [] (if (p (head l)) (cons (head l) (f p (tail l))) (f p (tail l)))) (Y (Î»f.Î»p.Î»l.if (isnil l) [] (if (p (head l)) (cons (head l) (f p (tail l))) (f p (tail l)))))>[0m
[0m [0m
[90mline 1742 <<: lengthY    = Y (\f. \l. if (isnil l) 0 (1 + (f (tail l))))[0m
[32m-> lengthY = <thunk:(Î»f.Î»l.if (isnil l) false (+ 1 (f (tail l)))) (Y (Î»f.Î»l.if (isnil l) false (+ 1 (f (tail l)))))>[0m
[0m [0m
[90mline 1743 <<: reverseY   = \l. Y (\f l acc. if (isnil l) acc (f (tail l) (cons (head l) acc))) l nil[0m
[32m-> reverseY = Î»l.Y (Î»f.Î»l.Î»acc.if (isnil l) acc (f (tail l) (cons (head l) acc))) l [][0m
[0m [0m
[90mline 1744 <<: sumY       = Y (\f. \l. if (isnil l) 0 ((head l) + (f (tail l))))[0m
[32m-> sumY = <thunk:(Î»f.Î»l.if (isnil l) false (+ (head l) (f (tail l)))) (Y (Î»f.Î»l.if (isnil l) false (+ (head l) (f (tail l)))))>[0m
[0m [0m
[90mline 1745 <<: productY   = Y (\f. \l. if (isnil l) 1 ((head l) * (f (tail l))))[0m
[32m-> productY = <thunk:(Î»f.Î»l.if (isnil l) 1 (* (head l) (f (tail l)))) (Y (Î»f.Î»l.if (isnil l) 1 (* (head l) (f (tail l)))))>[0m
[0m [0m
[90mline 1746 <<: anyY       = Y (\f. \p l. if (isnil l) false (or (p (head l)) (f p (tail l))))[0m
[32m-> anyY = <thunk:(Î»f.Î»p.Î»l.if (isnil l) false (or (p (head l)) (f p (tail l)))) (Y (Î»f.Î»p.Î»l.if (isnil l) false (or (p (head l)) (f p (tail l)))))>[0m
[0m [0m
[90mline 1747 <<: allY       = Y (\f. \p l. if (isnil l) true (and (p (head l)) (f p (tail l))))[0m
[32m-> allY = <thunk:(Î»f.Î»p.Î»l.if (isnil l) true (and (p (head l)) (f p (tail l)))) (Y (Î»f.Î»p.Î»l.if (isnil l) true (and (p (head l)) (f p (tail l)))))>[0m
[0m [0m
[90mline 1748 <<: findY      = Y (\f. \p l. if (isnil l) nil (if (p (head l)) (head l) (f p (tail l))))[0m
[32m-> findY = <thunk:(Î»f.Î»p.Î»l.if (isnil l) [] (if (p (head l)) (head l) (f p (tail l)))) (Y (Î»f.Î»p.Î»l.if (isnil l) [] (if (p (head l)) (head l) (f p (tail l)))))>[0m
[0m [0m
[90mline 1749 <<: [0m
[0mPROGRESS::100[0m
[0mLoaded file 'stdlib.lambda' lines=1750 time=97.5 ms[0m
[36mLoading commands from 'stdlib.lambda'[0m
[90mline 0 <<: [33m# =============================================================================[0m[0m
[90mline 1 <<: [33m# stdlib.lambda - Standard Library for Lambda Interpreter[0m[0m
[90mline 2 <<: [33m#[0m[0m
[90mline 3 <<: [33m# This library provides a comprehensive set of functions and utilities for[0m[0m
[90mline 4 <<: [33m# programming in the untyped lambda calculus. It includes everything from[0m[0m
[90mline 5 <<: [33m# basic boolean logic and Church numerals to advanced data structures,[0m[0m
[90mline 6 <<: [33m# functional programming utilities, and a macro system.[0m[0m
[90mline 7 <<: [33m# =============================================================================[0m[0m
[90mline 8 <<: [0m
[90mline 9 <<: [0m
[90mline 10 <<: [33m# =============================================================================[0m[0m
[90mline 11 <<: [33m# SECTION 1: CORE LANGUAGE CONSTRUCTS[0m[0m
[90mline 12 <<: [33m#[0m[0m
[90mline 13 <<: [33m# This section defines the fundamental building blocks of the language,[0m[0m
[90mline 14 <<: [33m# including core identity, boolean logic, and conditional expressions.[0m[0m
[90mline 15 <<: [33m# =============================================================================[0m[0m
[90mline 16 <<: [0m
[90mline 17 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 18 <<: [33m# 1.1. Core Identity and Combinators[0m[0m
[90mline 19 <<: [33m#[0m[0m
[90mline 20 <<: [33m# These are the fundamental building blocks of combinatory logic and lambda calculus.[0m[0m
[90mline 21 <<: [33m# They form the mathematical foundation for all higher-level programming constructs.[0m[0m
[90mline 22 <<: [33m#[0m[0m
[90mline 23 <<: [33m# THEORY:[0m[0m
[90mline 24 <<: [33m#   - I (Identity): The simplest combinator, returns its argument unchanged[0m[0m
[90mline 25 <<: [33m#   - K (Constant): Creates constant functions, foundation for Church booleans[0m[0m
[90mline 26 <<: [33m#   - S (Substitution): Most powerful combinator, can express any computable function[0m[0m
[90mline 27 <<: [33m#   - B (Composition): Function composition, essential for building complex functions[0m[0m
[90mline 28 <<: [33m#   - C (Flip): Argument order manipulation, useful for partial application[0m[0m
[90mline 29 <<: [33m#[0m[0m
[90mline 30 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 31 <<: [33m#   I 42          # Returns 42 (identity)[0m[0m
[90mline 32 <<: [33m#   K 1 2         # Returns 1 (constant function, ignores second argument)[0m[0m
[90mline 33 <<: [33m#   S plus mult 3 # Returns plus 3 (mult 3) = plus 3 (3*3) = plus 3 9 = 12[0m[0m
[90mline 34 <<: [33m#   B succ double 5 # Returns succ (double 5) = succ 10 = 11[0m[0m
[90mline 35 <<: [33m#   C minus 3 10  # Returns minus 10 3 = 7 (flipped arguments)[0m[0m
[90mline 36 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 37 <<: id       = Î»x.x[0m
[32m-> id = Î»x.x[0m
[0m [0m
[90mline 38 <<: [33m# Secondary identity & constant aliases used in tests[0m[0m
[90mline 39 <<: id2      = id[0m
[32m-> id2 = Î»x.x[0m
[0m [0m
[90mline 40 <<: const2   = K[0m
[32m-> const2 = K[0m
[0m [0m
[90mline 41 <<: K        = Î»x y.x[0m
[32m-> K = true[0m
[0m [0m
[90mline 42 <<: I        = Î»x.x[0m
[32m-> I = Î»x.x[0m
[0m [0m
[90mline 43 <<: S        = Î»x y z.x z (y z)[0m
[32m-> S = Î»x.Î»y.Î»z.x z (y z)[0m
[0m [0m
[90mline 44 <<: B        = Î»x y z.x (y z)[0m
[32m-> B = Î»x.Î»y.Î»z.x (y z)[0m
[0m [0m
[90mline 45 <<: C        = Î»x y z.x z y[0m
[32m-> C = Î»x.Î»y.Î»z.x z y[0m
[0m [0m
[90mline 46 <<: [33m# Y        = Î»f.(Î»x.f (x x)) (Î»x.f (x x)) # The Y combinator is defined natively by the interpreter for recursion.[0m[0m
[90mline 47 <<: [0m
[90mline 48 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 49 <<: [33m# 1.2. Boolean Logic and Conditionals[0m[0m
[90mline 50 <<: [33m#[0m[0m
[90mline 51 <<: [33m# Church booleans are the foundation of conditional logic in lambda calculus.[0m[0m
[90mline 52 <<: [33m# They are encoded as selector functions that choose between two alternatives.[0m[0m
[90mline 53 <<: [33m#[0m[0m
[90mline 54 <<: [33m# ENCODING:[0m[0m
[90mline 55 <<: [33m#   true  = Î»x y.x  (selects first argument)[0m[0m
[90mline 56 <<: [33m#   false = Î»x y.y  (selects second argument)[0m[0m
[90mline 57 <<: [33m#[0m[0m
[90mline 58 <<: [33m# This encoding makes conditionals natural: (condition then-branch else-branch)[0m[0m
[90mline 59 <<: [33m# [0m[0m
[90mline 60 <<: [33m# LOGIC OPERATIONS:[0m[0m
[90mline 61 <<: [33m#   - NOT: Flips the selector by swapping the arguments to true/false[0m[0m
[90mline 62 <<: [33m#   - AND: Returns second argument if first is true, otherwise false[0m[0m
[90mline 63 <<: [33m#   - OR: Returns true if first argument is true, otherwise second argument[0m[0m
[90mline 64 <<: [33m#   - XOR: Returns true if exactly one argument is true[0m[0m
[90mline 65 <<: [33m#[0m[0m
[90mline 66 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 67 <<: [33m#   true 1 0              # Returns 1 (selects first argument)[0m[0m
[90mline 68 <<: [33m#   false 1 0             # Returns 0 (selects second argument)[0m[0m
[90mline 69 <<: [33m#   if (gt 5 3) "yes" "no" # Returns "yes" (if 5 > 3 then "yes" else "no")[0m[0m
[0mPROGRESS::4[0m
[90mline 70 <<: [33m#   and true false        # Returns false[0m[0m
[90mline 71 <<: [33m#   or false true         # Returns true[0m[0m
[90mline 72 <<: [33m#   not true              # Returns false[0m[0m
[90mline 73 <<: [33m#   xor true true         # Returns false (both true, so XOR is false)[0m[0m
[90mline 74 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 75 <<: true     = Î»x y.x[0m
[32m-> true = true[0m
[0m [0m
[90mline 76 <<: false    = Î»x y.y[0m
[32m-> false = false[0m
[0m [0m
[90mline 77 <<: if       = Î»p a b.p a b[0m
[32m-> if = Î»p.Î»a.Î»b.p a b[0m
[0m [0m
[90mline 78 <<: cond     = if[0m
[32m-> cond = Î»p.Î»a.Î»b.p a b[0m
[0m [0m
[90mline 79 <<: not      = Î»p.p false true[0m
[32m-> not = Î»p.p false true[0m
[0m [0m
[90mline 80 <<: and      = Î»p q.p q false[0m
[32m-> and = Î»p.Î»q.p q false[0m
[0m [0m
[90mline 81 <<: or       = Î»p q.p true q[0m
[32m-> or = [true][0m
[0m [0m
[90mline 82 <<: xor      = Î»p q.p (not q) q[0m
[32m-> xor = [not q][0m
[0m [0m
[90mline 83 <<: eqBool   = Î»x y.x y (not y)[0m
[32m-> eqBool = Î»x.Î»y.x y (not y)[0m
[0m [0m
[90mline 84 <<: [0m
[90mline 85 <<: [33m# Conditional application utilities[0m[0m
[90mline 86 <<: when     = Î»p f x.if p (f x) x              [33m# Apply function conditionally[0m[0m
[32m-> when = Î»p.Î»f.Î»x.if p (f x) x[0m
[0m [0m
[90mline 87 <<: unless   = Î»p f x.if p x (f x)              [33m# Apply function unless condition[0m[0m
[32m-> unless = Î»p.Î»f.Î»x.if p x (f x)[0m
[0m [0m
[90mline 88 <<: [33m# cond     = Î»p t e.if p t e                  # (Now provided earlier as alias)[0m[0m
[90mline 89 <<: [0m
[90mline 90 <<: [0m
[90mline 91 <<: [33m# =============================================================================[0m[0m
[90mline 92 <<: [33m# SECTION 2: NUMERIC COMPUTATION[0m[0m
[90mline 93 <<: [33m#[0m[0m
[90mline 94 <<: [33m# This section covers all aspects of numeric computation using Church numerals.[0m[0m
[90mline 95 <<: [33m# It includes basic arithmetic, comparisons, advanced functions like GCD and[0m[0m
[90mline 96 <<: [33m# prime checking, and iterative helpers for performance.[0m[0m
[90mline 97 <<: [33m# =============================================================================[0m[0m
[90mline 98 <<: [0m
[90mline 99 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 100 <<: [33m# 2.1. Church Numerals and Basic Arithmetic[0m[0m
[90mline 101 <<: [33m#[0m[0m
[90mline 102 <<: [33m# Church numerals encode natural numbers as higher-order functions that represent[0m[0m
[90mline 103 <<: [33m# repeated function application. This encoding makes arithmetic operations natural[0m[0m
[90mline 104 <<: [33m# function compositions and provides the foundation for all numeric computation.[0m[0m
[90mline 105 <<: [33m#[0m[0m
[90mline 106 <<: [33m# ENCODING:[0m[0m
[90mline 107 <<: [33m#   Number n = Î»f.Î»x.f^n(x)  (apply function f exactly n times to x)[0m[0m
[90mline 108 <<: [33m#   0 = Î»f.Î»x.x              (apply f zero times: just return x)[0m[0m
[90mline 109 <<: [33m#   1 = Î»f.Î»x.f x            (apply f once)[0m[0m
[90mline 110 <<: [33m#   2 = Î»f.Î»x.f (f x)        (apply f twice)[0m[0m
[90mline 111 <<: [33m#   3 = Î»f.Î»x.f (f (f x))    (apply f three times)[0m[0m
[90mline 112 <<: [33m#[0m[0m
[90mline 113 <<: [33m# ARITHMETIC OPERATIONS:[0m[0m
[90mline 114 <<: [33m#   - Addition: Apply f m times, then n more times[0m[0m
[90mline 115 <<: [33m#   - Multiplication: Compose f with itself m*n times[0m[0m
[90mline 116 <<: [33m#   - Exponentiation: Apply the "multiply by base" function n times[0m[0m
[90mline 117 <<: [33m#   - Predecessor: Complex operation using pairs and projection[0m[0m
[90mline 118 <<: [33m#[0m[0m
[90mline 119 <<: [33m# PERFORMANCE NOTE: [0m[0m
[90mline 120 <<: [33m#   Enable native arithmetic with :native on for faster computation of large numbers.[0m[0m
[90mline 121 <<: [33m#[0m[0m
[90mline 122 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 123 <<: [33m#   plus 3 4        # Returns 7 (Church numeral for 7)[0m[0m
[90mline 124 <<: [33m#   mult 6 7        # Returns 42 (Church numeral for 42)[0m[0m
[90mline 125 <<: [33m#   exp 2 3         # Returns 8 (2^3 as Church numeral)[0m[0m
[90mline 126 <<: [33m#   iszero 0        # Returns true (Church boolean)[0m[0m
[90mline 127 <<: [33m#   succ 5          # Returns 6 (successor of 5)[0m[0m
[90mline 128 <<: [33m#   pred 3          # Returns 2 (predecessor of 3, pred 0 = 0)[0m[0m
[90mline 129 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 130 <<: zero     = Î»f x.x[0m
[32m-> zero = false[0m
[0m [0m
[90mline 131 <<: succ     = Î»n f x.f (n f x)[0m
[32m-> succ = Î»n.Î»f.Î»x.f (n f x)[0m
[0m [0m
[90mline 132 <<: pred     = Î»n f x.n (Î»g h.h (g f)) (Î»u.x) (Î»u.u)[0m
[32m-> pred = Î»n.Î»f.Î»x.n (Î»g.Î»h.h (g f)) (Î»u.x) (Î»u.u)[0m
[0m [0m
[90mline 133 <<: plus     = Î»m n f x.m f (n f x)[0m
[32m-> plus = Î»m.Î»n.Î»f.Î»x.m f (n f x)[0m
[0m [0m
[90mline 134 <<: minus    = Î»m n.n pred m[0m
[32m-> minus = Î»m.Î»n.n pred m[0m
[0m [0m
[90mline 135 <<: mult     = Î»m n f.m (n f)[0m
[32m-> mult = Î»m.Î»n.Î»f.m (n f)[0m
[0m [0m
[90mline 136 <<: exp      = Y (Î»f. Î»b n. if (iszero n) 1 (mult b (f b (pred n))))[0m
[32m-> exp = <thunk:(Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))) (Y (Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))))>[0m
[0m [0m
[90mline 137 <<: pow      = exp[0m
[32m-> pow = <thunk:(Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))) (Y (Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))))>[0m
[0m [0m
[90mline 138 <<: iszero   = Î»n.n (Î»x.false) true[0m
[32m-> iszero = Î»n.n (Î»x.false) true[0m
[0m [0m
[90mline 139 <<: [0m
[90mline 140 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 141 <<: [33m# 2.2. Division and Modulo[0m[0m
[90mline 142 <<: [33m#[0m[0m
[90mline 143 <<: [33m# Division and modulo are implemented using an iterative helper function that[0m[0m
[90mline 144 <<: [33m# repeatedly subtracts the divisor from the dividend while counting iterations.[0m[0m
[90mline 145 <<: [33m# The helper returns a pair (quotient, remainder) which is then destructured.[0m[0m
[90mline 146 <<: [33m#[0m[0m
[90mline 147 <<: [33m# ALGORITHM:[0m[0m
[90mline 148 <<: [33m#   1. Start with quotient = 0, remainder = dividend[0m[0m
[90mline 149 <<: [33m#   2. While remainder >= divisor:[0m[0m
[90mline 150 <<: [33m#      - Increment quotient[0m[0m
[90mline 151 <<: [33m#      - Subtract divisor from remainder[0m[0m
[90mline 152 <<: [33m#   3. Return (quotient, remainder)[0m[0m
[90mline 153 <<: [33m#[0m[0m
[90mline 154 <<: [33m# SAFETY: Division by zero returns 0 (handled by the lt comparison failing)[0m[0m
[90mline 155 <<: [33m#[0m[0m
[90mline 156 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 157 <<: [33m#   div 15 3        # Returns 5 (15 Ã· 3 = 5)[0m[0m
[0mPROGRESS::9[0m
[90mline 158 <<: [33m#   mod 17 5        # Returns 2 (17 mod 5 = 2)[0m[0m
[90mline 159 <<: [33m#   div 7 0         # Returns 0 (division by zero protection)[0m[0m
[90mline 160 <<: [33m#   mod 10 3        # Returns 1 (10 mod 3 = 1)[0m[0m
[90mline 161 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 162 <<: [33m# Iterative division helper. Returns a pair (quotient, remainder).[0m[0m
[90mline 163 <<: DIV_ITER = Y(Î»f. Î»q m n. \[0m
[90mline 164 <<:     if (lt m n) \[0m
[90mline 165 <<:         (pair q m)\[0m
[90mline 166 <<:         (f (succ q) (minus m n) n)\[0m
[90mline 167 <<: )[0m
[32m-> DIV_ITER = <thunk:(Î»f.Î»q.Î»m.Î»n.if (lt m n) (pair q m) (f (succ q) (minus m n) n)) (Y (Î»f.Î»q.Î»m.Î»n.if (lt m n) (pair q m) (f (succ q) (minus m n) n)))>[0m
[0m [0m
[90mline 168 <<: div = Î»m n. first (DIV_ITER 0 m n)[0m
[32m-> div = Î»m.Î»n.first (DIV_ITER false m n)[0m
[0m [0m
[90mline 169 <<: mod = Î»m n. second (DIV_ITER 0 m n)[0m
[32m-> mod = Î»m.Î»n.second (DIV_ITER false m n)[0m
[0m [0m
[90mline 170 <<: [0m
[90mline 171 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 172 <<: [33m# 2.3. Comparison Operations[0m[0m
[90mline 173 <<: [33m#[0m[0m
[90mline 174 <<: [33m# All comparison operations are built on Church numeral subtraction and the iszero[0m[0m
[90mline 175 <<: [33m# predicate. The foundation is the leq (â‰¤) operation, which checks if m-n equals zero.[0m[0m
[90mline 176 <<: [33m# All other comparisons are derived from this basic operation.[0m[0m
[90mline 177 <<: [33m#[0m[0m
[90mline 178 <<: [33m# IMPLEMENTATION STRATEGY:[0m[0m
[90mline 179 <<: [33m#   - leq m n: Check if (m - n) = 0, meaning m â‰¤ n[0m[0m
[90mline 180 <<: [33m#   - eq m n: Check if both m â‰¤ n AND n â‰¤ m[0m[0m
[90mline 181 <<: [33m#   - lt m n: Check if m â‰¤ n but NOT m = n[0m[0m
[90mline 182 <<: [33m#   - gt m n: Check if NOT m â‰¤ n[0m[0m
[90mline 183 <<: [33m#   - geq/neq: Logical negations of lt/eq respectively[0m[0m
[90mline 184 <<: [33m#[0m[0m
[90mline 185 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 186 <<: [33m#   leq 3 5         # Returns true (3 â‰¤ 5)[0m[0m
[90mline 187 <<: [33m#   eq 4 4          # Returns true (4 = 4)[0m[0m
[90mline 188 <<: [33m#   lt 2 2          # Returns false (2 is not < 2)[0m[0m
[90mline 189 <<: [33m#   gt 7 3          # Returns true (7 > 3)[0m[0m
[90mline 190 <<: [33m#   geq 5 5         # Returns true (5 â‰¥ 5)[0m[0m
[90mline 191 <<: [33m#   neq 3 8         # Returns true (3 â‰  8)[0m[0m
[90mline 192 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 193 <<: leq      = Î»m n.iszero (minus m n)[0m
[32m-> leq = Î»m.Î»n.iszero (minus m n)[0m
[0m [0m
[90mline 194 <<: eq       = Î»m n.and (leq m n) (leq n m)[0m
[32m-> eq = Î»m.Î»n.and (leq m n) (leq n m)[0m
[0m [0m
[90mline 195 <<: lt       = Î»m n.and (leq m n) (not (eq m n))[0m
[32m-> lt = Î»m.Î»n.and (leq m n) (not (eq m n))[0m
[0m [0m
[90mline 196 <<: gt       = Î»m n.not (leq m n)[0m
[32m-> gt = Î»m.Î»n.not (leq m n)[0m
[0m [0m
[90mline 197 <<: geq      = Î»m n.not (lt m n)[0m
[32m-> geq = Î»m.Î»n.not (lt m n)[0m
[0m [0m
[90mline 198 <<: neq      = Î»m n.not (eq m n)[0m
[32m-> neq = Î»m.Î»n.not (eq m n)[0m
[0m [0m
[90mline 199 <<: [0m
[90mline 200 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 201 <<: [33m# 2.4. Additional Numeric Operations and Predicates[0m[0m
[90mline 202 <<: [33m#[0m[0m
[90mline 203 <<: [33m# This collection provides common mathematical operations and numeric predicates[0m[0m
[90mline 204 <<: [33m# built on top of the basic Church numeral operations. These functions demonstrate[0m[0m
[90mline 205 <<: [33m# how complex mathematical concepts can be expressed in pure lambda calculus.[0m[0m
[90mline 206 <<: [33m#[0m[0m
[90mline 207 <<: [33m# MATHEMATICAL OPERATIONS:[0m[0m
[90mline 208 <<: [33m#   - square/double/triple/quadruple: Common multiplications[0m[0m
[90mline 209 <<: [33m#   - half: Integer division by 2[0m[0m
[90mline 210 <<: [33m#   - abs: Absolute value (no-op for Church numerals since they're non-negative)[0m[0m
[90mline 211 <<: [33m#   - max/min: Selection based on comparison[0m[0m
[90mline 212 <<: [33m#[0m[0m
[90mline 213 <<: [33m# PREDICATES:[0m[0m
[90mline 214 <<: [33m#   - even/odd: Based on modulo 2 operation[0m[0m
[90mline 215 <<: [33m#   - isone/istwo: Specific equality checks[0m[0m
[90mline 216 <<: [33m#   - ispositive: Non-zero check[0m[0m
[90mline 217 <<: [33m#[0m[0m
[90mline 218 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 219 <<: [33m#   square 7        # Returns 49 (7Â²)[0m[0m
[90mline 220 <<: [33m#   double 6        # Returns 12 (2 Ã— 6)[0m[0m
[90mline 221 <<: [33m#   half 10         # Returns 5 (10 Ã· 2)[0m[0m
[90mline 222 <<: [33m#   even 8          # Returns true (8 is even)[0m[0m
[90mline 223 <<: [33m#   odd 7           # Returns true (7 is odd)[0m[0m
[90mline 224 <<: [33m#   max 5 3         # Returns 5 (maximum of 5 and 3)[0m[0m
[90mline 225 <<: [33m#   min 5 3         # Returns 3 (minimum of 5 and 3)[0m[0m
[90mline 226 <<: [33m#   ispositive 0    # Returns false (0 is not positive)[0m[0m
[90mline 227 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 228 <<: square   = Î»n.mult n n[0m
[32m-> square = Î»n.mult n n[0m
[0m [0m
[90mline 229 <<: double   = Î»n.plus n n[0m
[32m-> double = Î»n.plus n n[0m
[0m [0m
[90mline 230 <<: half     = Î»n.div n 2[0m
[32m-> half = Î»n.div n 2[0m
[0m [0m
[90mline 231 <<: even     = Î»n.eq (mod n 2) zero[0m
[32m-> even = Î»n.eq (mod n 2) zero[0m
[0m [0m
[90mline 232 <<: odd      = Î»n.not (even n)[0m
[32m-> odd = Î»n.not (even n)[0m
[0m [0m
[90mline 233 <<: abs      = Î»n.n                               [33m# Church numerals are non-negative[0m[0m
[32m-> abs = Î»n.n[0m
[0m [0m
[90mline 234 <<: max      = Î»m n.if (geq m n) m n[0m
[32m-> max = Î»m.Î»n.if (geq m n) m n[0m
[0m [0m
[90mline 235 <<: min      = Î»m n.if (leq m n) m n[0m
[32m-> min = Î»m.Î»n.if (leq m n) m n[0m
[0m [0m
[90mline 236 <<: [33m# pow      = exp                              # Alias for exp[0m[0m
[90mline 237 <<: isone    = Î»n.eq n 1[0m
[32m-> isone = Î»n.eq n 1[0m
[0m [0m
[90mline 238 <<: istwo    = Î»n.eq n 2[0m
[32m-> istwo = Î»n.eq n 2[0m
[0m [0m
[90mline 239 <<: ispositive = Î»n.not (iszero n)[0m
[32m-> ispositive = Î»n.not (iszero n)[0m
[0m [0m
[90mline 240 <<: triple   = Î»n.plus n (plus n n)[0m
[32m-> triple = Î»n.plus n (plus n n)[0m
[0m [0m
[90mline 241 <<: quadruple = Î»n.plus (double n) (double n)[0m
[32m-> quadruple = Î»n.plus (double n) (double n)[0m
[0m [0m
[90mline 242 <<: [0m
[90mline 243 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 244 <<: [33m# 2.5. Advanced Numeric Algorithms[0m[0m
[0mPROGRESS::14[0m
[90mline 245 <<: [33m#[0m[0m
[90mline 246 <<: [33m# This section implements sophisticated mathematical algorithms using Church numerals[0m[0m
[90mline 247 <<: [33m# and lambda calculus techniques. These functions demonstrate how complex mathematics[0m[0m
[90mline 248 <<: [33m# can be expressed in pure functional form.[0m[0m
[90mline 249 <<: [33m#[0m[0m
[90mline 250 <<: [33m# ALGORITHMS IMPLEMENTED:[0m[0m
[90mline 251 <<: [33m#   - Iterative Factorial: Uses pair accumulation to avoid deep recursion[0m[0m
[90mline 252 <<: [33m#   - Iterative Fibonacci: Maintains (current, next) pair that shifts each iteration[0m[0m
[90mline 253 <<: [33m#   - Euclidean GCD: Classic algorithm using modulo and recursion[0m[0m
[90mline 254 <<: [33m#   - Newton's Method Square Root: Iterative approximation with convergence check[0m[0m
[90mline 255 <<: [33m#   - Trial Division Primality: Tests divisibility up to âˆšn for efficiency[0m[0m
[90mline 256 <<: [33m#   - Ackermann Function: Extremely fast-growing function (use small arguments!)[0m[0m
[90mline 257 <<: [33m#[0m[0m
[90mline 258 <<: [33m# PERFORMANCE NOTES:[0m[0m
[90mline 259 <<: [33m#   - Iterative versions (fact, fib) avoid stack overflow for large inputs[0m[0m
[90mline 260 <<: [33m#   - Square root uses 20 iterations maximum with Newton's method[0m[0m
[90mline 261 <<: [33m#   - Prime checking is optimized to test only up to âˆšn[0m[0m
[90mline 262 <<: [33m#   - GCD uses the efficient Euclidean algorithm[0m[0m
[90mline 263 <<: [33m#[0m[0m
[90mline 264 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 265 <<: [33m#   fact 5              # Returns 120 (5! = 5Ã—4Ã—3Ã—2Ã—1)[0m[0m
[90mline 266 <<: [33m#   fib 10              # Returns 55 (10th Fibonacci number)[0m[0m
[90mline 267 <<: [33m#   gcd 48 18           # Returns 6 (greatest common divisor)[0m[0m
[90mline 268 <<: [33m#   lcm 4 6             # Returns 12 (least common multiple)[0m[0m
[90mline 269 <<: [33m#   sqrt 25             # Returns 5 (integer square root)[0m[0m
[90mline 270 <<: [33m#   sqrt 26             # Returns 5 (integer square root, rounded down)[0m[0m
[90mline 271 <<: [33m#   isPrime 17          # Returns true (17 is prime)[0m[0m
[90mline 272 <<: [33m#   isPrime 15          # Returns false (15 = 3Ã—5, not prime)[0m[0m
[90mline 273 <<: [33m#   ackermann 3 2       # Returns 29 (grows very fast - keep arguments small!)[0m[0m
[90mline 274 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 275 <<: [33m# Iterative Factorial[0m[0m
[90mline 276 <<: FACT_ITER_HELPER = Î»n.n (Î»p.pair (succ (first p)) \[0m
[90mline 277 <<:                                   (mult (succ (first p)) (second p))) \[0m
[90mline 278 <<:                          (pair 0 1)[0m
[32m-> FACT_ITER_HELPER = Î»n.n (Î»p.pair (succ (first p)) (mult (succ (first p)) (second p))) (pair false 1)[0m
[0m [0m
[90mline 279 <<: fact             = Î»n.second (FACT_ITER_HELPER n)[0m
[32m-> fact = Î»n.second (FACT_ITER_HELPER n)[0m
[0m [0m
[90mline 280 <<: [0m
[90mline 281 <<: [33m# Iterative Fibonacci[0m[0m
[90mline 282 <<: FIB_ITER_HELPER  = Î»n.n (Î»p.pair (second p) \[0m
[90mline 283 <<:                                   (plus (first p) (second p))) \[0m
[90mline 284 <<:                          (pair 0 1)[0m
[32m-> FIB_ITER_HELPER = Î»n.n (Î»p.pair (second p) (plus (first p) (second p))) (pair false 1)[0m
[0m [0m
[90mline 285 <<: fib              = Î»n.first (FIB_ITER_HELPER n)[0m
[32m-> fib = Î»n.first (FIB_ITER_HELPER n)[0m
[0m [0m
[90mline 286 <<: [0m
[90mline 287 <<: [33m# GCD and LCM using Euclidean algorithm[0m[0m
[90mline 288 <<: gcd = Y (Î»g a b. if (iszero b) a (g b (mod a b)))[0m
[32m-> gcd = <thunk:(Î»g.Î»a.Î»b.if (iszero b) a (g b (mod a b))) (Y (Î»g.Î»a.Î»b.if (iszero b) a (g b (mod a b))))>[0m
[0m [0m
[90mline 289 <<: lcm = Î»a b. if (or (iszero a) (iszero b)) 0 (div (mult a b) (gcd a b))[0m
[32m-> lcm = Î»a.Î»b.if (or (iszero a) (iszero b)) false (div (mult a b) (gcd a b))[0m
[0m [0m
[90mline 290 <<: [0m
[90mline 291 <<: [33m# Square Root using Newton's method[0m[0m
[90mline 292 <<: SQRT_NEWTON_STEP = Î»n x. half (plus x (div n x))[0m
[32m-> SQRT_NEWTON_STEP = Î»n.Î»x.half (plus x (div n x))[0m
[0m [0m
[90mline 293 <<: SQRT_CONVERGED   = Î»n x. leq (abs (minus (mult x x) n)) 1[0m
[32m-> SQRT_CONVERGED = Î»n.Î»x.leq (abs (minus (mult x x) n)) 1[0m
[0m [0m
[90mline 294 <<: SQRT_ITER        = Y (Î»f n x iterations. \[0m
[90mline 295 <<:     if (or (SQRT_CONVERGED n x) (iszero iterations)) \[0m
[90mline 296 <<:         x \[0m
[90mline 297 <<:         (f n (SQRT_NEWTON_STEP n x) (pred iterations)) \[0m
[90mline 298 <<: )[0m
[32m-> SQRT_ITER = <thunk:(Î»f.Î»n.Î»x.Î»iterations.if (or (SQRT_CONVERGED n x) (iszero iterations)) x (f n (SQRT_NEWTON_STEP n x) (pred iterations))) (Y (Î»f.Î»n.Î»x.Î»iterations.if (or (SQRT_CONVERGED n x) (iszero iterations)) x (f n (SQRT_NEWTON_STEP n x) (pred iterations))))>[0m
[0m [0m
[90mline 299 <<: sqrt = Î»n. \[0m
[90mline 300 <<:     if (iszero n) zero \[0m
[90mline 301 <<:     (if (eq n 1) 1 \[0m
[90mline 302 <<:         (SQRT_ITER n (half (plus n 1)) 20))  [33m# Initial guess: (n+1)/2, 20 iterations[0m[0m
[32m-> sqrt = Î»n.if (iszero n) zero (if (eq n 1) 1 (SQRT_ITER n (half (plus n 1)) 20))[0m
[0m [0m
[90mline 303 <<: [0m
[90mline 304 <<: [33m# Prime number check via trial division[0m[0m
[90mline 305 <<: isPrime = Y (Î»f n. \[0m
[90mline 306 <<:     let iter = Y (Î»iter i. \[0m
[90mline 307 <<:         if (gt (mult i i) n) true \[0m
[90mline 308 <<:         (if (eq (mod n i) 0) false \[0m
[90mline 309 <<:             (iter (succ i))) \[0m
[90mline 310 <<:     ) in \[0m
[90mline 311 <<:     if (lt n 2) false (iter 2) \[0m
[90mline 312 <<: )[0m
[32m-> isPrime = <thunk:(Î»f.Î»n.(Î»iter.if (lt n 2) false (iter 2)) (Y (Î»iter.Î»i.if (gt (mult i i) n) true (if (eq (mod n i) false) false (iter (succ i)))))) (Y (Î»f.Î»n.(Î»iter.if (lt n 2) false (iter 2)) (Y (Î»iter.Î»i.if (gt (mult i i) n) true (if (eq (mod n i) false) false (iter (succ i)))))))>[0m
[0m [0m
[90mline 313 <<: [0m
[90mline 314 <<: [33m# Ackermann function[0m[0m
[90mline 315 <<: ackermann  = \p.(p (\a.\q.(a (q a 1))) succ)[0m
[32m-> ackermann = Î»p.p (Î»a.Î»q.a (q a 1)) succ[0m
[0m [0m
[90mline 316 <<: [0m
[90mline 317 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 318 <<: [33m# 2.6. Recursive Function Examples (using Y combinator)[0m[0m
[90mline 319 <<: [33m#[0m[0m
[90mline 320 <<: [33m# These are alternative, often less efficient, implementations provided for[0m[0m
[90mline 321 <<: [33m# educational purposes to demonstrate recursion with the Y combinator.[0m[0m
[90mline 322 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 323 <<: factRec    = Y (\f.\n. if (iszero n) 1 (mult n (f (pred n))))[0m
[32m-> factRec = <thunk:(Î»f.Î»n.if (iszero n) 1 (mult n (f (pred n)))) (Y (Î»f.Î»n.if (iszero n) 1 (mult n (f (pred n)))))>[0m
[0m [0m
[90mline 324 <<: fibRec     = Y (\f.\n. if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n)))))[0m
[32m-> fibRec = <thunk:(Î»f.Î»n.if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n))))) (Y (Î»f.Î»n.if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n))))))>[0m
[0m [0m
[90mline 325 <<: sumUptoRec = Y (\f.\n.if (iszero n) 0 (plus n (f (pred n))))[0m
[32m-> sumUptoRec = <thunk:(Î»f.Î»n.if (iszero n) false (plus n (f (pred n)))) (Y (Î»f.Î»n.if (iszero n) false (plus n (f (pred n)))))>[0m
[0m [0m
[90mline 326 <<: [0m
[90mline 327 <<: [0m
[90mline 328 <<: [33m# =============================================================================[0m[0m
[90mline 329 <<: [33m# SECTION 3: DATA STRUCTURES[0m[0m
[90mline 330 <<: [33m#[0m[0m
[90mline 331 <<: [33m# This section defines common data structures like pairs, lists, and trees,[0m[0m
[90mline 332 <<: [33m# along with a comprehensive suite of operations for each.[0m[0m
[0mPROGRESS::19[0m
[90mline 333 <<: [33m# =============================================================================[0m[0m
[90mline 334 <<: [0m
[90mline 335 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 336 <<: [33m# 3.1. Pairs[0m[0m
[90mline 337 <<: [33m#[0m[0m
[90mline 338 <<: [33m# Pairs are the fundamental data structure for combining two values in lambda calculus.[0m[0m
[90mline 339 <<: [33m# They are implemented using Church encoding where a pair is a function that takes[0m[0m
[90mline 340 <<: [33m# another function and applies it to the two stored values.[0m[0m
[90mline 341 <<: [33m#[0m[0m
[90mline 342 <<: [33m# ENCODING:[0m[0m
[90mline 343 <<: [33m#   pair x y = Î»f.f x y    (store x and y, apply function f to both)[0m[0m
[90mline 344 <<: [33m#   first p = p (Î»x y.x)   (apply pair to a function that selects first)[0m[0m
[90mline 345 <<: [33m#   second p = p (Î»x y.y)  (apply pair to a function that selects second)[0m[0m
[90mline 346 <<: [33m#[0m[0m
[90mline 347 <<: [33m# This encoding demonstrates the power of higher-order functions - data structures[0m[0m
[90mline 348 <<: [33m# become functions that can be manipulated through function application.[0m[0m
[90mline 349 <<: [33m#[0m[0m
[90mline 350 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 351 <<: [33m#   p = pair 10 20      # Create a pair containing 10 and 20[0m[0m
[90mline 352 <<: [33m#   first p             # Returns 10 (extract first element)[0m[0m
[90mline 353 <<: [33m#   second p            # Returns 20 (extract second element)[0m[0m
[90mline 354 <<: [33m#   swap p              # Returns pair 20 10 (swapped pair)[0m[0m
[90mline 355 <<: [33m#   pair 3 4 plus       # Returns 7 (apply plus to the pair elements)[0m[0m
[90mline 356 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 357 <<: pair     = Î»x y f.f x y[0m
[32m-> pair = Î»x.Î»y.Î»f.f x y[0m
[0m [0m
[90mline 358 <<: first    = Î»p.p (Î»x y.x)[0m
[32m-> first = Î»p.p (true)[0m
[0m [0m
[90mline 359 <<: second   = Î»p.p (Î»x y.y)[0m
[32m-> second = Î»p.p false[0m
[0m [0m
[90mline 360 <<: swap     = Î»p.Î»f.p (Î»x y.f y x)[0m
[32m-> swap = Î»p.Î»f.p (Î»x.Î»y.f y x)[0m
[0m [0m
[90mline 361 <<: [0m
[90mline 362 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 363 <<: [33m# 3.2. Lists - Core Operations[0m[0m
[90mline 364 <<: [33m#[0m[0m
[90mline 365 <<: [33m# Lists in lambda calculus are implemented using Church encoding with a cons/nil[0m[0m
[90mline 366 <<: [33m# structure similar to LISP. This encoding makes fold operations the natural way[0m[0m
[90mline 367 <<: [33m# to process lists, since the fold operation is built into the list structure itself.[0m[0m
[90mline 368 <<: [33m#[0m[0m
[90mline 369 <<: [33m# ENCODING:[0m[0m
[90mline 370 <<: [33m#   nil = Î»f z.z                    (empty list: return accumulator unchanged)[0m[0m
[90mline 371 <<: [33m#   cons x xs = Î»f z.f x (xs f z)   (prepend x: apply f to x and rest of list)[0m[0m
[90mline 372 <<: [33m#[0m[0m
[90mline 373 <<: [33m# The beauty of this encoding is that a list IS its own right fold function![0m[0m
[90mline 374 <<: [33m# When you call (list f z), you're performing foldr f z list.[0m[0m
[90mline 375 <<: [33m#[0m[0m
[90mline 376 <<: [33m# OPERATIONS:[0m[0m
[90mline 377 <<: [33m#   - isnil: Tests if list equals the nil function[0m[0m
[90mline 378 <<: [33m#   - head: Extracts first element using a selector function[0m[0m
[90mline 379 <<: [33m#   - tail: Complex operation using accumulator pairs to reconstruct list tail[0m[0m
[90mline 380 <<: [33m#[0m[0m
[90mline 381 <<: [33m# PERFORMANCE NOTES:[0m[0m
[90mline 382 <<: [33m#   - cons and head are O(1)[0m[0m
[90mline 383 <<: [33m#   - tail is O(n) due to the need to reconstruct the list[0m[0m
[90mline 384 <<: [33m#   - isnil is O(1) by testing list structure[0m[0m
[90mline 385 <<: [33m#[0m[0m
[90mline 386 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 387 <<: [33m#   l = cons 1 (cons 2 nil)     # Creates list [1, 2][0m[0m
[90mline 388 <<: [33m#   isnil nil                   # Returns true[0m[0m
[90mline 389 <<: [33m#   head l                      # Returns 1[0m[0m
[90mline 390 <<: [33m#   tail l                      # Returns [2] (the list containing just 2)[0m[0m
[90mline 391 <<: [33m#   isnil (tail (tail l))       # Returns true (tail of [2] is empty)[0m[0m
[90mline 392 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 393 <<: nil      = Î»f z.z[0m
[32m-> nil = false[0m
[0m [0m
[90mline 394 <<: cons     = Î»x xs f z.f x (xs f z)[0m
[32m-> cons = Î»x.Î»xs.Î»f.Î»z.f x (xs f z)[0m
[0m [0m
[90mline 395 <<: isnil    = Î»l.l (Î»x xs.false) true[0m
[32m-> isnil = Î»l.l (Î»x.Î»xs.false) true[0m
[0m [0m
[90mline 396 <<: head     = Î»l.l (Î»x xs.x) nil[0m
[32m-> head = Î»l.l (true) [][0m
[0m [0m
[90mline 397 <<: tail     = Î»l.first (l (Î»x p.pair (second p) (cons x (second p))) (pair nil nil))[0m
[32m-> tail = Î»l.first (l (Î»x.Î»p.pair (second p) (cons x (second p))) (pair [] []))[0m
[0m [0m
[90mline 398 <<: [33m# isempty  = isnil # Alias for isnil[0m[0m
[90mline 399 <<: [0m
[90mline 400 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 401 <<: [33m# 3.3. Lists - Higher-Order Functions[0m[0m
[90mline 402 <<: [33m#[0m[0m
[90mline 403 <<: [33m# These are the fundamental list processing functions in functional programming.[0m[0m
[90mline 404 <<: [33m# They operate on lists using higher-order functions (functions that take other[0m[0m
[90mline 405 <<: [33m# functions as arguments) to transform, filter, and aggregate data.[0m[0m
[90mline 406 <<: [33m#[0m[0m
[90mline 407 <<: [33m# The Church encoding of lists makes these operations natural:[0m[0m
[90mline 408 <<: [33m#   - map: Transform each element using function f[0m[0m
[90mline 409 <<: [33m#   - filter: Keep only elements satisfying predicate f[0m[0m
[90mline 410 <<: [33m#   - foldl: Left-associative fold ((((z op x1) op x2) op x3) ...)[0m[0m
[90mline 411 <<: [33m#   - foldr: Right-associative fold (x1 op (x2 op (x3 op ... z)))[0m[0m
[90mline 412 <<: [33m#[0m[0m
[90mline 413 <<: [33m# MATHEMATICAL FOUNDATION:[0m[0m
[90mline 414 <<: [33m#   These functions form a complete basis for list processing. Any list operation[0m[0m
[90mline 415 <<: [33m#   can be expressed in terms of these primitives, making them the building blocks[0m[0m
[90mline 416 <<: [33m#   of functional data processing.[0m[0m
[90mline 417 <<: [33m#[0m[0m
[90mline 418 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 419 <<: [33m#   map (mult 2) [1, 2, 3]      # Returns [2, 4, 6] (double each element)[0m[0m
[0mPROGRESS::24[0m
[90mline 420 <<: [33m#   filter even [1, 2, 3, 4]    # Returns [2, 4] (keep only even numbers)[0m[0m
[90mline 421 <<: [33m#   foldl plus 0 [1, 2, 3]      # Returns 6 (sum: ((0+1)+2)+3)[0m[0m
[90mline 422 <<: [33m#   foldr mult 1 [2, 3, 4]      # Returns 24 (product: 2*(3*(4*1)))[0m[0m
[90mline 423 <<: [33m#   foldr cons nil [1, 2, 3]    # Returns [1, 2, 3] (identity for lists)[0m[0m
[90mline 424 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 425 <<: map      = Î»f l.l (Î»x rest.cons (f x) rest) nil[0m
[32m-> map = Î»f.Î»l.l (Î»x.Î»rest.cons (f x) rest) [][0m
[0m [0m
[90mline 426 <<: filter   = Î»f l.l (Î»x rest.if (f x) (cons x rest) rest) nil[0m
[32m-> filter = Î»f.Î»l.l (Î»x.Î»rest.if (f x) (cons x rest) rest) [][0m
[0m [0m
[90mline 427 <<: [33m# NOTE: Original foldl was effectively a right-to-left fold (processing elements in reverse),[0m[0m
[90mline 428 <<: [33m# which made reverse become the identity. Correct left fold via CPS:[0m[0m
[90mline 429 <<: [33m# foldl f z [x1,x2,..,xn] = f (... (f (f z x1) x2) ...) xn[0m[0m
[90mline 430 <<: foldl    = Î»f z l.(l (Î»x k. Î»acc. k (f acc x)) (Î»acc.acc)) z[0m
[32m-> foldl = Î»f.Î»z.Î»l.l (Î»x.Î»k.Î»acc.k (f acc x)) (Î»acc.acc) z[0m
[0m [0m
[90mline 431 <<: foldr    = Î»f z l.l f z[0m
[32m-> foldr = Î»f.Î»z.Î»l.l f z[0m
[0m [0m
[90mline 432 <<: [0m
[90mline 433 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 434 <<: [33m# 3.4. Lists - Generation and Manipulation[0m[0m
[90mline 435 <<: [33m#[0m[0m
[90mline 436 <<: [33m# These functions provide essential list operations for building, combining,[0m[0m
[90mline 437 <<: [33m# and transforming lists. They build on the higher-order functions to provide[0m[0m
[90mline 438 <<: [33m# practical list manipulation capabilities.[0m[0m
[90mline 439 <<: [33m#[0m[0m
[90mline 440 <<: [33m# OPERATIONS:[0m[0m
[90mline 441 <<: [33m#   - append: Concatenates two lists using the foldr structure[0m[0m
[90mline 442 <<: [33m#   - reverse: Uses foldl to build reversed list by consing in opposite order[0m[0m
[90mline 443 <<: [33m#   - length: Counts elements by folding with successor function[0m[0m
[90mline 444 <<: [33m#   - take/drop: Extract prefix/suffix of specified length[0m[0m
[90mline 445 <<: [33m#   - range: Generates arithmetic sequences[0m[0m
[90mline 446 <<: [33m#   - enumeration: Creates lists of consecutive numbers[0m[0m
[90mline 447 <<: [33m#[0m[0m
[90mline 448 <<: [33m# COMPLEXITY ANALYSIS:[0m[0m
[90mline 449 <<: [33m#   - append: O(n) where n is length of first list[0m[0m
[90mline 450 <<: [33m#   - reverse: O(n) using foldl accumulation[0m[0m
[90mline 451 <<: [33m#   - length: O(n) by traversing entire list[0m[0m
[90mline 452 <<: [33m#   - take/drop: O(min(n, list_length))[0m[0m
[90mline 453 <<: [33m#   - range operations: O(n) where n is the count[0m[0m
[90mline 454 <<: [33m#[0m[0m
[90mline 455 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 456 <<: [33m#   append [1, 2] [3, 4]        # Returns [1, 2, 3, 4][0m[0m
[90mline 457 <<: [33m#   reverse [1, 2, 3]           # Returns [3, 2, 1][0m[0m
[90mline 458 <<: [33m#   length [1, 2, 3, 4, 5]      # Returns 5[0m[0m
[90mline 459 <<: [33m#   take 3 [1, 2, 3, 4, 5]      # Returns [1, 2, 3][0m[0m
[90mline 460 <<: [33m#   drop 2 [1, 2, 3, 4, 5]      # Returns [3, 4, 5][0m[0m
[90mline 461 <<: [33m#   range 5                     # Returns [0, 1, 2, 3, 4][0m[0m
[90mline 462 <<: [33m#   enumFromTo 3 7              # Returns [3, 4, 5, 6, 7][0m[0m
[90mline 463 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 464 <<: append   = Î»l1 l2.l1 cons l2[0m
[32m-> append = [cons][0m
[0m [0m
[90mline 465 <<: reverse  = Î»l.foldl (Î»acc x.cons x acc) nil l[0m
[32m-> reverse = Î»l.foldl (Î»acc.Î»x.cons x acc) [] l[0m
[0m [0m
[90mline 466 <<: length   = Î»l.foldr (Î»x acc.succ acc) zero l[0m
[32m-> length = Î»l.foldr (Î»x.Î»acc.succ acc) zero l[0m
[0m [0m
[90mline 467 <<: take     = Î»n l.n (Î»f prev.if (isnil prev) nil (cons (head prev) (f (tail prev)))) (Î»x.nil) l[0m
[32m-> take = Î»n.Î»l.n (Î»f.Î»prev.if (isnil prev) [] (cons (head prev) (f (tail prev)))) (Î»x.[]) l[0m
[0m [0m
[90mline 468 <<: drop     = Î»n l.n tail l[0m
[32m-> drop = [tail][0m
[0m [0m
[90mline 469 <<: concat   = Î»ll.foldr append nil ll[0m
[32m-> concat = Î»ll.foldr append [] ll[0m
[0m [0m
[90mline 470 <<: range    = Î»n. Y (Î»f k. if (eq k n) nil (cons k (f (succ k)))) 0[0m
[32m-> range = Î»n.Y (Î»f.Î»k.if (eq k n) [] (cons k (f (succ k)))) false[0m
[0m [0m
[90mline 471 <<: countdown = Î»n. Y (Î»f k. if (iszero k) (cons 0 nil) (cons k (f (pred k)))) n[0m
[32m-> countdown = Î»n.Y (Î»f.Î»k.if (iszero k) ([false]) (cons k (f (pred k)))) n[0m
[0m [0m
[90mline 472 <<: enumFromTo = Î»start end.map (plus start) (range (succ (minus end start)))[0m
[32m-> enumFromTo = Î»start.Î»end.map (plus start) (range (succ (minus end start)))[0m
[0m [0m
[90mline 473 <<: enumFrom   = Î»start n.map (plus start) (range n)[0m
[32m-> enumFrom = Î»start.Î»n.map (plus start) (range n)[0m
[0m [0m
[90mline 474 <<: primes     = Î»n.filter isPrime (enumFromTo 2 n)[0m
[32m-> primes = Î»n.filter isPrime (enumFromTo 2 n)[0m
[0m [0m
[90mline 475 <<: repeat     = Î»n x.n (Î»acc.cons x acc) nil[0m
[32m-> repeat = Î»n.Î»x.n (Î»acc.cons x acc) [][0m
[0m [0m
[90mline 476 <<: iota       = range [33m# Alias for range[0m[0m
[32m-> iota = Î»n.Y (Î»f.Î»k.if (eq k n) [] (cons k (f (succ k)))) false[0m
[0m [0m
[90mline 477 <<: replicate  = Î»n x.n (Î»acc.cons x acc) nil[0m
[32m-> replicate = Î»n.Î»x.n (Î»acc.cons x acc) [][0m
[0m [0m
[90mline 478 <<: [0m
[90mline 479 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 480 <<: [33m# 3.5. Lists - Element Access and Querying[0m[0m
[90mline 481 <<: [33m#[0m[0m
[90mline 482 <<: [33m# These functions provide ways to access specific elements and query properties[0m[0m
[90mline 483 <<: [33m# of lists. They demonstrate how higher-order functions can be used to implement[0m[0m
[90mline 484 <<: [33m# complex queries and searches over list structures.[0m[0m
[90mline 485 <<: [33m#[0m[0m
[90mline 486 <<: [33m# ELEMENT ACCESS:[0m[0m
[90mline 487 <<: [33m#   - nth: Random access to list elements (O(n) due to linear structure)[0m[0m
[90mline 488 <<: [33m#   - last/init: Access to end of list (requires full traversal)[0m[0m
[90mline 489 <<: [33m#   - elem/notElem: Membership testing using linear search[0m[0m
[90mline 490 <<: [33m#[0m[0m
[90mline 491 <<: [33m# PREDICATES AND AGGREGATIONS:[0m[0m
[90mline 492 <<: [33m#   - any/all: Universal and existential quantification over predicates[0m[0m
[90mline 493 <<: [33m#   - find: First element satisfying a condition[0m[0m
[90mline 494 <<: [33m#   - sum/product/max/min: Numeric aggregations using foldr[0m[0m
[90mline 495 <<: [33m#[0m[0m
[90mline 496 <<: [33m# PERFORMANCE NOTES:[0m[0m
[90mline 497 <<: [33m#   - nth, last, init are O(n) due to list traversal requirements[0m[0m
[90mline 498 <<: [33m#   - elem/notElem are O(n) worst case (linear search)[0m[0m
[90mline 499 <<: [33m#   - any/all can short-circuit in some lambda calculus implementations[0m[0m
[90mline 500 <<: [33m#   - sum/product/max/min are O(n) aggregations over entire list[0m[0m
[90mline 501 <<: [33m#[0m[0m
[90mline 502 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 503 <<: [33m#   nth 2 [10, 20, 30, 40]      # Returns 30 (0-indexed access)[0m[0m
[90mline 504 <<: [33m#   last [1, 2, 3, 4]           # Returns 4 (last element)[0m[0m
[90mline 505 <<: [33m#   init [1, 2, 3, 4]           # Returns [1, 2, 3] (all but last)[0m[0m
[90mline 506 <<: [33m#   elem 3 [1, 2, 3, 4]         # Returns true (3 is in the list)[0m[0m
[90mline 507 <<: [33m#   any even [1, 3, 4, 5]       # Returns true (4 is even)[0m[0m
[0mPROGRESS::29[0m
[90mline 508 <<: [33m#   all positive [1, 2, 3]      # Returns true (all elements > 0)[0m[0m
[90mline 509 <<: [33m#   find even [1, 3, 4, 5]      # Returns 4 (first even number)[0m[0m
[90mline 510 <<: [33m#   sum [1, 2, 3, 4]            # Returns 10 (1+2+3+4)[0m[0m
[90mline 511 <<: [33m#   maximum [3, 1, 4, 1, 5]     # Returns 5 (largest element)[0m[0m
[90mline 512 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 513 <<: nth      = Î»n l.head (drop n l)[0m
[32m-> nth = Î»n.Î»l.head (drop n l)[0m
[0m [0m
[90mline 514 <<: last     = Î»l.head (reverse l)[0m
[32m-> last = Î»l.head (reverse l)[0m
[0m [0m
[90mline 515 <<: init     = Î»l.reverse (tail (reverse l))[0m
[32m-> init = Î»l.reverse (tail (reverse l))[0m
[0m [0m
[90mline 516 <<: elem     = Î»x l.any (eq x) l[0m
[32m-> elem = Î»x.Î»l.any (eq x) l[0m
[0m [0m
[90mline 517 <<: notElem  = Î»x l.not (elem x l)[0m
[32m-> notElem = Î»x.Î»l.not (elem x l)[0m
[0m [0m
[90mline 518 <<: any      = Î»p l.foldr (Î»x acc.or (p x) acc) false l[0m
[32m-> any = Î»p.Î»l.foldr (Î»x.Î»acc.or (p x) acc) false l[0m
[0m [0m
[90mline 519 <<: all      = Î»p l.foldr (Î»x acc.and (p x) acc) true l[0m
[32m-> all = Î»p.Î»l.foldr (Î»x.Î»acc.and (p x) acc) true l[0m
[0m [0m
[90mline 520 <<: find     = Î»p l.foldl (Î»acc x.if (and (isnil acc) (p x)) x acc) nil l[0m
[32m-> find = Î»p.Î»l.foldl (Î»acc.Î»x.if (and (isnil acc) (p x)) x acc) [] l[0m
[0m [0m
[90mline 521 <<: sum      = Î»l.foldr plus zero l[0m
[32m-> sum = Î»l.foldr plus zero l[0m
[0m [0m
[90mline 522 <<: product  = Î»l.foldr mult 1 l[0m
[32m-> product = Î»l.foldr mult 1 l[0m
[0m [0m
[90mline 523 <<: maximum  = Î»l.foldr (Î»x acc.if (gt x acc) x acc) zero l[0m
[32m-> maximum = Î»l.foldr (Î»x.Î»acc.if (gt x acc) x acc) zero l[0m
[0m [0m
[90mline 524 <<: minimum  = Î»l.foldr (Î»x acc.if (lt x acc) x acc) (head l) (tail l)[0m
[32m-> minimum = Î»l.foldr (Î»x.Î»acc.if (lt x acc) x acc) (head l) (tail l)[0m
[0m [0m
[90mline 525 <<: [0m
[90mline 526 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 527 <<: [33m# 3.6. Lists - Advanced Utilities[0m[0m
[90mline 528 <<: [33m#[0m[0m
[90mline 529 <<: [33m# These sophisticated list operations combine multiple basic operations to provide[0m[0m
[90mline 530 <<: [33m# powerful data processing capabilities. They represent common patterns in[0m[0m
[90mline 531 <<: [33m# functional programming and demonstrate the composability of simple operations.[0m[0m
[90mline 532 <<: [33m#[0m[0m
[90mline 533 <<: [33m# COMBINING LISTS:[0m[0m
[90mline 534 <<: [33m#   - zip: Combines two lists element-wise into pairs[0m[0m
[90mline 535 <<: [33m#   - zipWith: Combines two lists using a binary function[0m[0m
[90mline 536 <<: [33m#   - unzip: Separates a list of pairs into two lists[0m[0m
[90mline 537 <<: [33m#[0m[0m
[90mline 538 <<: [33m# SCANNING AND ACCUMULATION:[0m[0m
[90mline 539 <<: [33m#   - scanl/scanr: Like fold, but returns all intermediate results[0m[0m
[90mline 540 <<: [33m#   - These show the step-by-step progression of an accumulation[0m[0m
[90mline 541 <<: [33m#[0m[0m
[90mline 542 <<: [33m# FILTERING AND PARTITIONING:[0m[0m
[90mline 543 <<: [33m#   - nub/unique: Remove duplicate elements (O(nÂ²) with linear search)[0m[0m
[90mline 544 <<: [33m#   - partition: Split list into elements satisfying/not satisfying predicate[0m[0m
[90mline 545 <<: [33m#[0m[0m
[90mline 546 <<: [33m# MATHEMATICAL FOUNDATION:[0m[0m
[90mline 547 <<: [33m#   These operations preserve important algebraic properties and can be[0m[0m
[90mline 548 <<: [33m#   composed to create complex data transformations while maintaining[0m[0m
[90mline 549 <<: [33m#   referential transparency.[0m[0m
[90mline 550 <<: [33m#[0m[0m
[90mline 551 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 552 <<: [33m#   zip [1, 2, 3] [a, b, c]         # Returns [(1,a), (2,b), (3,c)][0m[0m
[90mline 553 <<: [33m#   zipWith plus [1, 2] [3, 4]      # Returns [4, 6] (element-wise addition)[0m[0m
[90mline 554 <<: [33m#   scanl plus 0 [1, 2, 3]          # Returns [0, 1, 3, 6] (running sums)[0m[0m
[90mline 555 <<: [33m#   scanr mult 1 [2, 3, 4]          # Returns [24, 12, 4, 1] (running products)[0m[0m
[90mline 556 <<: [33m#   nub [1, 2, 2, 3, 1]             # Returns [3, 2, 1] (duplicates removed)[0m[0m
[90mline 557 <<: [33m#   partition even [1, 2, 3, 4]     # Returns ([2, 4], [1, 3]) (evens, odds)[0m[0m
[90mline 558 <<: [33m#   unzip [(1,a), (2,b)]            # Returns ([1, 2], [a, b]) (separate pairs)[0m[0m
[90mline 559 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 560 <<: zip     = Y (Î»zip l1 l2.if (or (isnil l1) (isnil l2)) nil (cons (pair (head l1) (head l2)) (zip (tail l1) (tail l2))))[0m
[32m-> zip = <thunk:(Î»zip.Î»l1.Î»l2.if (or (isnil l1) (isnil l2)) [] (cons (pair (head l1) (head l2)) (zip (tail l1) (tail l2)))) (Y (Î»zip.Î»l1.Î»l2.if (or (isnil l1) (isnil l2)) [] (cons (pair (head l1) (head l2)) (zip (tail l1) (tail l2)))))>[0m
[0m [0m
[90mline 561 <<: zipWith = Y (Î»zipWith f l1 l2.if (or (isnil l1) (isnil l2)) nil (cons (f (head l1) (head l2)) (zipWith f (tail l1) (tail l2))))[0m
[32m-> zipWith = <thunk:(Î»zipWith.Î»f.Î»l1.Î»l2.if (or (isnil l1) (isnil l2)) [] (cons (f (head l1) (head l2)) (zipWith f (tail l1) (tail l2)))) (Y (Î»zipWith.Î»f.Î»l1.Î»l2.if (or (isnil l1) (isnil l2)) [] (cons (f (head l1) (head l2)) (zipWith f (tail l1) (tail l2)))))>[0m
[0m [0m
[90mline 562 <<: scanl    = Î»f z l.reverse (foldl (Î»acc x.cons (f (head acc) x) acc) (cons z nil) l)[0m
[32m-> scanl = Î»f.Î»z.Î»l.reverse (foldl (Î»acc.Î»x.cons (f (head acc) x) acc) ([z]) l)[0m
[0m [0m
[90mline 563 <<: scanr    = Î»f z l.foldr (Î»x acc.cons (f x (head acc)) acc) (cons z nil) l[0m
[32m-> scanr = Î»f.Î»z.Î»l.foldr (Î»x.Î»acc.cons (f x (head acc)) acc) ([z]) l[0m
[0m [0m
[90mline 564 <<: unzip   = Î»l.pair (map first l) (map second l)[0m
[32m-> unzip = Î»l.pair (map first l) (map second l)[0m
[0m [0m
[90mline 565 <<: nub     = Î»l.foldl (Î»acc x.if (elem x acc) acc (cons x acc)) nil l[0m
[32m-> nub = Î»l.foldl (Î»acc.Î»x.if (elem x acc) acc (cons x acc)) [] l[0m
[0m [0m
[90mline 566 <<: unique = nub[0m
[32m-> unique = Î»l.foldl (Î»acc.Î»x.if (elem x acc) acc (cons x acc)) [] l[0m
[0m [0m
[90mline 567 <<: partition = Î»p l.pair (filter p l) (filter (Î»x.not (p x)) l)[0m
[32m-> partition = Î»p.Î»l.pair (filter p l) (filter (Î»x.not (p x)) l)[0m
[0m [0m
[90mline 568 <<: splitAt = Î»n l.pair (take n l) (drop n l)[0m
[32m-> splitAt = Î»n.Î»l.pair (take n l) (drop n l)[0m
[0m [0m
[90mline 569 <<: [0m
[90mline 570 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 571 <<: [33m# 3.7. Set Operations on Lists[0m[0m
[90mline 572 <<: [33m#[0m[0m
[90mline 573 <<: [33m# These operations treat lists as mathematical sets, focusing on membership[0m[0m
[90mline 574 <<: [33m# and set relationships rather than order or duplicates. Note that these[0m[0m
[90mline 575 <<: [33m# implementations are not optimized for large sets since they use linear search.[0m[0m
[90mline 576 <<: [33m#[0m[0m
[90mline 577 <<: [33m# SET OPERATIONS:[0m[0m
[90mline 578 <<: [33m#   - union: All elements that appear in either set[0m[0m
[90mline 579 <<: [33m#   - intersect: Elements that appear in both sets[0m[0m
[90mline 580 <<: [33m#   - difference: Elements in first set but not in second[0m[0m
[90mline 581 <<: [33m#   - isSubset/isSuperset: Test containment relationships[0m[0m
[90mline 582 <<: [33m#[0m[0m
[90mline 583 <<: [33m# COMPLEXITY: All operations are O(nÃ—m) where n and m are the list lengths,[0m[0m
[90mline 584 <<: [33m# due to the use of linear membership testing.[0m[0m
[90mline 585 <<: [33m#[0m[0m
[90mline 586 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 587 <<: [33m#   union [1, 2] [2, 3, 4]          # Returns [1, 2, 3, 4] (all elements)[0m[0m
[90mline 588 <<: [33m#   intersect [1, 2, 3] [2, 3, 4]   # Returns [2, 3] (common elements)[0m[0m
[90mline 589 <<: [33m#   difference [1, 2, 3] [2, 4]     # Returns [1, 3] (in first, not second)[0m[0m
[90mline 590 <<: [33m#   isSubset [1, 2] [1, 2, 3]       # Returns true ([1,2] âŠ† [1,2,3])[0m[0m
[90mline 591 <<: [33m#   isSuperset [1, 2, 3] [1, 2]     # Returns true ([1,2,3] âŠ‡ [1,2])[0m[0m
[90mline 592 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 593 <<: union      = Î»l1 l2.append l1 (filter (Î»x.notElem x l1) l2)[0m
[32m-> union = Î»l1.Î»l2.append l1 (filter (Î»x.notElem x l1) l2)[0m
[0m [0m
[90mline 594 <<: intersect  = Î»l1 l2.filter (Î»x.elem x l2) l1[0m
[32m-> intersect = Î»l1.Î»l2.filter (Î»x.elem x l2) l1[0m
[0m [0m
[0mPROGRESS::34[0m
[90mline 595 <<: difference = Î»l1 l2.filter (Î»x.notElem x l2) l1[0m
[32m-> difference = Î»l1.Î»l2.filter (Î»x.notElem x l2) l1[0m
[0m [0m
[90mline 596 <<: isSubset   = Î»l1 l2.all (Î»x.elem x l2) l1[0m
[32m-> isSubset = Î»l1.Î»l2.all (Î»x.elem x l2) l1[0m
[0m [0m
[90mline 597 <<: isSuperset = Î»l1 l2.isSubset l2 l1[0m
[32m-> isSuperset = Î»l1.Î»l2.isSubset l2 l1[0m
[0m [0m
[90mline 598 <<: [0m
[90mline 599 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 600 <<: [33m# 3.8. Tree Data Structures (Binary Trees)[0m[0m
[90mline 601 <<: [33m#[0m[0m
[90mline 602 <<: [33m# A basic implementation of binary trees using Church encoding. Trees are[0m[0m
[90mline 603 <<: [33m# represented as pairs where the first element is the value and the second[0m[0m
[90mline 604 <<: [33m# element is a pair of (left_subtree, right_subtree).[0m[0m
[90mline 605 <<: [33m#[0m[0m
[90mline 606 <<: [33m# ENCODING:[0m[0m
[90mline 607 <<: [33m#   leaf v = (v, (nil, nil))        - A leaf node with value v and no children[0m[0m
[90mline 608 <<: [33m#   node v l r = (v, (l, r))        - Internal node with value v and subtrees l, r[0m[0m
[90mline 609 <<: [33m#[0m[0m
[90mline 610 <<: [33m# TREE OPERATIONS:[0m[0m
[90mline 611 <<: [33m#   - Accessor functions: treeValue, treeLeft, treeRight[0m[0m
[90mline 612 <<: [33m#   - Predicate: isLeaf (checks if both subtrees are nil)[0m[0m
[90mline 613 <<: [33m#   - Traversals: inOrder, preOrder, postOrder (visit nodes in different orders)[0m[0m
[90mline 614 <<: [33m#   - Metrics: treeSize (count nodes), treeDepth (maximum path length)[0m[0m
[90mline 615 <<: [33m#[0m[0m
[90mline 616 <<: [33m# PERFORMANCE WARNING:[0m[0m
[90mline 617 <<: [33m#   Keep trees small to avoid deep recursion that might cause stack overflow.[0m[0m
[90mline 618 <<: [33m#   These implementations use explicit recursion which can be expensive.[0m[0m
[90mline 619 <<: [33m#[0m[0m
[90mline 620 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 621 <<: [33m#   tree = node 5 (leaf 3) (leaf 7)     # Binary tree: 3 <- 5 -> 7[0m[0m
[90mline 622 <<: [33m#   treeValue tree                       # Returns 5 (root value)[0m[0m
[90mline 623 <<: [33m#   treeLeft tree                        # Returns leaf 3 (left subtree)[0m[0m
[90mline 624 <<: [33m#   isLeaf (treeLeft tree)               # Returns true (leaf 3 has no children)[0m[0m
[90mline 625 <<: [33m#   inOrder tree                         # Returns [3, 5, 7] (left-root-right)[0m[0m
[90mline 626 <<: [33m#   preOrder tree                        # Returns [5, 3, 7] (root-left-right)[0m[0m
[90mline 627 <<: [33m#   treeSize tree                        # Returns 3 (total nodes)[0m[0m
[90mline 628 <<: [33m#   treeDepth tree                       # Returns 2 (maximum depth)[0m[0m
[90mline 629 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 630 <<: leaf      = Î»v.pair v (pair nil nil)[0m
[32m-> leaf = Î»v.pair v (pair [] [])[0m
[0m [0m
[90mline 631 <<: node      = Î»v l r.pair v (pair l r)[0m
[32m-> node = Î»v.Î»l.Î»r.pair v (pair l r)[0m
[0m [0m
[90mline 632 <<: treeValue = first[0m
[32m-> treeValue = Î»p.p (true)[0m
[0m [0m
[90mline 633 <<: treeLeft  = Î»t.first (second t)[0m
[32m-> treeLeft = Î»t.first (second t)[0m
[0m [0m
[90mline 634 <<: treeRight = Î»t.second (second t)[0m
[32m-> treeRight = Î»t.second (second t)[0m
[0m [0m
[90mline 635 <<: isLeaf    = Î»t.and (isnil (treeLeft t)) (isnil (treeRight t))[0m
[32m-> isLeaf = Î»t.and (isnil (treeLeft t)) (isnil (treeRight t))[0m
[0m [0m
[90mline 636 <<: [33m# Simplified traversals to avoid recursion[0m[0m
[90mline 637 <<: inOrder   = Y (Î»f t.if (isnil t) nil (append (f (treeLeft t)) (cons (treeValue t) (f (treeRight t)))))[0m
[32m-> inOrder = <thunk:(Î»f.Î»t.if (isnil t) [] (append (f (treeLeft t)) (cons (treeValue t) (f (treeRight t))))) (Y (Î»f.Î»t.if (isnil t) [] (append (f (treeLeft t)) (cons (treeValue t) (f (treeRight t))))))>[0m
[0m [0m
[90mline 638 <<: preOrder  = Y (Î»f t.if (isnil t) nil (cons (treeValue t) (append (f (treeLeft t)) (f (treeRight t)))))[0m
[32m-> preOrder = <thunk:(Î»f.Î»t.if (isnil t) [] (cons (treeValue t) (append (f (treeLeft t)) (f (treeRight t))))) (Y (Î»f.Î»t.if (isnil t) [] (cons (treeValue t) (append (f (treeLeft t)) (f (treeRight t))))))>[0m
[0m [0m
[90mline 639 <<: postOrder = Y (Î»f t.if (isnil t) nil (append (f (treeLeft t)) (append (f (treeRight t)) (cons (treeValue t) nil))))[0m
[32m-> postOrder = <thunk:(Î»f.Î»t.if (isnil t) [] (append (f (treeLeft t)) (append (f (treeRight t)) ([treeValue t])))) (Y (Î»f.Î»t.if (isnil t) [] (append (f (treeLeft t)) (append (f (treeRight t)) ([treeValue t])))))>[0m
[0m [0m
[90mline 640 <<: [0m
[90mline 641 <<: treeSize  = Î»t.if (isnil t) 0 (succ (plus (treeSize (treeLeft t)) (treeSize (treeRight t))))[0m
[32m-> treeSize = Î»t.if (isnil t) false (succ (plus (treeSize (treeLeft t)) (treeSize (treeRight t))))[0m
[0m [0m
[90mline 642 <<: treeDepth = Î»t.if (isnil t) 0 (succ (max (treeDepth (treeLeft t)) (treeDepth (treeRight t))))[0m
[32m-> treeDepth = Î»t.if (isnil t) false (succ (max (treeDepth (treeLeft t)) (treeDepth (treeRight t))))[0m
[0m [0m
[90mline 643 <<: [0m
[90mline 644 <<: [0m
[90mline 645 <<: [33m# =============================================================================[0m[0m
[90mline 646 <<: [33m# SECTION 4: FUNCTIONAL PROGRAMMING UTILITIES[0m[0m
[90mline 647 <<: [33m#[0m[0m
[90mline 648 <<: [33m# This section provides higher-order functions, combinators, and utilities[0m[0m
[90mline 649 <<: [33m# that are common in functional programming. These build on the basic[0m[0m
[90mline 650 <<: [33m# combinators to provide more sophisticated function manipulation capabilities.[0m[0m
[90mline 651 <<: [33m# =============================================================================[0m[0m
[90mline 652 <<: [0m
[90mline 653 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 654 <<: [33m# 4.1. Function Composition and Application[0m[0m
[90mline 655 <<: [33m#[0m[0m
[90mline 656 <<: [33m# These fundamental operations form the backbone of functional programming style.[0m[0m
[90mline 657 <<: [33m# They allow building complex functions from simpler ones through composition[0m[0m
[90mline 658 <<: [33m# and provide various ways to apply functions to arguments.[0m[0m
[90mline 659 <<: [33m#[0m[0m
[90mline 660 <<: [33m# COMPOSITION THEORY:[0m[0m
[90mline 661 <<: [33m#   Function composition (âˆ˜) is associative: (f âˆ˜ g) âˆ˜ h = f âˆ˜ (g âˆ˜ h)[0m[0m
[90mline 662 <<: [33m#   This allows building complex transformations from simple building blocks.[0m[0m
[90mline 663 <<: [33m#[0m[0m
[90mline 664 <<: [33m# APPLICATION PATTERNS:[0m[0m
[90mline 665 <<: [33m#   - apply: Explicit function application (mostly for clarity)[0m[0m
[90mline 666 <<: [33m#   - compose: Creates new functions by chaining operations[0m[0m
[90mline 667 <<: [33m#   - flip: Changes argument order for partial application[0m[0m
[90mline 668 <<: [33m#   - on: Applies a binary operation to the results of a unary function[0m[0m
[90mline 669 <<: [33m#   - iterate: Repeated function application[0m[0m
[90mline 670 <<: [33m#   - times: Point-free style repeated application[0m[0m
[90mline 671 <<: [33m#[0m[0m
[90mline 672 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 673 <<: [33m#   (compose succ double) 5      # Returns 11 (succ(double(5)) = succ(10) = 11)[0m[0m
[90mline 674 <<: [33m#   flip minus 3 10             # Returns 7 (minus 10 3 = 7, arguments flipped)[0m[0m
[90mline 675 <<: [33m#   iterate succ 3 0            # Returns 3 (apply succ three times: 0â†’1â†’2â†’3)[0m[0m
[90mline 676 <<: [33m#   on plus double 3 4          # Returns 14 (plus(double(3), double(4)) = 6+8)[0m[0m
[90mline 677 <<: [33m#   times 5 succ 0              # Returns 5 (apply succ five times to 0)[0m[0m
[90mline 678 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 679 <<: apply    = Î»f x.f x[0m
[32m-> apply = 1[0m
[0m [0m
[90mline 680 <<: compose  = B[0m
[32m-> compose = Î»x.Î»y.Î»z.x (y z)[0m
[0m [0m
[90mline 681 <<: flip     = C[0m
[32m-> flip = Î»x.Î»y.Î»z.x z y[0m
[0m [0m
[90mline 682 <<: on       = Î»op f x y.op (f x) (f y)[0m
[32m-> on = Î»op.Î»f.Î»x.Î»y.op (f x) (f y)[0m
[0m [0m
[0mPROGRESS::39[0m
[90mline 683 <<: iterate  = Î»f n x.n f x[0m
[32m-> iterate = Î»f.[f][0m
[0m [0m
[90mline 684 <<: times    = Î»n.Î»f.Î»x.n f x[0m
[32m-> times = Î»n.Î»f.Î»x.n f x[0m
[0m [0m
[90mline 685 <<: [0m
[90mline 686 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 687 <<: [33m# 4.2. Currying and Partial Application[0m[0m
[90mline 688 <<: [33m#[0m[0m
[90mline 689 <<: [33m# These functions manipulate function arity and argument application patterns.[0m[0m
[90mline 690 <<: [33m# Currying transforms functions to take arguments one at a time, while partial[0m[0m
[90mline 691 <<: [33m# application fixes some arguments to create specialized functions.[0m[0m
[90mline 692 <<: [33m#[0m[0m
[90mline 693 <<: [33m# MATHEMATICAL FOUNDATION:[0m[0m
[90mline 694 <<: [33m#   Currying establishes an isomorphism between:[0m[0m
[90mline 695 <<: [33m#   - Functions of type (A Ã— B) â†’ C[0m[0m
[90mline 696 <<: [33m#   - Functions of type A â†’ (B â†’ C)[0m[0m
[90mline 697 <<: [33m#   This allows treating multi-argument functions as chains of single-argument functions.[0m[0m
[90mline 698 <<: [33m#[0m[0m
[90mline 699 <<: [33m# PRACTICAL APPLICATIONS:[0m[0m
[90mline 700 <<: [33m#   - curry: Converts pair-taking functions to curried form[0m[0m
[90mline 701 <<: [33m#   - uncurry: Converts curried functions to pair-taking form[0m[0m
[90mline 702 <<: [33m#   - partial: Creates specialized functions by fixing arguments[0m[0m
[90mline 703 <<: [33m#   - partial2: Fixes first two arguments of a three-argument function[0m[0m
[90mline 704 <<: [33m#[0m[0m
[90mline 705 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 706 <<: [33m#   add_pair = Î»p.plus (first p) (second p)  # Function taking a pair[0m[0m
[90mline 707 <<: [33m#   add_curried = curry add_pair              # Now takes two separate arguments[0m[0m
[90mline 708 <<: [33m#   add_curried 3 4                          # Returns 7[0m[0m
[90mline 709 <<: [33m#   [0m[0m
[90mline 710 <<: [33m#   add5 = partial plus 5                    # Function that adds 5[0m[0m
[90mline 711 <<: [33m#   add5 10                                  # Returns 15[0m[0m
[90mline 712 <<: [33m#   [0m[0m
[90mline 713 <<: [33m#   mult_with_pair = uncurry mult            # Takes pair instead of two args[0m[0m
[90mline 714 <<: [33m#   mult_with_pair (pair 3 4)                # Returns 12[0m[0m
[90mline 715 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 716 <<: curry    = Î»f x y.f (pair x y)[0m
[32m-> curry = Î»f.Î»x.Î»y.f (pair x y)[0m
[0m [0m
[90mline 717 <<: uncurry  = Î»f p.f (first p) (second p)[0m
[32m-> uncurry = Î»f.Î»p.f (first p) (second p)[0m
[0m [0m
[90mline 718 <<: partial  = Î»f x.Î»y.f x y[0m
[32m-> partial = Î»f.Î»x.Î»y.f x y[0m
[0m [0m
[90mline 719 <<: partial2 = Î»f x y.Î»z.f x y z[0m
[32m-> partial2 = Î»f.Î»x.Î»y.Î»z.f x y z[0m
[0m [0m
[90mline 720 <<: [33m# 3-arity curry helpers used in tests[0m[0m
[90mline 721 <<: curry3   = Î»f x y z.f (pair x (pair y z))[0m
[32m-> curry3 = Î»f.Î»x.Î»y.Î»z.f (pair x (pair y z))[0m
[0m [0m
[90mline 722 <<: uncurry3 = Î»f p.f (first p) (first (second p)) (second (second p))[0m
[32m-> uncurry3 = Î»f.Î»p.f (first p) (first (second p)) (second (second p))[0m
[0m [0m
[90mline 723 <<: [0m
[90mline 724 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 725 <<: [33m# 4.3. Additional Combinators[0m[0m
[90mline 726 <<: [33m#[0m[0m
[90mline 727 <<: [33m# These are classic combinators from combinatory logic, many with bird names[0m[0m
[90mline 728 <<: [33m# from Raymond Smullyan's "To Mock a Mockingbird". They provide alternative[0m[0m
[90mline 729 <<: [33m# ways to express common functional programming patterns.[0m[0m
[90mline 730 <<: [33m#[0m[0m
[90mline 731 <<: [33m# BIRD NAMES AND THEIR MEANINGS:[0m[0m
[90mline 732 <<: [33m#   - Mockingbird (Ï‰): Self-application, foundation of recursion[0m[0m
[90mline 733 <<: [33m#   - Thrush (T): Reverse application, useful for data flow[0m[0m
[90mline 734 <<: [33m#   - Cardinal (C): Argument flipping, enables partial application patterns[0m[0m
[90mline 735 <<: [33m#   - Bluebird (B): Function composition, building complex functions[0m[0m
[90mline 736 <<: [33m#   - Kestrel (K): Constant functions, basis for conditional logic[0m[0m
[90mline 737 <<: [33m#   - Warbler (W): Duplication combinator, applies function to same argument twice[0m[0m
[90mline 738 <<: [33m#   - Starling (S): Most powerful combinator, can express any computable function[0m[0m
[90mline 739 <<: [33m#[0m[0m
[90mline 740 <<: [33m# THEORETICAL IMPORTANCE:[0m[0m
[90mline 741 <<: [33m#   These combinators form a complete basis for computation - any computable[0m[0m
[90mline 742 <<: [33m#   function can be expressed using just S and K combinators.[0m[0m
[90mline 743 <<: [33m#[0m[0m
[90mline 744 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 745 <<: [33m#   omega plus                   # Returns plus plus (self-application)[0m[0m
[90mline 746 <<: [33m#   thrush 42 succ               # Returns 43 (apply succ to 42)[0m[0m
[90mline 747 <<: [33m#   warbler plus 5               # Returns 10 (plus 5 5)[0m[0m
[90mline 748 <<: [33m#   cardinal minus 3 10          # Returns 7 (minus with flipped arguments)[0m[0m
[90mline 749 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 750 <<: const    = K[0m
[32m-> const = K[0m
[0m [0m
[90mline 751 <<: omega    = Î»x.x x[0m
[32m-> omega = Î»x.x x[0m
[0m [0m
[90mline 752 <<: mockingbird = omega[0m
[32m-> mockingbird = Î»x.x x[0m
[0m [0m
[90mline 753 <<: thrush   = Î»x f.f x[0m
[32m-> thrush = Î»x.Î»f.f x[0m
[0m [0m
[90mline 754 <<: cardinal = flip[0m
[32m-> cardinal = Î»x.Î»y.Î»z.x z y[0m
[0m [0m
[90mline 755 <<: bluebird = compose[0m
[32m-> bluebird = Î»x.Î»y.Î»z.x (y z)[0m
[0m [0m
[90mline 756 <<: kestrel  = const[0m
[32m-> kestrel = K[0m
[0m [0m
[90mline 757 <<: warbler  = Î»f x.f x x[0m
[32m-> warbler = [x][0m
[0m [0m
[90mline 758 <<: starling = S[0m
[32m-> starling = Î»x.Î»y.Î»z.x z (y z)[0m
[0m [0m
[90mline 759 <<: [0m
[90mline 760 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 761 <<: [33m# 4.4. Looping Constructs[0m[0m
[90mline 762 <<: [33m#[0m[0m
[90mline 763 <<: [33m# These combinators provide imperative-style looping in a purely functional way.[0m[0m
[90mline 764 <<: [33m# The WHILE combinator demonstrates how iteration can be expressed through[0m[0m
[90mline 765 <<: [33m# recursion and conditional application.[0m[0m
[90mline 766 <<: [33m#[0m[0m
[90mline 767 <<: [33m# WHILE LOOP SEMANTICS:[0m[0m
[90mline 768 <<: [33m#   WHILE condition body state repeatedly applies body to state while[0m[0m
[90mline 769 <<: [33m#   condition(state) returns true. This provides familiar iterative patterns[0m[0m
[0mPROGRESS::44[0m
[90mline 770 <<: [33m#   within the pure functional paradigm.[0m[0m
[90mline 771 <<: [33m#[0m[0m
[90mline 772 <<: [33m# IMPLEMENTATION STRATEGY:[0m[0m
[90mline 773 <<: [33m#   Uses the Y combinator for recursion with conditional termination.[0m[0m
[90mline 774 <<: [33m#   The loop continues by recursively calling itself with the updated state,[0m[0m
[90mline 775 <<: [33m#   or terminates by returning the final state.[0m[0m
[90mline 776 <<: [33m#[0m[0m
[90mline 777 <<: [33m# SAFETY WARNING:[0m[0m
[90mline 778 <<: [33m#   Infinite loops are possible if the condition never becomes false![0m[0m
[90mline 779 <<: [33m#   Always ensure the body function eventually leads to condition failure.[0m[0m
[90mline 780 <<: [33m#[0m[0m
[90mline 781 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 782 <<: [33m#   # Count down from 5 to 0[0m[0m
[90mline 783 <<: [33m#   countdown_from_5 = WHILE (Î»n.gt n 0) pred 5    # Returns 0[0m[0m
[90mline 784 <<: [33m#   [0m[0m
[90mline 785 <<: [33m#   # Alternative GCD implementation using WHILE[0m[0m
[90mline 786 <<: [33m#   gcd1 12 8                                      # Returns 4[0m[0m
[90mline 787 <<: [33m#   [0m[0m
[90mline 788 <<: [33m#   # Custom iteration: multiply by 2 until > 100[0m[0m
[90mline 789 <<: [33m#   grow = WHILE (Î»n.leq n 100) (mult 2) 1         # Returns 128[0m[0m
[90mline 790 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 791 <<: [33m# A general-purpose WHILE loop combinator[0m[0m
[90mline 792 <<: WHILE = Y (Î»loop. Î»cond body state. if (cond state) (loop cond body (body state)) state)[0m
[32m-> WHILE = <thunk:(Î»loop.Î»cond.Î»body.Î»state.if (cond state) (loop cond body (body state)) state) (Y (Î»loop.Î»cond.Î»body.Î»state.if (cond state) (loop cond body (body state)) state))>[0m
[0m [0m
[90mline 793 <<: [0m
[90mline 794 <<: [33m# Example of using WHILE for GCD (less efficient than the recursive version)[0m[0m
[90mline 795 <<: GCD_STEP = Î»p. if (gt (first p) (second p)) \[0m
[90mline 796 <<:                  (pair (minus (first p) (second p)) (second p)) \[0m
[90mline 797 <<:                  (pair (first p) (minus (second p) (first p)))[0m
[32m-> GCD_STEP = Î»p.if (gt (first p) (second p)) (pair (minus (first p) (second p)) (second p)) (pair (first p) (minus (second p) (first p)))[0m
[0m [0m
[90mline 798 <<: gcd1 = Î»m n. if (or (iszero m) (iszero n)) (if (iszero m) n m) \[0m
[90mline 799 <<:     (first (WHILE (Î»p. neq (first p) (second p)) GCD_STEP (pair m n)))[0m
[32m-> gcd1 = Î»m.Î»n.if (or (iszero m) (iszero n)) (if (iszero m) n m) (first (WHILE (Î»p.neq (first p) (second p)) GCD_STEP (pair m n)))[0m
[0m [0m
[90mline 800 <<: [0m
[90mline 801 <<: [0m
[90mline 802 <<: [33m# =============================================================================[0m[0m
[90mline 803 <<: [33m# SECTION 5: ALGEBRAIC DATA TYPES[0m[0m
[90mline 804 <<: [33m#[0m[0m
[90mline 805 <<: [33m# This section defines common algebraic data types like Maybe (Optional) and[0m[0m
[90mline 806 <<: [33m# Either, which are useful for handling computations that can fail or have[0m[0m
[90mline 807 <<: [33m# alternative results.[0m[0m
[90mline 808 <<: [33m# =============================================================================[0m[0m
[90mline 809 <<: [0m
[90mline 810 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 811 <<: [33m# 5.1. Maybe (Optional) Type[0m[0m
[90mline 812 <<: [33m#[0m[0m
[90mline 813 <<: [33m# The Maybe type is a foundational algebraic data type that safely represents[0m[0m
[90mline 814 <<: [33m# the presence or absence of a value. This eliminates the need for null[0m[0m
[90mline 815 <<: [33m# references and provides a principled way to handle optional values.[0m[0m
[90mline 816 <<: [33m#[0m[0m
[90mline 817 <<: [33m# ENCODING:[0m[0m
[90mline 818 <<: [33m#   nothing = nil                   # Represents absence of value[0m[0m
[90mline 819 <<: [33m#   just x = pair true x           # Represents presence of value x[0m[0m
[90mline 820 <<: [33m#[0m[0m
[90mline 821 <<: [33m# TYPE THEORY:[0m[0m
[90mline 822 <<: [33m#   Maybe A = Nothing | Just A[0m[0m
[90mline 823 <<: [33m#   This creates a sum type that extends any type A with a "null" value.[0m[0m
[90mline 824 <<: [33m#   The encoding uses Church pairs where the first element indicates presence.[0m[0m
[90mline 825 <<: [33m#[0m[0m
[90mline 826 <<: [33m# SAFETY BENEFITS:[0m[0m
[90mline 827 <<: [33m#   - No null pointer exceptions or undefined behavior[0m[0m
[90mline 828 <<: [33m#   - Explicit handling of absent values in the type system[0m[0m
[90mline 829 <<: [33m#   - Compositional operations that preserve safety[0m[0m
[90mline 830 <<: [33m#[0m[0m
[90mline 831 <<: [33m# FUNCTIONAL PATTERNS:[0m[0m
[90mline 832 <<: [33m#   - maybe: Eliminates the Maybe with a default and transformation function[0m[0m
[90mline 833 <<: [33m#   - maybeMap: Applies a function only if value is present (functor law)[0m[0m
[90mline 834 <<: [33m#   - Chaining: Sequence operations that might fail[0m[0m
[90mline 835 <<: [33m#[0m[0m
[90mline 836 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 837 <<: [33m#   value1 = just 42              # Contains the value 42[0m[0m
[90mline 838 <<: [33m#   value2 = nothing              # Contains no value[0m[0m
[90mline 839 <<: [33m#   [0m[0m
[90mline 840 <<: [33m#   fromMaybe 0 value1            # Returns 42[0m[0m
[90mline 841 <<: [33m#   fromMaybe 0 value2            # Returns 0 (default)[0m[0m
[90mline 842 <<: [33m#   [0m[0m
[90mline 843 <<: [33m#   maybe "empty" show value1     # Returns "42" (converted to string)[0m[0m
[90mline 844 <<: [33m#   maybe "empty" show value2     # Returns "empty"[0m[0m
[90mline 845 <<: [33m#   [0m[0m
[90mline 846 <<: [33m#   maybeMap (mult 2) value1      # Returns just 84[0m[0m
[90mline 847 <<: [33m#   maybeMap (mult 2) value2      # Returns nothing[0m[0m
[90mline 848 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 849 <<: nothing   = nil[0m
[32m-> nothing = false[0m
[0m [0m
[90mline 850 <<: just      = Î»x.pair true x[0m
[32m-> just = Î»x.pair true x[0m
[0m [0m
[90mline 851 <<: isNothing = isnil[0m
[32m-> isNothing = Î»l.l (Î»x.Î»xs.false) true[0m
[0m [0m
[90mline 852 <<: isJust    = Î»m.not (isNothing m)[0m
[32m-> isJust = Î»m.not (isNothing m)[0m
[0m [0m
[90mline 853 <<: fromJust  = second[0m
[32m-> fromJust = Î»p.p false[0m
[0m [0m
[90mline 854 <<: maybe     = Î»def f m.if (isNothing m) def (f (fromJust m))[0m
[32m-> maybe = Î»def.Î»f.Î»m.if (isNothing m) def (f (fromJust m))[0m
[0m [0m
[90mline 855 <<: fromMaybe = Î»def m.if (isNothing m) def (fromJust m)[0m
[32m-> fromMaybe = Î»def.Î»m.if (isNothing m) def (fromJust m)[0m
[0m [0m
[90mline 856 <<: [0m
[90mline 857 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[0mPROGRESS::49[0m
[90mline 858 <<: [33m# 5.2. Either Type[0m[0m
[90mline 859 <<: [33m#[0m[0m
[90mline 860 <<: [33m# The Either type represents a value that can be one of two types, commonly[0m[0m
[90mline 861 <<: [33m# used for error handling where Left contains an error and Right contains[0m[0m
[90mline 862 <<: [33m# a successful result. This provides structured error handling without exceptions.[0m[0m
[90mline 863 <<: [33m#[0m[0m
[90mline 864 <<: [33m# ENCODING:[0m[0m
[90mline 865 <<: [33m#   left x = pair false x         # Left value (typically error)[0m[0m
[90mline 866 <<: [33m#   right x = pair true x         # Right value (typically success)[0m[0m
[90mline 867 <<: [33m#[0m[0m
[90mline 868 <<: [33m# ERROR HANDLING PATTERN:[0m[0m
[90mline 869 <<: [33m#   Either Error Success[0m[0m
[90mline 870 <<: [33m#   - Left contains error information[0m[0m
[90mline 871 <<: [33m#   - Right contains successful computation result[0m[0m
[90mline 872 <<: [33m#   - Operations can be chained, short-circuiting on first error[0m[0m
[90mline 873 <<: [33m#[0m[0m
[90mline 874 <<: [33m# BIAS TOWARDS RIGHT:[0m[0m
[90mline 875 <<: [33m#   By convention, Either is "right-biased" - operations like map apply[0m[0m
[90mline 876 <<: [33m#   to Right values and preserve Left values unchanged.[0m[0m
[90mline 877 <<: [33m#[0m[0m
[90mline 878 <<: [33m# COMPARISON WITH MAYBE:[0m[0m
[90mline 879 <<: [33m#   Maybe: Presence/absence with no error information[0m[0m
[90mline 880 <<: [33m#   Either: Choice between two values, with error context[0m[0m
[90mline 881 <<: [33m#[0m[0m
[90mline 882 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 883 <<: [33m#   success = right 42            # Successful computation[0m[0m
[90mline 884 <<: [33m#   error = left "division by zero"  # Error with message[0m[0m
[90mline 885 <<: [33m#   [0m[0m
[90mline 886 <<: [33m#   either show id success        # Returns 42 (right side)[0m[0m
[90mline 887 <<: [33m#   either show id error          # Returns "division by zero" (left side)[0m[0m
[90mline 888 <<: [33m#   [0m[0m
[90mline 889 <<: [33m#   # Error handling in division[0m[0m
[90mline 890 <<: [33m#   divide = Î»a b.if (iszero b) (left "divide by zero") (right (div a b))[0m[0m
[90mline 891 <<: [33m#   divide 10 2                   # Returns right 5[0m[0m
[90mline 892 <<: [33m#   divide 10 0                   # Returns left "divide by zero"[0m[0m
[90mline 893 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 894 <<: left      = Î»x.pair false x[0m
[32m-> left = Î»x.pair false x[0m
[0m [0m
[90mline 895 <<: right     = Î»x.pair true x[0m
[32m-> right = Î»x.pair true x[0m
[0m [0m
[90mline 896 <<: isLeft    = Î»e.not (first e)[0m
[32m-> isLeft = Î»e.not (first e)[0m
[0m [0m
[90mline 897 <<: isRight   = first[0m
[32m-> isRight = Î»p.p (true)[0m
[0m [0m
[90mline 898 <<: fromLeft  = second[0m
[32m-> fromLeft = Î»p.p false[0m
[0m [0m
[90mline 899 <<: fromRight = second[0m
[32m-> fromRight = Î»p.p false[0m
[0m [0m
[90mline 900 <<: either    = Î»f g e.if (isLeft e) (f (fromLeft e)) (g (fromRight e))[0m
[32m-> either = Î»f.Î»g.Î»e.if (isLeft e) (f (fromLeft e)) (g (fromRight e))[0m
[0m [0m
[90mline 901 <<: [0m
[90mline 902 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 903 <<: [33m# 5.3. Safe Operations using Maybe[0m[0m
[90mline 904 <<: [33m#[0m[0m
[90mline 905 <<: [33m# These functions demonstrate how Maybe types enable safe operations on[0m[0m
[90mline 906 <<: [33m# potentially dangerous computations. Instead of crashing or returning[0m[0m
[90mline 907 <<: [33m# invalid results, they return structured optional values.[0m[0m
[90mline 908 <<: [33m#[0m[0m
[90mline 909 <<: [33m# SAFETY PATTERN:[0m[0m
[90mline 910 <<: [33m#   Traditional: f(x) â†’ crash if x invalid[0m[0m
[90mline 911 <<: [33m#   Safe: safef(x) â†’ nothing if x invalid, just result if x valid[0m[0m
[90mline 912 <<: [33m#[0m[0m
[90mline 913 <<: [33m# COMPOSITION SAFETY:[0m[0m
[90mline 914 <<: [33m#   Safe operations can be chained using monadic bind patterns,[0m[0m
[90mline 915 <<: [33m#   automatically handling the failure cases throughout the chain.[0m[0m
[90mline 916 <<: [33m#[0m[0m
[90mline 917 <<: [33m# EXAMPLES OF SAFETY:[0m[0m
[90mline 918 <<: [33m#   - safehead: No crash on empty lists[0m[0m
[90mline 919 <<: [33m#   - safediv: No division by zero[0m[0m
[90mline 920 <<: [33m#   - safenth: No index out of bounds[0m[0m
[90mline 921 <<: [33m#   - safeMinimum/Maximum: No crash on empty collections[0m[0m
[90mline 922 <<: [33m#[0m[0m
[90mline 923 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 924 <<: [33m#   safehead (cons 1 (cons 2 nil))    # Returns just 1[0m[0m
[90mline 925 <<: [33m#   safehead nil                      # Returns nothing[0m[0m
[90mline 926 <<: [33m#   [0m[0m
[90mline 927 <<: [33m#   safediv 10 2                      # Returns just 5[0m[0m
[90mline 928 <<: [33m#   safediv 10 0                      # Returns nothing[0m[0m
[90mline 929 <<: [33m#   [0m[0m
[90mline 930 <<: [33m#   safenth 0 (cons 'a' (cons 'b' nil))  # Returns just 'a'[0m[0m
[90mline 931 <<: [33m#   safenth 5 (cons 'a' nil)             # Returns nothing[0m[0m
[90mline 932 <<: [33m#   [0m[0m
[90mline 933 <<: [33m#   # Chaining safe operations[0m[0m
[90mline 934 <<: [33m#   processFirst = Î»l.maybeMap (mult 2) (safehead l)[0m[0m
[90mline 935 <<: [33m#   processFirst (cons 5 nil)         # Returns just 10[0m[0m
[90mline 936 <<: [33m#   processFirst nil                  # Returns nothing[0m[0m
[90mline 937 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 938 <<: safehead = Î»l.if (isnil l) nothing (just (head l))[0m
[32m-> safehead = Î»l.if (isnil l) nothing (just (head l))[0m
[0m [0m
[90mline 939 <<: safetail = Î»l.if (isnil l) nothing (just (tail l))[0m
[32m-> safetail = Î»l.if (isnil l) nothing (just (tail l))[0m
[0m [0m
[90mline 940 <<: safenth  = Î»n l.if (gt n (pred (length l))) nothing (just (nth n l))[0m
[32m-> safenth = Î»n.Î»l.if (gt n (pred (length l))) nothing (just (nth n l))[0m
[0m [0m
[90mline 941 <<: [33m# safediv: legacy lowercase naming kept for backward compatibility.[0m[0m
[90mline 942 <<: [33m# Prefer using safeDiv (alias) for consistency with other safe* functions.[0m[0m
[90mline 943 <<: safediv  = Î»a b.if (iszero b) nothing (just (div a b))[0m
[32m-> safediv = Î»a.Î»b.if (iszero b) nothing (just (div a b))[0m
[0m [0m
[90mline 944 <<: [33m# Alias with preferred casing[0m[0m
[0mPROGRESS::54[0m
[90mline 945 <<: safeDiv  = safediv[0m
[32m-> safeDiv = Î»a.Î»b.if (iszero b) nothing (just (div a b))[0m
[0m [0m
[90mline 946 <<: safeMinimum = Î»l.if (isnil l) nothing (just (minimum l))[0m
[32m-> safeMinimum = Î»l.if (isnil l) nothing (just (minimum l))[0m
[0m [0m
[90mline 947 <<: safeMaximum = Î»l.if (isnil l) nothing (just (maximum l))[0m
[32m-> safeMaximum = Î»l.if (isnil l) nothing (just (maximum l))[0m
[0m [0m
[90mline 948 <<: [33m# safeInit[0m[0m
[90mline 949 <<: [33m# Returns the list without its last element (or nil if empty/singleton).[0m[0m
[90mline 950 <<: [33m# NOTE: Unlike other safe* functions this returns a plain list, NOT a Maybe.[0m[0m
[90mline 951 <<: [33m# Use safeInitMaybe if you need a Maybe-encoded result.[0m[0m
[90mline 952 <<: safeInit = Î»l.if (or (isnil l) (isnil (tail l))) nil (reverse (tail (reverse l)))[0m
[32m-> safeInit = Î»l.if (or (isnil l) (isnil (tail l))) [] (reverse (tail (reverse l)))[0m
[0m [0m
[90mline 953 <<: [0m
[90mline 954 <<: [33m# Maybe-encoded variant for consistency with safehead/safetail/etc.[0m[0m
[90mline 955 <<: safeInitMaybe = Î»l.if (or (isnil l) (isnil (tail l))) nothing (just (reverse (tail (reverse l))))[0m
[32m-> safeInitMaybe = Î»l.if (or (isnil l) (isnil (tail l))) nothing (just (reverse (tail (reverse l))))[0m
[0m [0m
[90mline 956 <<: maybeMap = Î»f m.if (isNothing m) nothing (just (f (fromJust m)))[0m
[32m-> maybeMap = Î»f.Î»m.if (isNothing m) nothing (just (f (fromJust m)))[0m
[0m [0m
[90mline 957 <<: [0m
[90mline 958 <<: [0m
[90mline 959 <<: [33m# =============================================================================[0m[0m
[90mline 960 <<: [33m# SECTION 6: STATE AND I/O[0m[0m
[90mline 961 <<: [33m#[0m[0m
[90mline 962 <<: [33m# This section provides utilities for managing state and simulating I/O in a[0m[0m
[90mline 963 <<: [33m# purely functional way. These patterns demonstrate how imperative concepts[0m[0m
[90mline 964 <<: [33m# can be expressed through pure functional programming using monadic patterns.[0m[0m
[90mline 965 <<: [33m#[0m[0m
[90mline 966 <<: [33m# STATE MONAD CONCEPT:[0m[0m
[90mline 967 <<: [33m#   The State monad encapsulates stateful computations as functions that[0m[0m
[90mline 968 <<: [33m#   take an initial state and return both a result and a new state.[0m[0m
[90mline 969 <<: [33m#   This allows for stateful programming without mutable variables.[0m[0m
[90mline 970 <<: [33m#[0m[0m
[90mline 971 <<: [33m# I/O SIMULATION:[0m[0m
[90mline 972 <<: [33m#   Since pure lambda calculus has no I/O primitives, we simulate I/O[0m[0m
[90mline 973 <<: [33m#   operations using list transformations and stream processing patterns.[0m[0m
[90mline 974 <<: [33m#[0m[0m
[90mline 975 <<: [33m# MONADIC LAWS:[0m[0m
[90mline 976 <<: [33m#   These combinators follow the monadic laws for composition:[0m[0m
[90mline 977 <<: [33m#   - Left identity: returnState >=> f â‰¡ f[0m[0m
[90mline 978 <<: [33m#   - Right identity: f >=> returnState â‰¡ f  [0m[0m
[90mline 979 <<: [33m#   - Associativity: (f >=> g) >=> h â‰¡ f >=> (g >=> h)[0m[0m
[90mline 980 <<: [33m# =============================================================================[0m[0m
[90mline 981 <<: [0m
[90mline 982 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 983 <<: [33m# 6.1. State Monad Helpers[0m[0m
[90mline 984 <<: [33m#[0m[0m
[90mline 985 <<: [33m# The State monad allows for stateful computations in pure functional programming.[0m[0m
[90mline 986 <<: [33m# A stateful computation is represented as a function: State â†’ (Result, NewState)[0m[0m
[90mline 987 <<: [33m#[0m[0m
[90mline 988 <<: [33m# MONAD OPERATIONS:[0m[0m
[90mline 989 <<: [33m#   returnState: Wraps a pure value in the state monad[0m[0m
[90mline 990 <<: [33m#   bindState: Sequences stateful computations (monadic bind)[0m[0m
[90mline 991 <<: [33m#   getState: Reads the current state[0m[0m
[90mline 992 <<: [33m#   putState: Sets a new state[0m[0m
[90mline 993 <<: [33m#   runState: Executes a stateful computation with initial state[0m[0m
[90mline 994 <<: [33m#[0m[0m
[90mline 995 <<: [33m# COMPUTATIONAL PATTERN:[0m[0m
[90mline 996 <<: [33m#   - Each operation takes state and returns (value, new_state)[0m[0m
[90mline 997 <<: [33m#   - bindState threads state through computations automatically[0m[0m
[90mline 998 <<: [33m#   - Provides illusion of mutable state in pure functional setting[0m[0m
[90mline 999 <<: [33m#[0m[0m
[90mline 1000 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1001 <<: [33m#   # Simple counter that increments state[0m[0m
[90mline 1002 <<: [33m#   increment = Î»s.pair (plus s 1) (plus s 1)[0m[0m
[90mline 1003 <<: [33m#   [0m[0m
[90mline 1004 <<: [33m#   # Stateful computation that doubles then increments[0m[0m
[90mline 1005 <<: [33m#   doubleInc = bindState (Î»x.returnState (mult x 2)) [0m[0m
[90mline 1006 <<: [33m#                        (Î»y.Î»s.pair (plus y 1) (plus s 1))[0m[0m
[90mline 1007 <<: [33m#   [0m[0m
[90mline 1008 <<: [33m#   runState increment 5          # Returns pair 6 6[0m[0m
[90mline 1009 <<: [33m#   runState getState 42          # Returns pair 42 42[0m[0m
[90mline 1010 <<: [33m#   runState (putState 100) 42    # Returns pair nil 100[0m[0m
[90mline 1011 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1012 <<: returnState = Î»x s.pair x s[0m
[32m-> returnState = Î»x.Î»s.pair x s[0m
[0m [0m
[90mline 1013 <<: bindState   = Î»m f s.f (first (m s)) (second (m s))[0m
[32m-> bindState = Î»m.Î»f.Î»s.f (first (m s)) (second (m s))[0m
[0m [0m
[90mline 1014 <<: getState    = Î»s.pair s s[0m
[32m-> getState = Î»s.pair s s[0m
[0m [0m
[90mline 1015 <<: putState    = Î»s.Î»_.pair nil s[0m
[32m-> putState = Î»s.Î»_placeholder1.pair [] s[0m
[0m [0m
[90mline 1016 <<: runState    = Î»m s.m s[0m
[32m-> runState = 1[0m
[0m [0m
[90mline 1017 <<: [0m
[90mline 1018 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1019 <<: [33m# 6.2. I/O Simulation[0m[0m
[90mline 1020 <<: [33m#[0m[0m
[90mline 1021 <<: [33m# These functions simulate I/O by treating lists of characters (numbers) as[0m[0m
[90mline 1022 <<: [33m# input/output streams. This demonstrates how imperative I/O can be modeled[0m[0m
[90mline 1023 <<: [33m# functionally using stream transformations.[0m[0m
[90mline 1024 <<: [33m#[0m[0m
[90mline 1025 <<: [33m# STREAM-BASED I/O MODEL:[0m[0m
[90mline 1026 <<: [33m#   Input: Stream of characters (list of ASCII codes)[0m[0m
[90mline 1027 <<: [33m#   Output: Stream of characters being produced[0m[0m
[90mline 1028 <<: [33m#   Operations transform or consume these streams[0m[0m
[90mline 1029 <<: [33m#[0m[0m
[90mline 1030 <<: [33m# CHARACTER REPRESENTATION:[0m[0m
[90mline 1031 <<: [33m#   Characters are represented as Church numerals corresponding to ASCII codes:[0m[0m
[90mline 1032 <<: [33m#   'A' = 65, 'a' = 97, '0' = 48, space = 32, newline = 10[0m[0m
[0mPROGRESS::59[0m
[90mline 1033 <<: [33m#[0m[0m
[90mline 1034 <<: [33m# FUNCTIONAL I/O PRINCIPLES:[0m[0m
[90mline 1035 <<: [33m#   - No side effects: I/O operations return new streams[0m[0m
[90mline 1036 <<: [33m#   - Composable: Operations can be chained and combined[0m[0m
[90mline 1037 <<: [33m#   - Referentially transparent: Same input always produces same output[0m[0m
[90mline 1038 <<: [33m#[0m[0m
[90mline 1039 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1040 <<: [33m#   # Output a character to stream[0m[0m
[90mline 1041 <<: [33m#   output1 = putChar 65 nil              # Outputs 'A'[0m[0m
[90mline 1042 <<: [33m#   output2 = putChar 66 output1          # Outputs "BA"[0m[0m
[90mline 1043 <<: [33m#   [0m[0m
[90mline 1044 <<: [33m#   # Read first character from input[0m[0m
[90mline 1045 <<: [33m#   input = cons 72 (cons 105 nil)        # "Hi"[0m[0m
[90mline 1046 <<: [33m#   firstChar = getChar input             # Returns 72 ('H')[0m[0m
[90mline 1047 <<: [33m#   [0m[0m
[90mline 1048 <<: [33m#   # Append strings[0m[0m
[90mline 1049 <<: [33m#   hello = cons 72 (cons 101 (cons 108 (cons 108 (cons 111 nil))))  # "Hello"[0m[0m
[90mline 1050 <<: [33m#   world = cons 87 (cons 111 (cons 114 (cons 108 (cons 100 nil))))  # "World"[0m[0m
[90mline 1051 <<: [33m#   greeting = putStr hello world         # "HelloWorld"[0m[0m
[90mline 1052 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1053 <<: putChar = Î»c.cons c[0m
[32m-> putChar = Î»c.cons c[0m
[0m [0m
[90mline 1054 <<: getChar = head[0m
[32m-> getChar = Î»l.l (true) [][0m
[0m [0m
[90mline 1055 <<: putStr  = append[0m
[32m-> putStr = [cons][0m
[0m [0m
[90mline 1056 <<: getLine = Î»l.filter (neq 10) l [33m# Simplified: take until newline[0m[0m
[32m-> getLine = Î»l.filter (neq 10) l[0m
[0m [0m
[90mline 1057 <<: [0m
[90mline 1058 <<: [0m
[90mline 1059 <<: [33m# =============================================================================[0m[0m
[90mline 1060 <<: [33m# SECTION 7: STRING AND CHARACTER SIMULATION[0m[0m
[90mline 1061 <<: [33m#[0m[0m
[90mline 1062 <<: [33m# This section provides utilities for working with "strings" and "characters,"[0m[0m
[90mline 1063 <<: [33m# which are represented as lists of numbers (ASCII codes). This demonstrates[0m[0m
[90mline 1064 <<: [33m# how higher-level data types can be built from primitive Church encodings.[0m[0m
[90mline 1065 <<: [33m#[0m[0m
[90mline 1066 <<: [33m# STRING REPRESENTATION:[0m[0m
[90mline 1067 <<: [33m#   Strings are lists of Church numerals representing ASCII character codes.[0m[0m
[90mline 1068 <<: [33m#   This encoding allows for uniform treatment of textual and numeric data[0m[0m
[90mline 1069 <<: [33m#   while maintaining the pure functional paradigm.[0m[0m
[90mline 1070 <<: [33m#[0m[0m
[90mline 1071 <<: [33m# ASCII ENCODING FOUNDATION:[0m[0m
[90mline 1072 <<: [33m#   - Printable characters: 32-126[0m[0m
[90mline 1073 <<: [33m#   - Digits: 48-57 ('0'-'9')[0m[0m
[90mline 1074 <<: [33m#   - Uppercase: 65-90 ('A'-'Z') [0m[0m
[90mline 1075 <<: [33m#   - Lowercase: 97-122 ('a'-'z')[0m[0m
[90mline 1076 <<: [33m#   - Whitespace: space(32), tab(9), newline(10)[0m[0m
[90mline 1077 <<: [33m#[0m[0m
[90mline 1078 <<: [33m# CHARACTER CLASSIFICATION:[0m[0m
[90mline 1079 <<: [33m#   Predicate functions test character properties using ASCII code ranges.[0m[0m
[90mline 1080 <<: [33m#   These enable parsing and text processing operations.[0m[0m
[90mline 1081 <<: [33m#[0m[0m
[90mline 1082 <<: [33m# TEXT PROCESSING CAPABILITIES:[0m[0m
[90mline 1083 <<: [33m#   - Case conversion (upper/lower)[0m[0m
[90mline 1084 <<: [33m#   - Character type testing (digit, alpha, etc.)[0m[0m
[90mline 1085 <<: [33m#   - String manipulation through list operations[0m[0m
[90mline 1086 <<: [33m#   - Text parsing and formatting[0m[0m
[90mline 1087 <<: [33m# =============================================================================[0m[0m
[90mline 1088 <<: [0m
[90mline 1089 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1090 <<: [33m# 7.1. ASCII Constants and Predicates[0m[0m
[90mline 1091 <<: [33m#[0m[0m
[90mline 1092 <<: [33m# These constants and predicates provide the foundation for character-based[0m[0m
[90mline 1093 <<: [33m# text processing. They define important ASCII values and classification[0m[0m
[90mline 1094 <<: [33m# functions for different character types.[0m[0m
[90mline 1095 <<: [33m#[0m[0m
[90mline 1096 <<: [33m# ASCII CONSTANTS:[0m[0m
[90mline 1097 <<: [33m#   Critical whitespace and control characters used in text processing.[0m[0m
[90mline 1098 <<: [33m#   These form the basis for parsing and formatting operations.[0m[0m
[90mline 1099 <<: [33m#[0m[0m
[90mline 1100 <<: [33m# PREDICATE FUNCTIONS:[0m[0m
[90mline 1101 <<: [33m#   Character classification functions that test properties of ASCII codes.[0m[0m
[90mline 1102 <<: [33m#   These enable sophisticated text parsing and validation.[0m[0m
[90mline 1103 <<: [33m#[0m[0m
[90mline 1104 <<: [33m# RANGE-BASED CLASSIFICATION:[0m[0m
[90mline 1105 <<: [33m#   Uses numerical comparisons on ASCII codes to determine character types.[0m[0m
[90mline 1106 <<: [33m#   This approach is efficient and leverages the ordered nature of ASCII.[0m[0m
[90mline 1107 <<: [33m#[0m[0m
[90mline 1108 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1109 <<: [33m#   isdigit 48                    # Returns true ('0')[0m[0m
[90mline 1110 <<: [33m#   isdigit 65                    # Returns false ('A')[0m[0m
[90mline 1111 <<: [33m#   [0m[0m
[90mline 1112 <<: [33m#   islower 97                    # Returns true ('a')[0m[0m
[90mline 1113 <<: [33m#   isupper 97                    # Returns false ('a')[0m[0m
[90mline 1114 <<: [33m#   isupper 65                    # Returns true ('A')[0m[0m
[90mline 1115 <<: [33m#   [0m[0m
[90mline 1116 <<: [33m#   isalpha 65                    # Returns true ('A')[0m[0m
[90mline 1117 <<: [33m#   isalpha 48                    # Returns false ('0')[0m[0m
[90mline 1118 <<: [33m#   [0m[0m
[90mline 1119 <<: [33m#   isalnum 48                    # Returns true ('0')[0m[0m
[0mPROGRESS::64[0m
[90mline 1120 <<: [33m#   isalnum 65                    # Returns true ('A')[0m[0m
[90mline 1121 <<: [33m#   isalnum 32                    # Returns false (space)[0m[0m
[90mline 1122 <<: [33m#   [0m[0m
[90mline 1123 <<: [33m#   isspace 32                    # Returns true (space)[0m[0m
[90mline 1124 <<: [33m#   isspace 9                     # Returns true (tab)[0m[0m
[90mline 1125 <<: [33m#   isspace 65                    # Returns false ('A')[0m[0m
[90mline 1126 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1127 <<: space    = 32[0m
[32m-> space = 32[0m
[0m [0m
[90mline 1128 <<: newline  = 10[0m
[32m-> newline = 10[0m
[0m [0m
[90mline 1129 <<: tab      = 9[0m
[32m-> tab = 9[0m
[0m [0m
[90mline 1130 <<: [33m# null     = 0 # Redundant with zero[0m[0m
[90mline 1131 <<: isspace  = Î»c.or (eq c space) (or (eq c tab) (eq c newline))[0m
[32m-> isspace = Î»c.or (eq c space) (or (eq c tab) (eq c newline))[0m
[0m [0m
[90mline 1132 <<: isdigit  = Î»c.and (geq c 48) (leq c 57)[0m
[32m-> isdigit = Î»c.and (geq c 48) (leq c 57)[0m
[0m [0m
[90mline 1133 <<: islower  = Î»c.and (geq c 97) (leq c 122)[0m
[32m-> islower = Î»c.and (geq c 97) (leq c 122)[0m
[0m [0m
[90mline 1134 <<: isupper  = Î»c.and (geq c 65) (leq c 90)[0m
[32m-> isupper = Î»c.and (geq c 65) (leq c 90)[0m
[0m [0m
[90mline 1135 <<: isalpha  = Î»c.or (islower c) (isupper c)[0m
[32m-> isalpha = Î»c.or (islower c) (isupper c)[0m
[0m [0m
[90mline 1136 <<: isalnum  = Î»c.or (isalpha c) (isdigit c)[0m
[32m-> isalnum = Î»c.or (isalpha c) (isdigit c)[0m
[0m [0m
[90mline 1137 <<: [0m
[90mline 1138 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1139 <<: [33m# 7.2. Character and String Operations[0m[0m
[90mline 1140 <<: [33m#[0m[0m
[90mline 1141 <<: [33m# These functions provide character case conversion and demonstrate how[0m[0m
[90mline 1142 <<: [33m# string operations can be implemented through ASCII code manipulation.[0m[0m
[90mline 1143 <<: [33m#[0m[0m
[90mline 1144 <<: [33m# CASE CONVERSION ALGORITHM:[0m[0m
[90mline 1145 <<: [33m#   ASCII encoding places uppercase and lowercase letters exactly 32 positions[0m[0m
[90mline 1146 <<: [33m#   apart: 'A'(65) vs 'a'(97), 'B'(66) vs 'b'(98), etc.[0m[0m
[90mline 1147 <<: [33m#   Conversion involves adding/subtracting 32 based on current case.[0m[0m
[90mline 1148 <<: [33m#[0m[0m
[90mline 1149 <<: [33m# CONDITIONAL CONVERSION:[0m[0m
[90mline 1150 <<: [33m#   Only converts characters that are actually letters, leaving other[0m[0m
[90mline 1151 <<: [33m#   characters unchanged. This prevents corruption of numbers and symbols.[0m[0m
[90mline 1152 <<: [33m#[0m[0m
[90mline 1153 <<: [33m# STRING OPERATION ALIASES:[0m[0m
[90mline 1154 <<: [33m#   Some functions provide familiar names for existing list operations,[0m[0m
[90mline 1155 <<: [33m#   demonstrating how strings are just specialized lists of characters.[0m[0m
[90mline 1156 <<: [33m#[0m[0m
[90mline 1157 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1158 <<: [33m#   tolower 65                    # Returns 97 ('A' â†’ 'a')[0m[0m
[90mline 1159 <<: [33m#   tolower 97                    # Returns 97 ('a' â†’ 'a', no change)[0m[0m
[90mline 1160 <<: [33m#   tolower 48                    # Returns 48 ('0' â†’ '0', not a letter)[0m[0m
[90mline 1161 <<: [33m#   [0m[0m
[90mline 1162 <<: [33m#   toupper 97                    # Returns 65 ('a' â†’ 'A')[0m[0m
[90mline 1163 <<: [33m#   toupper 65                    # Returns 65 ('A' â†’ 'A', no change)[0m[0m
[90mline 1164 <<: [33m#   toupper 33                    # Returns 33 ('!' â†’ '!', not a letter)[0m[0m
[90mline 1165 <<: [33m#   [0m[0m
[90mline 1166 <<: [33m#   # Converting entire strings (lists of characters)[0m[0m
[90mline 1167 <<: [33m#   hello = cons 72 (cons 101 (cons 108 (cons 108 (cons 111 nil))))  # "Hello"[0m[0m
[90mline 1168 <<: [33m#   upper_hello = map toupper hello    # "HELLO"[0m[0m
[90mline 1169 <<: [33m#   lower_hello = map tolower hello    # "hello"[0m[0m
[90mline 1170 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1171 <<: tolower  = Î»c.if (isupper c) (plus c 32) c[0m
[32m-> tolower = Î»c.if (isupper c) (plus c 32) c[0m
[0m [0m
[90mline 1172 <<: toupper  = Î»c.if (islower c) (minus c 32) c[0m
[32m-> toupper = Î»c.if (islower c) (minus c 32) c[0m
[0m [0m
[90mline 1173 <<: [33m# strlen   = length # Alias for length[0m[0m
[90mline 1174 <<: [33m# strcat   = append # Alias for append[0m[0m
[90mline 1175 <<: [33m# strrev   = reverse # Alias for reverse[0m[0m
[90mline 1176 <<: words    = Î»l.filter (Î»w.not (isnil w)) (break isspace l)[0m
[32m-> words = Î»l.filter (Î»w.not (isnil w)) (break isspace l)[0m
[0m [0m
[90mline 1177 <<: lines    = Î»l.filter (Î»w.not (isnil w)) (break (eq newline) l)[0m
[32m-> lines = Î»l.filter (Î»w.not (isnil w)) (break (eq newline) l)[0m
[0m [0m
[90mline 1178 <<: unwords  = intercalate (cons space nil)[0m
[32m-> unwords = intercalate (Î»f.Î»z.f 32 (false f z))[0m
[0m [0m
[90mline 1179 <<: unlines  = intercalate (cons newline nil)[0m
[32m-> unlines = intercalate (Î»f.Î»z.f 10 (false f z))[0m
[0m [0m
[90mline 1180 <<: break    = Î»p l.foldl (Î»acc x.if (p x) acc (pair (cons x (first acc)) (second acc))) (pair nil l) l[0m
[32m-> break = Î»p.Î»l.foldl (Î»acc.Î»x.if (p x) acc (pair (cons x (first acc)) (second acc))) (pair [] l) l[0m
[0m [0m
[90mline 1181 <<: intercalate = Î»sep l.if (isnil l) nil (if (isnil (tail l)) (head l) (foldr (Î»x acc.if (isnil acc) x (append x (cons sep acc))) nil l))[0m
[32m-> intercalate = Î»sep.Î»l.if (isnil l) [] (if (isnil (tail l)) (head l) (foldr (Î»x.Î»acc.if (isnil acc) x (append x (cons sep acc))) [] l))[0m
[0m [0m
[90mline 1182 <<: [0m
[90mline 1183 <<: [0m
[90mline 1184 <<: [33m# =============================================================================[0m[0m
[90mline 1185 <<: [33m# SECTION 8: DEBUGGING, ERRORS, AND PERFORMANCE[0m[0m
[90mline 1186 <<: [33m#[0m[0m
[90mline 1187 <<: [33m# This section provides utilities for debugging, error handling, and[0m[0m
[90mline 1188 <<: [33m# performance analysis in the lambda calculus. These tools help developers[0m[0m
[90mline 1189 <<: [33m# understand program behavior and optimize computational efficiency.[0m[0m
[90mline 1190 <<: [33m#[0m[0m
[90mline 1191 <<: [33m# ERROR HANDLING PHILOSOPHY:[0m[0m
[90mline 1192 <<: [33m#   Since lambda calculus lacks exceptions, errors are represented as[0m[0m
[90mline 1193 <<: [33m#   divergent computations (infinite loops) or special values that can[0m[0m
[90mline 1194 <<: [33m#   be detected by the runtime environment.[0m[0m
[90mline 1195 <<: [33m#[0m[0m
[90mline 1196 <<: [33m# DEBUGGING STRATEGY:[0m[0m
[90mline 1197 <<: [33m#   Functional debugging relies on tracing values through computations[0m[0m
[90mline 1198 <<: [33m#   rather than traditional step-through debugging. The trace function[0m[0m
[90mline 1199 <<: [33m#   provides a hook for observing intermediate values.[0m[0m
[90mline 1200 <<: [33m#[0m[0m
[90mline 1201 <<: [33m# PERFORMANCE CONSIDERATIONS:[0m[0m
[90mline 1202 <<: [33m#   Pure functional programming enables certain optimizations like[0m[0m
[90mline 1203 <<: [33m#   memoization and lazy evaluation, though their effectiveness depends[0m[0m
[90mline 1204 <<: [33m#   on the implementation environment.[0m[0m
[90mline 1205 <<: [33m# =============================================================================[0m[0m
[90mline 1206 <<: [0m
[90mline 1207 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[0mPROGRESS::69[0m
[90mline 1208 <<: [33m# 8.1. Debugging and Error Handling[0m[0m
[90mline 1209 <<: [33m#[0m[0m
[90mline 1210 <<: [33m# These functions provide mechanisms for program debugging and error[0m[0m
[90mline 1211 <<: [33m# representation in the pure functional paradigm.[0m[0m
[90mline 1212 <<: [33m#[0m[0m
[90mline 1213 <<: [33m# TRACE FUNCTION:[0m[0m
[90mline 1214 <<: [33m#   The trace function is designed to log or display debugging information[0m[0m
[90mline 1215 <<: [33m#   while returning its argument unchanged. In this implementation, it's[0m[0m
[90mline 1216 <<: [33m#   a no-op, but in a full system it would output the message.[0m[0m
[90mline 1217 <<: [33m#[0m[0m
[90mline 1218 <<: [33m# ERROR REPRESENTATION:[0m[0m
[90mline 1219 <<: [33m#   Errors are represented as divergent computations using fixed-point[0m[0m
[90mline 1220 <<: [33m#   combinators. When an error occurs, the computation enters an infinite[0m[0m
[90mline 1221 <<: [33m#   loop rather than returning a value.[0m[0m
[90mline 1222 <<: [33m#[0m[0m
[90mline 1223 <<: [33m# ERROR TYPES:[0m[0m
[90mline 1224 <<: [33m#   Different error conditions are represented by specific error constants:[0m[0m
[90mline 1225 <<: [33m#   - divByZero: Division by zero errors[0m[0m
[90mline 1226 <<: [33m#   - indexError: Array/list index out of bounds[0m[0m
[90mline 1227 <<: [33m#   - typeError: Type mismatch errors[0m[0m
[90mline 1228 <<: [33m#[0m[0m
[90mline 1229 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1230 <<: [33m#   # Debugging (conceptual - actual implementation may vary)[0m[0m
[90mline 1231 <<: [33m#   trace "computing factorial" (factorial 5)[0m[0m
[90mline 1232 <<: [33m#   [0m[0m
[90mline 1233 <<: [33m#   # Error conditions[0m[0m
[90mline 1234 <<: [33m#   divide = Î»a b.if (iszero b) divByZero (div a b)[0m[0m
[90mline 1235 <<: [33m#   divide 10 2       # Returns 5[0m[0m
[90mline 1236 <<: [33m#   divide 10 0       # Triggers divByZero (infinite loop)[0m[0m
[90mline 1237 <<: [33m#   [0m[0m
[90mline 1238 <<: [33m#   # Safe indexing[0m[0m
[90mline 1239 <<: [33m#   safeIndex = Î»n l.if (geq n (length l)) indexError (nth n l)[0m[0m
[90mline 1240 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1241 <<: trace     = Î»msg x.x[0m
[32m-> trace = false[0m
[0m [0m
[90mline 1242 <<: [33m# debug     = trace # Alias for trace[0m[0m
[90mline 1243 <<: undefined = Y I[0m
[32m-> undefined = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1244 <<: error     = undefined[0m
[32m-> error = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1245 <<: [33m# Error types for safe operations[0m[0m
[90mline 1246 <<: divByZero  = undefined[0m
[32m-> divByZero = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1247 <<: indexError = undefined[0m
[32m-> indexError = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1248 <<: typeError  = undefined[0m
[32m-> typeError = <thunk:(Î»x.x) (Y (Î»x.x))>[0m
[0m [0m
[90mline 1249 <<: [0m
[90mline 1250 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1251 <<: [33m# 8.2. Performance and Optimization[0m[0m
[90mline 1252 <<: [33m#[0m[0m
[90mline 1253 <<: [33m# These functions provide tools for measuring and optimizing performance[0m[0m
[90mline 1254 <<: [33m# in functional programs.[0m[0m
[90mline 1255 <<: [33m#[0m[0m
[90mline 1256 <<: [33m# BENCHMARKING:[0m[0m
[90mline 1257 <<: [33m#   The benchmark function repeatedly applies a function to measure[0m[0m
[90mline 1258 <<: [33m#   performance characteristics. This helps identify computational[0m[0m
[90mline 1259 <<: [33m#   bottlenecks and compare algorithm efficiency.[0m[0m
[90mline 1260 <<: [33m#[0m[0m
[90mline 1261 <<: [33m# MEMOIZATION:[0m[0m
[90mline 1262 <<: [33m#   In pure functional programming, memoization can cache function results[0m[0m
[90mline 1263 <<: [33m#   to avoid recomputation. This implementation is a placeholder since[0m[0m
[90mline 1264 <<: [33m#   true memoization requires mutable state.[0m[0m
[90mline 1265 <<: [33m#[0m[0m
[90mline 1266 <<: [33m# LAZY EVALUATION:[0m[0m
[90mline 1267 <<: [33m#   Delay and force implement a basic form of lazy evaluation where[0m[0m
[90mline 1268 <<: [33m#   computations are deferred until their results are needed.[0m[0m
[90mline 1269 <<: [33m#   This can improve performance by avoiding unnecessary calculations.[0m[0m
[90mline 1270 <<: [33m#[0m[0m
[90mline 1271 <<: [33m# OPTIMIZATION STRATEGIES:[0m[0m
[90mline 1272 <<: [33m#   - Use tail recursion when possible to avoid stack overflow[0m[0m
[90mline 1273 <<: [33m#   - Consider memoization for expensive recursive functions[0m[0m
[90mline 1274 <<: [33m#   - Employ lazy evaluation for potentially infinite data structures[0m[0m
[90mline 1275 <<: [33m#   - Benchmark different algorithms to choose the most efficient[0m[0m
[90mline 1276 <<: [33m#[0m[0m
[90mline 1277 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1278 <<: [33m#   # Benchmarking factorial computation[0m[0m
[90mline 1279 <<: [33m#   benchmark 1000 factorial 10    # Runs factorial(10) 1000 times[0m[0m
[90mline 1280 <<: [33m#   [0m[0m
[90mline 1281 <<: [33m#   # Lazy evaluation of expensive computation[0m[0m
[90mline 1282 <<: [33m#   expensiveCalc = delay (factorial 100)[0m[0m
[90mline 1283 <<: [33m#   result = force expensiveCalc    # Only computed when forced[0m[0m
[90mline 1284 <<: [33m#   [0m[0m
[90mline 1285 <<: [33m#   # Memoized function (conceptual)[0m[0m
[90mline 1286 <<: [33m#   fastFib = memoize fibonacci     # Caches previous results[0m[0m
[90mline 1287 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1288 <<: benchmark = Î»n f x.times n (Î»_.f x) x[0m
[32m-> benchmark = Î»n.Î»f.Î»x.times n (Î»_placeholder1.f x) x[0m
[0m [0m
[90mline 1289 <<: [33m# timeIt    = benchmark # Alias for benchmark[0m[0m
[90mline 1290 <<: [33m# Memoization is a no-op without mutation, included for concept[0m[0m
[90mline 1291 <<: memoize   = Î»f.f[0m
[32m-> memoize = Î»f.f[0m
[0m [0m
[90mline 1292 <<: [33m# Lazy evaluation helpers[0m[0m
[90mline 1293 <<: delay     = Î»x.Î»f.f x[0m
[32m-> delay = Î»x.Î»f.f x[0m
[0m [0m
[90mline 1294 <<: force     = Î»thunk.thunk I[0m
[32m-> force = Î»thunk.thunk I[0m
[0m [0m
[0mPROGRESS::74[0m
[90mline 1295 <<: [0m
[90mline 1296 <<: [0m
[90mline 1297 <<: [33m# =============================================================================[0m[0m
[90mline 1298 <<: [33m# 8.3. STRUCTURAL EQUALITY HELPERS[0m[0m
[90mline 1299 <<: [33m#[0m[0m
[90mline 1300 <<: [33m# Primitive eq only handles numerals (using order). For composite structures[0m[0m
[90mline 1301 <<: [33m# we supply parametric structural equality combinators. They take an element[0m[0m
[90mline 1302 <<: [33m# equality (or two, for Either) so callers choose how to compare leaves.[0m[0m
[90mline 1303 <<: [33m# We intentionally do NOT redefine eq globally to avoid ambiguity between[0m[0m
[90mline 1304 <<: [33m# 0 / nil / nothing, which all share the same Church encoding here.[0m[0m
[90mline 1305 <<: [33m#[0m[0m
[90mline 1306 <<: [33m# listEq   eqE l1 l2    : deep equality on lists[0m[0m
[90mline 1307 <<: [33m# pairEq   eqA eqB p q  : product equality[0m[0m
[90mline 1308 <<: [33m# maybeEq  eqA m1 m2    : optional equality[0m[0m
[90mline 1309 <<: [33m# eitherEq eqL eqR e1 e2: sum equality[0m[0m
[90mline 1310 <<: [33m#[0m[0m
[90mline 1311 <<: [33m# Example convenience macros (added later) will allow: test-list, test-pairâ€¦[0m[0m
[90mline 1312 <<: [33m#[0m[0m
[90mline 1313 <<: [33m# NOTE: For nested structures use partial application: (listEq (listEq eq) a b)[0m[0m
[90mline 1314 <<: [33m# =============================================================================[0m[0m
[90mline 1315 <<: [33m# Equality Guide[0m[0m
[90mline 1316 <<: [33m# eq            : primitive / numeric equality on Church numerals, booleans, chars[0m[0m
[90mline 1317 <<: [33m# isStructEqual : full structural + alpha equivalence (normalizes expressions)[0m[0m
[90mline 1318 <<: [33m# listEq/...Eq  : deep equality for specific encodings using a provided element eq[0m[0m
[90mline 1319 <<: [33m#[0m[0m
[90mline 1320 <<: [33m# Use hierarchy:[0m[0m
[90mline 1321 <<: [33m#  1. For user data structures (lists/pairs/maybe/either): use listEq etc. with element eq.[0m[0m
[90mline 1322 <<: [33m#  2. For general lambda expressions where structure matters: isStructEqual.[0m[0m
[90mline 1323 <<: [33m#  3. For numerals/booleans/chars inside algorithms: eq.[0m[0m
[90mline 1324 <<: [33m# listEq et al do NOT normalize arbitrary expressions[0m[0m[32m;[0m[90m element eq should align with eq semantics.[0m
[90mline 1325 <<: listEq   = Y (Î»self.Î»eqE.Î»l1.Î»l2. \[0m
[90mline 1326 <<:                                 if (and (isnil l1) (isnil l2)) true ( \[0m
[90mline 1327 <<:                                     if (or (isnil l1) (isnil l2)) false ( \[0m
[90mline 1328 <<:                                         and (eqE (head l1) (head l2)) (self eqE (tail l1) (tail l2)))))[0m
[32m-> listEq = <thunk:(Î»self.Î»eqE.Î»l1.Î»l2.if (and (isnil l1) (isnil l2)) true (if (or (isnil l1) (isnil l2)) false (and (eqE (head l1) (head l2)) (self eqE (tail l1) (tail l2))))) (Y (Î»self.Î»eqE.Î»l1.Î»l2.if (and (isnil l1) (isnil l2)) true (if (or (isnil l1) (isnil l2)) false (and (eqE (head l1) (head l2)) (self eqE (tail l1) (tail l2))))))>[0m
[0m [0m
[90mline 1329 <<: pairEq   = Î»eqA.Î»eqB.Î»p1.Î»p2.and (eqA (first p1) (first p2)) (eqB (second p1) (second p2))[0m
[32m-> pairEq = Î»eqA.Î»eqB.Î»p1.Î»p2.and (eqA (first p1) (first p2)) (eqB (second p1) (second p2))[0m
[0m [0m
[90mline 1330 <<: maybeEq  = Î»eqA.Î»m1.Î»m2.if (and (isNothing m1) (isNothing m2)) true ( \[0m
[90mline 1331 <<:                                             if (or (isNothing m1) (isNothing m2)) false ( \[0m
[90mline 1332 <<:                                                 eqA (fromJust m1) (fromJust m2)))[0m
[32m-> maybeEq = Î»eqA.Î»m1.Î»m2.if (and (isNothing m1) (isNothing m2)) true (if (or (isNothing m1) (isNothing m2)) false (eqA (fromJust m1) (fromJust m2)))[0m
[0m [0m
[90mline 1333 <<: eitherEq = Î»eqL.Î»eqR.Î»e1.Î»e2.if (and (isLeft e1) (isLeft e2)) (eqL (fromLeft e1) (fromLeft e2)) ( \[0m
[90mline 1334 <<:                                                     if (and (isRight e1) (isRight e2)) (eqR (fromRight e1) (fromRight e2)) false)[0m
[32m-> eitherEq = Î»eqL.Î»eqR.Î»e1.Î»e2.if (and (isLeft e1) (isLeft e2)) (eqL (fromLeft e1) (fromLeft e2)) (if (and (isRight e1) (isRight e2)) (eqR (fromRight e1) (fromRight e2)) false)[0m
[0m [0m
[90mline 1335 <<: [0m
[90mline 1336 <<: [0m
[90mline 1337 <<: [33m# =============================================================================[0m[0m
[90mline 1338 <<: [33m# SECTION 9: MACRO SYSTEM[0m[0m
[90mline 1339 <<: [33m#[0m[0m
[90mline 1340 <<: [33m# This section defines a set of macros to provide syntactic sugar and simplify[0m[0m
[90mline 1341 <<: [33m# common programming patterns in the lambda calculus. Macros enable more[0m[0m
[90mline 1342 <<: [33m# readable and maintainable code by abstracting complex lambda expressions.[0m[0m
[90mline 1343 <<: [33m#[0m[0m
[90mline 1344 <<: [33m# MACRO PHILOSOPHY:[0m[0m
[90mline 1345 <<: [33m#   Macros transform source code at parse time, expanding into underlying[0m[0m
[90mline 1346 <<: [33m#   lambda expressions. They provide familiar syntax while maintaining[0m[0m
[90mline 1347 <<: [33m#   the pure functional foundation.[0m[0m
[90mline 1348 <<: [33m#[0m[0m
[90mline 1349 <<: [33m# MACRO SYNTAX:[0m[0m
[90mline 1350 <<: [33m#   :macro (pattern) => (expansion)[0m[0m
[90mline 1351 <<: [33m#   Variables in patterns are prefixed with $ and substituted in expansion.[0m[0m
[90mline 1352 <<: [33m#[0m[0m
[90mline 1353 <<: [33m# CATEGORIES OF MACROS:[0m[0m
[90mline 1354 <<: [33m#   1. Control flow: letbind, when, unless, for, iff[0m[0m
[90mline 1355 <<: [33m#   2. Mathematical: square, cube, inc, dec, min2, max2[0m[0m
[90mline 1356 <<: [33m#   3. Logical: nand, nor with list utilities[0m[0m
[90mline 1357 <<: [33m#   4. Function composition: compose, apply_twice, apply_n[0m[0m
[90mline 1358 <<: [33m#   5. Development aids: assert, test for validation[0m[0m
[90mline 1359 <<: [33m#[0m[0m
[90mline 1360 <<: [33m# BENEFITS:[0m[0m
[90mline 1361 <<: [33m#   - More readable code with familiar syntax[0m[0m
[90mline 1362 <<: [33m#   - Reduced boilerplate for common patterns[0m[0m
[90mline 1363 <<: [33m#   - Type-safe transformations at compile time[0m[0m
[90mline 1364 <<: [33m#   - Easier maintenance and refactoring[0m[0m
[90mline 1365 <<: [33m# =============================================================================[0m[0m
[90mline 1366 <<: [0m
[90mline 1367 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1368 <<: [33m# 9.1. Core and Conditional Macros[0m[0m
[90mline 1369 <<: [33m#[0m[0m
[90mline 1370 <<: [33m# These macros provide essential control flow and binding constructs that[0m[0m
[90mline 1371 <<: [33m# make lambda calculus programming more intuitive and readable.[0m[0m
[90mline 1372 <<: [33m#[0m[0m
[90mline 1373 <<: [33m# LETBIND MACRO:[0m[0m
[90mline 1374 <<: [33m#   Creates local variable bindings using lambda abstraction and application.[0m[0m
[90mline 1375 <<: [33m#   letbind x 5 (+ x 2) expands to ((Î»x.(+ x 2)) 5)[0m[0m
[90mline 1376 <<: [33m#[0m[0m
[90mline 1377 <<: [33m# CONDITIONAL MACROS:[0m[0m
[90mline 1378 <<: [33m#   - when: Executes expression only if condition is true[0m[0m
[90mline 1379 <<: [33m#   - unless: Executes expression only if condition is false[0m[0m
[90mline 1380 <<: [33m#   - iff: Alternative syntax for if-then-else with clearer semantics[0m[0m
[90mline 1381 <<: [33m#[0m[0m
[90mline 1382 <<: [33m# ITERATION MACRO:[0m[0m
[0mPROGRESS::79[0m
[90mline 1383 <<: [33m#   for loops transform into map operations, embracing functional iteration[0m[0m
[90mline 1384 <<: [33m#   over imperative looping constructs.[0m[0m
[90mline 1385 <<: [33m#[0m[0m
[90mline 1386 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1387 <<: [33m#   letbind x 10 (mult x x)               # Local binding: x = 10, returns 100[0m[0m
[90mline 1388 <<: [33m#   when (gt x 0) (display "positive")    # Conditional execution[0m[0m
[90mline 1389 <<: [33m#   unless (iszero x) (div 100 x)         # Negative conditional[0m[0m
[90mline 1390 <<: [33m#   for i at mylist do (mult i 2)         # Functional iteration[0m[0m
[90mline 1391 <<: [33m#   iff (even x) then "even" else "odd"   # Clear conditional syntax[0m[0m
[90mline 1392 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1393 <<: [38;5;205m:macro (letbind $var $val $expr) => ((Î»$var.$expr) $val)[0m[0m
[34mMacro 'letbind' defined successfully[0m
[0m [0m
[90mline 1394 <<: [38;5;205m:macro (when $cond $expr) => (if $cond $expr I)[0m[0m
[34mMacro 'when' defined successfully[0m
[0m [0m
[90mline 1395 <<: [38;5;205m:macro (unless $cond $expr) => (if $cond I $expr)[0m[0m
[34mMacro 'unless' defined successfully[0m
[0m [0m
[90mline 1396 <<: [38;5;205m:macro (for $var at $list do $body) => (map (Î»$var.$body) $list)[0m[0m
[34mMacro 'for' defined successfully[0m
[0m [0m
[90mline 1397 <<: [38;5;205m:macro (iff $p then $then else $else) => if $p $then $else[0m[0m
[34mMacro 'iff' defined successfully[0m
[0m [0m
[90mline 1398 <<: [0m
[90mline 1399 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1400 <<: [33m# 9.2. Math and Comparison Macros[0m[0m
[90mline 1401 <<: [33m#[0m[0m
[90mline 1402 <<: [33m# These macros provide convenient mathematical operations and comparisons[0m[0m
[90mline 1403 <<: [33m# that would otherwise require more verbose lambda expressions.[0m[0m
[90mline 1404 <<: [33m#[0m[0m
[90mline 1405 <<: [33m# MATHEMATICAL OPERATIONS:[0m[0m
[90mline 1406 <<: [33m#   - square, cube: Common polynomial operations[0m[0m
[90mline 1407 <<: [33m#   - inc, dec: Increment and decrement (aliases for succ/pred)[0m[0m
[90mline 1408 <<: [33m#   - min2, max2: Binary minimum and maximum functions[0m[0m
[90mline 1409 <<: [33m#[0m[0m
[90mline 1410 <<: [33m# RANGE OPERATIONS:[0m[0m
[90mline 1411 <<: [33m#   between macro tests if a value falls within a specified range,[0m[0m
[90mline 1412 <<: [33m#   combining multiple comparisons into a single readable expression.[0m[0m
[90mline 1413 <<: [33m#[0m[0m
[90mline 1414 <<: [33m# EFFICIENCY CONSIDERATIONS:[0m[0m
[90mline 1415 <<: [33m#   These macros expand to efficient lambda expressions that avoid[0m[0m
[90mline 1416 <<: [33m#   redundant computation while maintaining mathematical correctness.[0m[0m
[90mline 1417 <<: [33m#[0m[0m
[90mline 1418 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1419 <<: [33m#   square 5                           # Returns 25[0m[0m
[90mline 1420 <<: [33m#   cube 3                             # Returns 27[0m[0m
[90mline 1421 <<: [33m#   inc 10                             # Returns 11[0m[0m
[90mline 1422 <<: [33m#   dec 10                             # Returns 9[0m[0m
[90mline 1423 <<: [33m#   between 5 1 10                     # Returns true (1 â‰¤ 5 â‰¤ 10)[0m[0m
[90mline 1424 <<: [33m#   between 15 1 10                    # Returns false (15 > 10)[0m[0m
[90mline 1425 <<: [33m#   min2 7 3                           # Returns 3[0m[0m
[90mline 1426 <<: [33m#   max2 7 3                           # Returns 7[0m[0m
[90mline 1427 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1428 <<: [38;5;205m:macro (square $x) => (mult $x $x)[0m[0m
[34mMacro 'square' defined successfully[0m
[0m [0m
[90mline 1429 <<: [38;5;205m:macro (cube $x) => (mult $x (mult $x $x))[0m[0m
[34mMacro 'cube' defined successfully[0m
[0m [0m
[90mline 1430 <<: [38;5;205m:macro (inc $x) => (succ $x)[0m[0m
[34mMacro 'inc' defined successfully[0m
[0m [0m
[90mline 1431 <<: [38;5;205m:macro (dec $x) => (pred $x)[0m[0m
[34mMacro 'dec' defined successfully[0m
[0m [0m
[90mline 1432 <<: [38;5;205m:macro (between $x $low $high) => (and (geq $x $low) (leq $x $high))[0m[0m
[34mMacro 'between' defined successfully[0m
[0m [0m
[90mline 1433 <<: [38;5;205m:macro (min2 $a $b) => (if (leq $a $b) $a $b)[0m[0m
[34mMacro 'min2' defined successfully[0m
[0m [0m
[90mline 1434 <<: [38;5;205m:macro (max2 $a $b) => (if (geq $a $b) $a $b)[0m[0m
[34mMacro 'max2' defined successfully[0m
[0m [0m
[90mline 1435 <<: [0m
[90mline 1436 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1437 <<: [33m# 9.3. Boolean and List Macros[0m[0m
[90mline 1438 <<: [33m#[0m[0m
[90mline 1439 <<: [33m# These macros extend boolean logic and provide convenient list operations[0m[0m
[90mline 1440 <<: [33m# with more intuitive naming conventions.[0m[0m
[90mline 1441 <<: [33m#[0m[0m
[90mline 1442 <<: [33m# EXTENDED BOOLEAN LOGIC:[0m[0m
[90mline 1443 <<: [33m#   nand and nor provide the remaining basic boolean operations,[0m[0m
[90mline 1444 <<: [33m#   completing the set of fundamental logical operators.[0m[0m
[90mline 1445 <<: [33m#   These are derived from existing and/or operations with negation.[0m[0m
[90mline 1446 <<: [33m#[0m[0m
[90mline 1447 <<: [33m# LIST CONVENIENCE MACROS:[0m[0m
[90mline 1448 <<: [33m#   - empty?: More intuitive name for testing empty lists[0m[0m
[90mline 1449 <<: [33m#   - first/rest: Alternative names following Lisp conventions[0m[0m
[90mline 1450 <<: [33m#   - These provide familiar vocabulary for list processing[0m[0m
[90mline 1451 <<: [33m#[0m[0m
[90mline 1452 <<: [33m# NAMING CONVENTIONS:[0m[0m
[90mline 1453 <<: [33m#   The macros follow common functional programming conventions:[0m[0m
[90mline 1454 <<: [33m#   - Predicate functions end with '?'[0m[0m
[90mline 1455 <<: [33m#   - first/rest mirror head/tail semantics[0m[0m
[90mline 1456 <<: [33m#   - Boolean operations use standard logical names[0m[0m
[90mline 1457 <<: [33m#[0m[0m
[90mline 1458 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1459 <<: [33m#   nand true false                    # Returns true (not (and true false))[0m[0m
[90mline 1460 <<: [33m#   nor false false                    # Returns false (not (or false false))[0m[0m
[90mline 1461 <<: [33m#   empty? nil                         # Returns true[0m[0m
[90mline 1462 <<: [33m#   empty? (cons 1 nil)                # Returns false[0m[0m
[90mline 1463 <<: [33m#   first (cons 1 (cons 2 nil))        # Returns 1[0m[0m
[90mline 1464 <<: [33m#   rest (cons 1 (cons 2 nil))         # Returns (cons 2 nil)[0m[0m
[90mline 1465 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1466 <<: [38;5;205m:macro (nand $a $b) => (not (and $a $b))[0m[0m
[34mMacro 'nand' defined successfully[0m
[0m [0m
[90mline 1467 <<: [38;5;205m:macro (nor $a $b) => (not (or $a $b))[0m[0m
[34mMacro 'nor' defined successfully[0m
[0m [0m
[90mline 1468 <<: [38;5;205m:macro (empty? $list) => (isnil $list) [0m[0m
[34mMacro 'empty?' defined successfully[0m
[0m [0m
[90mline 1469 <<: [38;5;205m:macro (rest $list) => (tail $list)[0m[0m
[34mMacro 'rest' defined successfully[0m
[0m [0m
[0mPROGRESS::84[0m
[90mline 1470 <<: [0m
[90mline 1471 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1472 <<: [33m# 9.4. Function Application Macros[0m[0m
[90mline 1473 <<: [33m#[0m[0m
[90mline 1474 <<: [33m# These macros provide convenient ways to compose and apply functions,[0m[0m
[90mline 1475 <<: [33m# fundamental operations in functional programming.[0m[0m
[90mline 1476 <<: [33m#[0m[0m
[90mline 1477 <<: [33m# FUNCTION COMPOSITION:[0m[0m
[90mline 1478 <<: [33m#   The compose macro creates function pipelines where the output of one[0m[0m
[90mline 1479 <<: [33m#   function becomes the input of another. This enables building complex[0m[0m
[90mline 1480 <<: [33m#   operations from simple components.[0m[0m
[90mline 1481 <<: [33m#[0m[0m
[90mline 1482 <<: [33m# REPEATED APPLICATION:[0m[0m
[90mline 1483 <<: [33m#   - apply_twice: Applies a function twice to its argument[0m[0m
[90mline 1484 <<: [33m#   - apply_n: Applies a function n times, enabling iteration patterns[0m[0m
[90mline 1485 <<: [33m#[0m[0m
[90mline 1486 <<: [33m# FUNCTIONAL PROGRAMMING PATTERNS:[0m[0m
[90mline 1487 <<: [33m#   These macros embody core functional programming principles:[0m[0m
[90mline 1488 <<: [33m#   - Composition over inheritance[0m[0m
[90mline 1489 <<: [33m#   - Building complexity through function combination[0m[0m
[90mline 1490 <<: [33m#   - Avoiding explicit iteration through repeated application[0m[0m
[90mline 1491 <<: [33m#[0m[0m
[90mline 1492 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1493 <<: [33m#   compose succ succ 5                # Returns 7 (increment twice)[0m[0m
[90mline 1494 <<: [33m#   apply_twice succ 5                 # Returns 7 (same as above)[0m[0m
[90mline 1495 <<: [33m#   apply_n succ 3 5                   # Returns 8 (increment three times)[0m[0m
[90mline 1496 <<: [33m#   [0m[0m
[90mline 1497 <<: [33m#   # More complex compositions[0m[0m
[90mline 1498 <<: [33m#   compose (mult 2) succ 5            # Returns 12 (succ(5) * 2)[0m[0m
[90mline 1499 <<: [33m#   apply_n (mult 2) 3 1               # Returns 8 (multiply by 2 three times)[0m[0m
[90mline 1500 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1501 <<: [38;5;205m:macro (compose $f $g $x) => ($f ($g $x))[0m[0m
[34mMacro 'compose' defined successfully[0m
[0m [0m
[90mline 1502 <<: [38;5;205m:macro (apply_twice $f $x) => ($f ($f $x))[0m[0m
[34mMacro 'apply_twice' defined successfully[0m
[0m [0m
[90mline 1503 <<: [38;5;205m:macro (apply_n $f $n $x) => (times $n $f $x)[0m[0m
[34mMacro 'apply_n' defined successfully[0m
[0m [0m
[90mline 1504 <<: [0m
[90mline 1505 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1506 <<: [33m# 9.5. Debugging and Assertion Macros[0m[0m
[90mline 1507 <<: [33m#[0m[0m
[90mline 1508 <<: [33m# These macros provide essential development and testing utilities for[0m[0m
[90mline 1509 <<: [33m# ensuring program correctness and facilitating debugging.[0m[0m
[90mline 1510 <<: [33m#[0m[0m
[90mline 1511 <<: [33m# ASSERTION MACRO:[0m[0m
[90mline 1512 <<: [33m#   The assert macro implements precondition checking by returning the value[0m[0m
[90mline 1513 <<: [33m#   if the condition is true, or triggering an error if false. This provides[0m[0m
[90mline 1514 <<: [33m#   runtime validation of program invariants.[0m[0m
[90mline 1515 <<: [33m#[0m[0m
[90mline 1516 <<: [33m# TESTING MACRO:[0m[0m
[90mline 1517 <<: [33m#   The test macro compares an expression result with an expected value,[0m[0m
[90mline 1518 <<: [33m#   forming the basis for unit testing in functional programs.[0m[0m
[90mline 1519 <<: [33m#[0m[0m
[90mline 1520 <<: [33m# DEVELOPMENT WORKFLOW:[0m[0m
[90mline 1521 <<: [33m#   These macros support test-driven development and defensive programming:[0m[0m
[90mline 1522 <<: [33m#   - Assertions catch invalid states early[0m[0m
[90mline 1523 <<: [33m#   - Tests verify function behavior[0m[0m
[90mline 1524 <<: [33m#   - Both provide documentation of expected behavior[0m[0m
[90mline 1525 <<: [33m#[0m[0m
[90mline 1526 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1527 <<: [33m#   assert (gt x 0) x                  # Ensures x is positive before using[0m[0m
[90mline 1528 <<: [33m#   assert (not (isnil l)) (head l)    # Ensures list not empty before head[0m[0m
[90mline 1529 <<: [33m#   [0m[0m
[90mline 1530 <<: [33m#   test (plus 2 3) 5                  # Returns true (2 + 3 = 5)[0m[0m
[90mline 1531 <<: [33m#   test (mult 4 5) 19                 # Returns false (4 * 5 â‰  19)[0m[0m
[90mline 1532 <<: [33m#   [0m[0m
[90mline 1533 <<: [33m#   # Function testing[0m[0m
[90mline 1534 <<: [33m#   test (factorial 5) 120             # Verify factorial correctness[0m[0m
[90mline 1535 <<: [33m#   test (fibonacci 7) 13              # Verify fibonacci correctness[0m[0m
[90mline 1536 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1537 <<: [38;5;205m:macro (assert $condition $value) => (if $condition $value error)[0m[0m
[34mMacro 'assert' defined successfully[0m
[0m [0m
[90mline 1538 <<: [38;5;205m:macro (test $expr $expected) => (eq $expr $expected)[0m[0m
[34mMacro 'test' defined successfully[0m
[0m [0m
[90mline 1539 <<: [0m
[90mline 1540 <<: [33m# Structural test macros (list, pair, maybe, either)[0m[0m
[90mline 1541 <<: [33m# These dispatch to the structural equality helpers with numeric element eq.[0m[0m
[90mline 1542 <<: [33m# For custom element equality supply your own macro or call helpers directly.[0m[0m
[90mline 1543 <<: [33m## NOTE: Hyphens in macro names can clash with minus parsing[0m[0m[32m;[0m[90m prefer camelCase.[0m
[90mline 1544 <<: [38;5;205m:macro (testList $a $b) => (listEq eq $a $b)[0m[0m
[34mMacro 'testList' defined successfully[0m
[0m [0m
[90mline 1545 <<: [38;5;205m:macro (testPair $a $b) => (pairEq eq eq $a $b)[0m[0m
[34mMacro 'testPair' defined successfully[0m
[0m [0m
[90mline 1546 <<: [38;5;205m:macro (testMaybe $a $b) => (maybeEq eq $a $b)[0m[0m
[34mMacro 'testMaybe' defined successfully[0m
[0m [0m
[90mline 1547 <<: [38;5;205m:macro (testEither $a $b) => (eitherEq eq eq $a $b)[0m[0m
[34mMacro 'testEither' defined successfully[0m
[0m [0m
[90mline 1548 <<: [0m
[90mline 1549 <<: [33m# Variants allowing custom element equality (supply eq function first)[0m[0m
[90mline 1550 <<: [38;5;205m:macro (testListBy $eqE $a $b) => (listEq $eqE $a $b)[0m[0m
[34mMacro 'testListBy' defined successfully[0m
[0m [0m
[90mline 1551 <<: [38;5;205m:macro (testPairBy $eqA $eqB $a $b) => (pairEq $eqA $eqB $a $b)[0m[0m
[34mMacro 'testPairBy' defined successfully[0m
[0m [0m
[90mline 1552 <<: [38;5;205m:macro (testMaybeBy $eqA $a $b) => (maybeEq $eqA $a $b)[0m[0m
[34mMacro 'testMaybeBy' defined successfully[0m
[0m [0m
[90mline 1553 <<: [38;5;205m:macro (testEitherBy $eqL $eqR $a $b) => (eitherEq $eqL $eqR $a $b)[0m[0m
[34mMacro 'testEitherBy' defined successfully[0m
[0m [0m
[90mline 1554 <<: [0m
[90mline 1555 <<: [0m
[90mline 1556 <<: [33m# =============================================================================[0m[0m
[90mline 1557 <<: [33m# SECTION 10: INFIX OPERATORS[0m[0m
[0mPROGRESS::89[0m
[90mline 1558 <<: [33m#[0m[0m
[90mline 1559 <<: [33m# This section defines infix operators for common arithmetic and logical[0m[0m
[90mline 1560 <<: [33m# operations to allow for more conventional mathematical notation.[0m[0m
[90mline 1561 <<: [33m# These operators transform lambda calculus into a more familiar syntax[0m[0m
[90mline 1562 <<: [33m# while maintaining the underlying functional semantics.[0m[0m
[90mline 1563 <<: [33m#[0m[0m
[90mline 1564 <<: [33m# INFIX NOTATION BENEFITS:[0m[0m
[90mline 1565 <<: [33m#   - Familiar mathematical syntax: 2 + 3 instead of (plus 2 3)[0m[0m
[90mline 1566 <<: [33m#   - Operator precedence: 2 + 3 * 4 correctly parsed as 2 + (3 * 4)[0m[0m
[90mline 1567 <<: [33m#   - Associativity rules: 2 - 3 - 4 correctly parsed as (2 - 3) - 4[0m[0m
[90mline 1568 <<: [33m#   - Improved readability for mathematical expressions[0m[0m
[90mline 1569 <<: [33m#[0m[0m
[90mline 1570 <<: [33m# PRECEDENCE LEVELS:[0m[0m
[90mline 1571 <<: [33m#   Higher numbers bind tighter (evaluated first):[0m[0m
[90mline 1572 <<: [33m#   8: ^ (exponentiation)[0m[0m
[90mline 1573 <<: [33m#   7: *, /, % (multiplication, division, modulo)[0m[0m
[90mline 1574 <<: [33m#   6: +, - (addition, subtraction)[0m[0m
[90mline 1575 <<: [33m#   5: <, <=, >, >= (comparisons)[0m[0m
[90mline 1576 <<: [33m#   4: ==, != (equality tests)[0m[0m
[90mline 1577 <<: [33m#   3: && (logical and)[0m[0m
[90mline 1578 <<: [33m#   2: || (logical or)[0m[0m
[90mline 1579 <<: [33m#[0m[0m
[90mline 1580 <<: [33m# ASSOCIATIVITY:[0m[0m
[90mline 1581 <<: [33m#   - left: Operations associate left-to-right[0m[0m
[90mline 1582 <<: [33m#   - right: Operations associate right-to-left (only ^ in this set)[0m[0m
[90mline 1583 <<: [33m# =============================================================================[0m[0m
[90mline 1584 <<: [0m
[90mline 1585 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1586 <<: [33m# 10.1. Arithmetic Infix Operators[0m[0m
[90mline 1587 <<: [33m#[0m[0m
[90mline 1588 <<: [33m# These operators provide standard mathematical notation for arithmetic[0m[0m
[90mline 1589 <<: [33m# operations, making mathematical expressions more intuitive and readable.[0m[0m
[90mline 1590 <<: [33m#[0m[0m
[90mline 1591 <<: [33m# OPERATOR DEFINITIONS:[0m[0m
[90mline 1592 <<: [33m#   Each operator is defined as an alias to the corresponding function:[0m[0m
[90mline 1593 <<: [33m#   + maps to plus, - to minus, * to mult, / to div, etc.[0m[0m
[90mline 1594 <<: [33m#[0m[0m
[90mline 1595 <<: [33m# PRECEDENCE AND ASSOCIATIVITY:[0m[0m
[90mline 1596 <<: [33m#   - Exponentiation (^): Highest precedence (8), right-associative[0m[0m
[90mline 1597 <<: [33m#   - Multiplication/Division/Modulo (*, /, %): Precedence 7, left-associative[0m[0m
[90mline 1598 <<: [33m#   - Addition/Subtraction (+, -): Precedence 6, left-associative[0m[0m
[90mline 1599 <<: [33m#[0m[0m
[90mline 1600 <<: [33m# MATHEMATICAL CORRECTNESS:[0m[0m
[90mline 1601 <<: [33m#   The precedence rules follow standard mathematical conventions:[0m[0m
[90mline 1602 <<: [33m#   2 + 3 * 4^2 evaluates as 2 + (3 * (4^2)) = 2 + (3 * 16) = 50[0m[0m
[90mline 1603 <<: [33m#[0m[0m
[90mline 1604 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1605 <<: [33m#   3 + 4 * 5                          # Returns 23 (not 35)[0m[0m
[90mline 1606 <<: [33m#   2^3^2                              # Returns 512 (2^(3^2) = 2^9)[0m[0m
[90mline 1607 <<: [33m#   10 / 2 + 3                         # Returns 8 ((10/2) + 3)[0m[0m
[90mline 1608 <<: [33m#   15 % 4 * 2                         # Returns 6 ((15%4) * 2)[0m[0m
[90mline 1609 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1610 <<: + = plus[0m
[32m-> + = Î»m.Î»n.Î»f.Î»x.m f (n f x)[0m
[0m [0m
[90mline 1611 <<: - = minus[0m
[32m-> - = Î»m.Î»n.n pred m[0m
[0m [0m
[90mline 1612 <<: * = mult[0m
[32m-> * = Î»m.Î»n.Î»f.m (n f)[0m
[0m [0m
[90mline 1613 <<: / = div[0m
[32m-> / = Î»m.Î»n.first (DIV_ITER false m n)[0m
[0m [0m
[90mline 1614 <<: ^ = exp[0m
[32m-> ^ = <thunk:(Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))) (Y (Î»f.Î»b.Î»n.if (iszero n) 1 (mult b (f b (pred n)))))>[0m
[0m [0m
[90mline 1615 <<: % = mod[0m
[32m-> % = Î»m.Î»n.second (DIV_ITER false m n)[0m
[0m [0m
[90mline 1616 <<: [38;5;205m:infix + 6 left[0m[0m
[0mInfix operator '+' defined with precedence 6 and left associativity[0m
[0m [0m
[90mline 1617 <<: [38;5;205m:infix - 6 left[0m[0m
[0mInfix operator '-' defined with precedence 6 and left associativity[0m
[0m [0m
[90mline 1618 <<: [38;5;205m:infix * 7 left[0m[0m
[0mInfix operator '*' defined with precedence 7 and left associativity[0m
[0m [0m
[90mline 1619 <<: [38;5;205m:infix / 7 left[0m[0m
[0mInfix operator '/' defined with precedence 7 and left associativity[0m
[0m [0m
[90mline 1620 <<: [38;5;205m:infix % 7 left[0m[0m
[0mInfix operator '%' defined with precedence 7 and left associativity[0m
[0m [0m
[90mline 1621 <<: [38;5;205m:infix ^ 8 right[0m[0m
[0mInfix operator '^' defined with precedence 8 and right associativity[0m
[0m [0m
[90mline 1622 <<: [0m
[90mline 1623 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1624 <<: [33m# 10.2. Logical and Comparison Infix Operators[0m[0m
[90mline 1625 <<: [33m#[0m[0m
[90mline 1626 <<: [33m# These operators provide familiar syntax for logical operations and[0m[0m
[90mline 1627 <<: [33m# comparisons, essential for conditional logic and control flow.[0m[0m
[90mline 1628 <<: [33m#[0m[0m
[90mline 1629 <<: [33m# LOGICAL OPERATORS:[0m[0m
[90mline 1630 <<: [33m#   && (and) and || (or) provide short-circuit boolean evaluation[0m[0m
[90mline 1631 <<: [33m#   with appropriate precedence (and binds tighter than or).[0m[0m
[90mline 1632 <<: [33m#[0m[0m
[90mline 1633 <<: [33m# COMPARISON OPERATORS:[0m[0m
[90mline 1634 <<: [33m#   ==, !=, <, <=, >, >= provide the complete set of comparison operations[0m[0m
[90mline 1635 <<: [33m#   with consistent precedence and left-associativity.[0m[0m
[90mline 1636 <<: [33m#[0m[0m
[90mline 1637 <<: [33m# PRECEDENCE RATIONALE:[0m[0m
[90mline 1638 <<: [33m#   The precedence follows programming language conventions:[0m[0m
[90mline 1639 <<: [33m#   - Comparisons bind tighter than logical operations[0m[0m
[90mline 1640 <<: [33m#   - And binds tighter than or (mimicking mathematical convention)[0m[0m
[90mline 1641 <<: [33m#   - Equality tests bind tighter than logical operations[0m[0m
[90mline 1642 <<: [33m#[0m[0m
[90mline 1643 <<: [33m# CHAINING COMPARISONS:[0m[0m
[90mline 1644 <<: [33m#   While syntactically possible, chaining comparisons like x < y < z[0m[0m
[0mPROGRESS::94[0m
[90mline 1645 <<: [33m#   may not behave as mathematically expected due to left-associativity.[0m[0m
[90mline 1646 <<: [33m#[0m[0m
[90mline 1647 <<: [33m# USAGE EXAMPLES:[0m[0m
[90mline 1648 <<: [33m#   x > 0 && x < 10                    # Range check[0m[0m
[90mline 1649 <<: [33m#   a == b || a == c                   # Multiple equality[0m[0m
[90mline 1650 <<: [33m#   x != 0 && y / x > 5                # Safe division with check[0m[0m
[90mline 1651 <<: [33m#   age >= 18 && age <= 65             # Age validation[0m[0m
[90mline 1652 <<: [33m#   isValid && count > 0               # Compound conditions[0m[0m
[90mline 1653 <<: [33m# -----------------------------------------------------------------------------[0m[0m
[90mline 1654 <<: && = and[0m
[32m-> && = Î»p.Î»q.p q false[0m
[0m [0m
[90mline 1655 <<: || = or[0m
[32m-> || = [true][0m
[0m [0m
[90mline 1656 <<: == = eq[0m
[32m-> == = Î»m.Î»n.and (leq m n) (leq n m)[0m
[0m [0m
[90mline 1657 <<: != = neq[0m
[32m-> != = Î»m.Î»n.not (eq m n)[0m
[0m [0m
[90mline 1658 <<: <  = lt[0m
[32m-> < = Î»m.Î»n.and (leq m n) (not (eq m n))[0m
[0m [0m
[90mline 1659 <<: <= = leq[0m
[32m-> <= = Î»m.Î»n.iszero (minus m n)[0m
[0m [0m
[90mline 1660 <<: >  = gt[0m
[32m-> > = Î»m.Î»n.not (leq m n)[0m
[0m [0m
[90mline 1661 <<: >= = geq[0m
[32m-> >= = Î»m.Î»n.not (lt m n)[0m
[0m [0m
[90mline 1662 <<: [38;5;205m:infix && 3 left[0m[0m
[0mInfix operator '&&' defined with precedence 3 and left associativity[0m
[0m [0m
[90mline 1663 <<: [38;5;205m:infix || 2 left[0m[0m
[0mInfix operator '||' defined with precedence 2 and left associativity[0m
[0m [0m
[90mline 1664 <<: [38;5;205m:infix == 4 left[0m[0m
[0mInfix operator '==' defined with precedence 4 and left associativity[0m
[0m [0m
[90mline 1665 <<: [38;5;205m:infix != 4 left[0m[0m
[0mInfix operator '!=' defined with precedence 4 and left associativity[0m
[0m [0m
[90mline 1666 <<: [38;5;205m:infix <  5 left[0m[0m
[0mInfix operator '<' defined with precedence 5 and left associativity[0m
[0m [0m
[90mline 1667 <<: [38;5;205m:infix <= 5 left[0m[0m
[0mInfix operator '<=' defined with precedence 5 and left associativity[0m
[0m [0m
[90mline 1668 <<: [38;5;205m:infix >  5 left[0m[0m
[0mInfix operator '>' defined with precedence 5 and left associativity[0m
[0m [0m
[90mline 1669 <<: [38;5;205m:infix >= 5 left[0m[0m
[0mInfix operator '>=' defined with precedence 5 and left associativity[0m
[0m [0m
[90mline 1670 <<: [0m
[90mline 1671 <<: [0m
[90mline 1672 <<: [33m# =============================================================================[0m[0m
[90mline 1673 <<: [33m# SECTION 11: DEPRECATED AND ALIASED FUNCTIONS[0m[0m
[90mline 1674 <<: [33m#[0m[0m
[90mline 1675 <<: [33m# This section contains functions that are duplicates, aliases, or less[0m[0m
[90mline 1676 <<: [33m# efficient versions of other functions in the library. They are commented out[0m[0m
[90mline 1677 <<: [33m# to reduce clutter but are kept for historical or educational reference.[0m[0m
[90mline 1678 <<: [33m#[0m[0m
[90mline 1679 <<: [33m# PURPOSE OF THIS SECTION:[0m[0m
[90mline 1680 <<: [33m#   - Historical preservation of alternative implementations[0m[0m
[90mline 1681 <<: [33m#   - Educational examples showing different approaches to same problems[0m[0m
[90mline 1682 <<: [33m#   - Aliases that provide familiar names from other programming languages[0m[0m
[90mline 1683 <<: [33m#   - Less efficient but more explicit implementations for learning[0m[0m
[90mline 1684 <<: [33m#[0m[0m
[90mline 1685 <<: [33m# CATEGORIES:[0m[0m
[90mline 1686 <<: [33m#   1. Aliases: Alternative names for existing functions[0m[0m
[90mline 1687 <<: [33m#   2. Redundant functions: Multiple implementations of same functionality[0m[0m
[90mline 1688 <<: [33m#   3. Y-combinator examples: Explicit recursive implementations[0m[0m
[90mline 1689 <<: [33m#   4. Less efficient versions: Direct but slower implementations[0m[0m
[90mline 1690 <<: [33m#[0m[0m
[90mline 1691 <<: [33m# EDUCATIONAL VALUE:[0m[0m
[90mline 1692 <<: [33m#   These implementations demonstrate:[0m[0m
[90mline 1693 <<: [33m#   - Multiple ways to solve the same problem[0m[0m
[90mline 1694 <<: [33m#   - Trade-offs between clarity and efficiency[0m[0m
[90mline 1695 <<: [33m#   - Evolution of function design and optimization[0m[0m
[90mline 1696 <<: [33m#   - Different naming conventions across programming paradigms[0m[0m
[90mline 1697 <<: [33m#[0m[0m
[90mline 1698 <<: [33m# USAGE NOTE:[0m[0m
[90mline 1699 <<: [33m#   These functions are commented out to avoid namespace pollution.[0m[0m
[90mline 1700 <<: [33m#   Uncomment individual functions if needed for specific use cases.[0m[0m
[90mline 1701 <<: [33m# =============================================================================[0m[0m
[90mline 1702 <<: [0m
[90mline 1703 <<: [33m# --- Aliases ---[0m[0m
[90mline 1704 <<: [33m# factorial = fact[0m[0m
[90mline 1705 <<: [33m# fibonacci = fib[0m[0m
[90mline 1706 <<: [33m# contains = elem[0m[0m
[90mline 1707 <<: [33m# indexOf  = elemIndex[0m[0m
[90mline 1708 <<: clamp    = Î»min max x.if (lt x min) min (if (gt x max) max x)[0m
[32m-> clamp = Î»min.Î»max.Î»x.if (lt x min) min (if (gt x max) max x)[0m
[0m [0m
[90mline 1709 <<: [33m# bounded  = clamp[0m[0m
[90mline 1710 <<: [33m# inrange  = between[0m[0m
[90mline 1711 <<: [33m# pow2     = Î»n.exp 2 n[0m[0m
[90mline 1712 <<: [33m# pow10    = Î»n.exp 10 n[0m[0m
[90mline 1713 <<: [0m
[90mline 1714 <<: [33m# --- Redundant or Less-Used ---[0m[0m
[90mline 1715 <<: [33m# second   = Î»l.head (tail l)[0m[0m
[90mline 1716 <<: [33m# third    = Î»l.head (tail (tail l))[0m[0m
[90mline 1717 <<: [33m# butlast  = Î»l.reverse (tail (reverse l))[0m[0m
[90mline 1718 <<: [33m# removeFirst = Î»x l.filter (Î»y.not (eq x y)) l[0m[0m
[90mline 1719 <<: [33m# count    = Î»x l.length (filter (eq x) l)[0m[0m
[90mline 1720 <<: [33m# singleton = Î»x.cons x nil[0m[0m
[90mline 1721 <<: [33m# doubleton = Î»x y.cons x (cons y nil)[0m[0m
[90mline 1722 <<: [33m# tripleton = Î»x y z.cons x (cons y (cons z nil))[0m[0m
[90mline 1723 <<: [33m# issingle = Î»l.and (not (isnil l)) (isnil (tail l))[0m[0m
[90mline 1724 <<: [33m# isdouble = Î»l.and (not (isnil l)) (and (not (isnil (tail l))) (isnil (tail (tail l))))[0m[0m
[90mline 1725 <<: [33m# scanl    = Î»f z l.reverse (foldl (Î»acc x.cons (f (head acc) x) acc) (cons z nil) l)[0m[0m
[90mline 1726 <<: [33m# scanr    = Î»f z l.foldr (Î»x acc.cons (f x (head acc)) acc) (cons z nil) l[0m[0m
[90mline 1727 <<: [33m# findIndex = Î»p l.foldl (Î»acc x.if (and (isnil acc) (p x)) (cons (length acc) nil) acc) nil l[0m[0m
[90mline 1728 <<: [33m# elemIndex = Î»x l.findIndex (eq x) l[0m[0m
[90mline 1729 <<: [33m# safeInit = Î»l.if (isnil l) nil (reverse (tail (reverse l)))[0m[0m
[90mline 1730 <<: [0m
[90mline 1731 <<: [33m# --- Recursive examples using Y-combinator and infix operators (less efficient) ---[0m[0m
[90mline 1732 <<: fibY       = Y (\f. \n. if (n <= 2) 1 ((f (n - 1)) + (f (n - 2))))[0m
[32m-> fibY = <thunk:(Î»f.Î»n.if (<= n 2) 1 (+ (f (- n 1)) (f (- n 2)))) (Y (Î»f.Î»n.if (<= n 2) 1 (+ (f (- n 1)) (f (- n 2)))))>[0m
[0m [0m
[0mPROGRESS::99[0m
[90mline 1733 <<: factY      = Y (\f. \n. if (n == 0) 1 (n * (f (n - 1))))[0m
[32m-> factY = <thunk:(Î»f.Î»n.if (== n false) 1 (* n (f (- n 1)))) (Y (Î»f.Î»n.if (== n false) 1 (* n (f (- n 1)))))>[0m
[0m [0m
[90mline 1734 <<: sumUptoY   = Y (\f. \n. if (n == 0) 0 (n + (f (n - 1))))[0m
[32m-> sumUptoY = <thunk:(Î»f.Î»n.if (== n false) false (+ n (f (- n 1)))) (Y (Î»f.Î»n.if (== n false) false (+ n (f (- n 1)))))>[0m
[0m [0m
[90mline 1735 <<: expY       = Y (\f. \b n. if (n == 0) 1 (b * (f b (n - 1))))[0m
[32m-> expY = <thunk:(Î»f.Î»b.Î»n.if (== n false) 1 (* b (f b (- n 1)))) (Y (Î»f.Î»b.Î»n.if (== n false) 1 (* b (f b (- n 1)))))>[0m
[0m [0m
[90mline 1736 <<: rangeY     = \n. Y (\f k. if (k == n) nil (cons k (f (k + 1)))) 0[0m
[32m-> rangeY = Î»n.Y (Î»f.Î»k.if (== k n) [] (cons k (f (+ k 1)))) false[0m
[0m [0m
[90mline 1737 <<: countdownY = \n. Y (\f k. if (k == 0) (cons 0 nil) (cons k (f (k - 1)))) n[0m
[32m-> countdownY = Î»n.Y (Î»f.Î»k.if (== k false) ([false]) (cons k (f (- k 1)))) n[0m
[0m [0m
[90mline 1738 <<: gcdY       = Y (\f. \a b. if (b == 0) a (f b (a % b)))[0m
[32m-> gcdY = <thunk:(Î»f.Î»a.Î»b.if (== b false) a (f b (% a b))) (Y (Î»f.Î»a.Î»b.if (== b false) a (f b (% a b))))>[0m
[0m [0m
[90mline 1739 <<: lcmY       = Y (\f. \a b. if (a == 0 || b == 0) 0 ((a * b) / (gcdY a b)))[0m
[32m-> lcmY = <thunk:(Î»f.Î»a.Î»b.if (|| (== a false) (== b false)) false (/ (* a b) (gcdY a b))) (Y (Î»f.Î»a.Î»b.if (|| (== a false) (== b false)) false (/ (* a b) (gcdY a b))))>[0m
[0m [0m
[90mline 1740 <<: mapY       = Y (\f. \g l. if (isnil l) nil (cons (g (head l)) (f g (tail l))))[0m
[32m-> mapY = <thunk:(Î»f.Î»g.Î»l.if (isnil l) [] (cons (g (head l)) (f g (tail l)))) (Y (Î»f.Î»g.Î»l.if (isnil l) [] (cons (g (head l)) (f g (tail l)))))>[0m
[0m [0m
[90mline 1741 <<: filterY    = Y (\f. \p l. if (isnil l) nil (if (p (head l)) (cons (head l) (f p (tail l))) (f p (tail l))))[0m
[32m-> filterY = <thunk:(Î»f.Î»p.Î»l.if (isnil l) [] (if (p (head l)) (cons (head l) (f p (tail l))) (f p (tail l)))) (Y (Î»f.Î»p.Î»l.if (isnil l) [] (if (p (head l)) (cons (head l) (f p (tail l))) (f p (tail l)))))>[0m
[0m [0m
[90mline 1742 <<: lengthY    = Y (\f. \l. if (isnil l) 0 (1 + (f (tail l))))[0m
[32m-> lengthY = <thunk:(Î»f.Î»l.if (isnil l) false (+ 1 (f (tail l)))) (Y (Î»f.Î»l.if (isnil l) false (+ 1 (f (tail l)))))>[0m
[0m [0m
[90mline 1743 <<: reverseY   = \l. Y (\f l acc. if (isnil l) acc (f (tail l) (cons (head l) acc))) l nil[0m
[32m-> reverseY = Î»l.Y (Î»f.Î»l.Î»acc.if (isnil l) acc (f (tail l) (cons (head l) acc))) l [][0m
[0m [0m
[90mline 1744 <<: sumY       = Y (\f. \l. if (isnil l) 0 ((head l) + (f (tail l))))[0m
[32m-> sumY = <thunk:(Î»f.Î»l.if (isnil l) false (+ (head l) (f (tail l)))) (Y (Î»f.Î»l.if (isnil l) false (+ (head l) (f (tail l)))))>[0m
[0m [0m
[90mline 1745 <<: productY   = Y (\f. \l. if (isnil l) 1 ((head l) * (f (tail l))))[0m
[32m-> productY = <thunk:(Î»f.Î»l.if (isnil l) 1 (* (head l) (f (tail l)))) (Y (Î»f.Î»l.if (isnil l) 1 (* (head l) (f (tail l)))))>[0m
[0m [0m
[90mline 1746 <<: anyY       = Y (\f. \p l. if (isnil l) false (or (p (head l)) (f p (tail l))))[0m
[32m-> anyY = <thunk:(Î»f.Î»p.Î»l.if (isnil l) false (or (p (head l)) (f p (tail l)))) (Y (Î»f.Î»p.Î»l.if (isnil l) false (or (p (head l)) (f p (tail l)))))>[0m
[0m [0m
[90mline 1747 <<: allY       = Y (\f. \p l. if (isnil l) true (and (p (head l)) (f p (tail l))))[0m
[32m-> allY = <thunk:(Î»f.Î»p.Î»l.if (isnil l) true (and (p (head l)) (f p (tail l)))) (Y (Î»f.Î»p.Î»l.if (isnil l) true (and (p (head l)) (f p (tail l)))))>[0m
[0m [0m
[90mline 1748 <<: findY      = Y (\f. \p l. if (isnil l) nil (if (p (head l)) (head l) (f p (tail l))))[0m
[32m-> findY = <thunk:(Î»f.Î»p.Î»l.if (isnil l) [] (if (p (head l)) (head l) (f p (tail l)))) (Y (Î»f.Î»p.Î»l.if (isnil l) [] (if (p (head l)) (head l) (f p (tail l)))))>[0m
[0m [0m
[90mline 1749 <<: [0m
[0mPROGRESS::100[0m
[0mLoaded file 'stdlib.lambda' lines=1750 time=164.8 ms[0m
[36mLoading commands from 'tests.lambda'[0m
[90mline 0 <<: [33m# =========================================================================[0m[0m
[90mline 1 <<: [33m# Structural Equality Test Suite (auto-converted from tests.lambda)[0m[0m
[90mline 2 <<: [33m# Each prior test:  expr  # expect VALUE  ==>  alphaEq expr VALUE[0m[0m
[90mline 3 <<: [33m# Loads stdlib.lambda first[0m[0m[32m;[0m[90m then load this file: [38;5;205m:load struct-tests.lambda[0m[0m
[90mline 4 <<: [33m# NOTE:[0m[0m
[90mline 5 <<: [33m#   - Some descriptive expectations (e.g., words/unwords textual forms) kept as comments[0m[0m
[90mline 6 <<: [33m#   - Ambiguous expectations were converted where a reasonable canonical form exists[0m[0m
[90mline 7 <<: [33m# =========================================================================[0m[0m
[90mline 8 <<: [0m
[90mline 9 <<: [38;5;205m:test clear[0m[0m
[0mTest counters cleared (structural equality).[0m
[0m [0m
[90mline 10 <<: [38;5;205m:clear cache[0m[0m
[0mAll caches cleared.[0m
[0m [0m
[90mline 11 <<: [0m
[90mline 12 <<: [33m# --- Boolean Logic ---[0m[0m
[90mline 13 <<: alphaEq (true 1 0) 1[0m
[35mEval: alphaEq (true 1 false) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 1/1 (100.00%)[0m
[34mTime: 1.7 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 14 <<: alphaEq (false 1 0) 0[0m
[35mEval: alphaEq (false 1 false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 2/2 (100.00%)[0m
[34mTime: 0.7 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 15 <<: alphaEq (not true) false[0m
[35mEval: alphaEq (not true) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 3/3 (100.00%)[0m
[34mTime: 0.3 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 16 <<: alphaEq (not false) true[0m
[35mEval: alphaEq (not false) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 4/4 (100.00%)[0m
[34mTime: 0.3 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 17 <<: alphaEq (and true true) true[0m
[35mEval: alphaEq (and true true) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 5/5 (100.00%)[0m
[34mTime: 0.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 18 <<: alphaEq (and true false) false[0m
[35mEval: alphaEq (and true false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 6/6 (100.00%)[0m
[34mTime: 0.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 19 <<: alphaEq (or true false) true[0m
[35mEval: alphaEq (or true false) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 7/7 (100.00%)[0m
[34mTime: 0.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 20 <<: alphaEq (xor true true) false[0m
[35mEval: alphaEq (xor true true) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 8/8 (100.00%)[0m
[34mTime: 0.4 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 21 <<: alphaEq (if true 42 99) 42[0m
[35mEval: alphaEq (if true 42 99) 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 9/9 (100.00%)[0m
[34mTime: 15.3 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 22 <<: alphaEq (if false 42 99) 99[0m
[35mEval: alphaEq (if false 42 99) 99[0m
[35mAlpha left:  99[0m
[35mAlpha right: 99[0m
[32mAlpha passed - 10/10 (100.00%)[0m
[34mTime: 19.3 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 23 <<: alphaEq (eqBool true true) true[0m
[35mEval: alphaEq (eqBool true true) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 11/11 (100.00%)[0m
[34mTime: 0.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 24 <<: alphaEq (eqBool true false) false[0m
[35mEval: alphaEq (eqBool true false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 12/12 (100.00%)[0m
[34mTime: 0.4 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 25 <<: [0m
[90mline 26 <<: [33m# --- Church Numerals ---[0m[0m
[90mline 27 <<: alphaEq (zero (Î»x.1) 0) 0[0m
[35mEval: alphaEq (zero (Î»x.1) false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 13/13 (100.00%)[0m
[34mTime: 0.7 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 28 <<: alphaEq (succ (succ zero)) 2[0m
[35mEval: alphaEq (succ (succ zero)) 2[0m
[35mAlpha left:  2[0m
[35mAlpha right: 2[0m
[32mAlpha passed - 14/14 (100.00%)[0m
[34mTime: 1.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 29 <<: alphaEq (plus 2 3) 5[0m
[35mEval: alphaEq (plus 2 3) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 15/15 (100.00%)[0m
[34mTime: 1.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 30 <<: alphaEq (mult 3 4) 12[0m
[35mEval: alphaEq (mult 3 4) 12[0m
[35mAlpha left:  12[0m
[35mAlpha right: 12[0m
[32mAlpha passed - 16/16 (100.00%)[0m
[34mTime: 2.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 31 <<: alphaEq (pred 3) 2[0m
[35mEval: alphaEq (pred 3) 2[0m
[35mAlpha left:  2[0m
[35mAlpha right: 2[0m
[32mAlpha passed - 17/17 (100.00%)[0m
[34mTime: 0.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::4[0m
[90mline 32 <<: alphaEq (minus 5 2) 3[0m
[35mEval: alphaEq (minus 5 2) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 18/18 (100.00%)[0m
[34mTime: 1.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 33 <<: alphaEq (iszero 0) true[0m
[35mEval: alphaEq (iszero false) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 19/19 (100.00%)[0m
[34mTime: 0.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 34 <<: alphaEq (iszero 1) false[0m
[35mEval: alphaEq (iszero 1) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 20/20 (100.00%)[0m
[34mTime: 0.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 35 <<: alphaEq (exp 2 3) 8[0m
[35mEval: alphaEq (exp 2 3) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 21/21 (100.00%)[0m
[34mTime: 1.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 36 <<: [0m
[90mline 37 <<: [33m# --- Division and Modulo ---[0m[0m
[90mline 38 <<: alphaEq (div 7 2) 3[0m
[35mEval: alphaEq (div 7 2) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 22/22 (100.00%)[0m
[34mTime: 1.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 39 <<: alphaEq (mod 7 2) 1[0m
[35mEval: alphaEq (mod 7 2) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 23/23 (100.00%)[0m
[34mTime: 1.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 40 <<: [0m
[90mline 41 <<: [33m# --- Comparisons ---[0m[0m
[90mline 42 <<: alphaEq (leq 2 3) true[0m
[35mEval: alphaEq (leq 2 3) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 24/24 (100.00%)[0m
[34mTime: 1.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 43 <<: alphaEq (leq 3 2) false[0m
[35mEval: alphaEq (leq 3 2) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 25/25 (100.00%)[0m
[34mTime: 0.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 44 <<: alphaEq (eq 4 4) true[0m
[35mEval: alphaEq (eq 4 4) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 26/26 (100.00%)[0m
[34mTime: 1.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 45 <<: alphaEq (eq 4 5) false[0m
[35mEval: alphaEq (eq 4 5) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 27/27 (100.00%)[0m
[34mTime: 1.2 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 46 <<: alphaEq (gt 5 2) true[0m
[35mEval: alphaEq (gt 5 2) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 28/28 (100.00%)[0m
[34mTime: 1.0 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 47 <<: alphaEq (lt 2 5) true[0m
[35mEval: alphaEq (lt 2 5) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 29/29 (100.00%)[0m
[34mTime: 1.5 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 48 <<: alphaEq (neq 2 2) false[0m
[35mEval: alphaEq (neq 2 2) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 30/30 (100.00%)[0m
[34mTime: 0.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 49 <<: alphaEq (neq 2 3) true[0m
[35mEval: alphaEq (neq 2 3) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 31/31 (100.00%)[0m
[34mTime: 0.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 50 <<: [0m
[90mline 51 <<: [33m# --- Numeric Operations ---[0m[0m
[90mline 52 <<: alphaEq (max 3 7) 7[0m
[35mEval: alphaEq (max 3 7) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 32/32 (100.00%)[0m
[34mTime: 1.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 53 <<: alphaEq (min 3 7) 3[0m
[35mEval: alphaEq (min 3 7) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 33/33 (100.00%)[0m
[34mTime: 2.0 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 54 <<: alphaEq (even 4) true[0m
[35mEval: alphaEq (even 4) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 34/34 (100.00%)[0m
[34mTime: 0.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 55 <<: alphaEq (odd 5) true[0m
[35mEval: alphaEq (odd 5) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 35/35 (100.00%)[0m
[34mTime: 0.7 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 56 <<: alphaEq (square 6) 36[0m
[34mMacro  0 square in   square 6[0m
[34mMacro  0        out  mult 6 6[0m
[34mMacro  0 square done mult 6 6[0m
[35mEval: alphaEq (mult 6 6) 36[0m
[35mAlpha left:  36[0m
[35mAlpha right: 36[0m
[32mAlpha passed - 36/36 (100.00%)[0m
[34mTime: 6.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 57 <<: alphaEq (double 8) 16[0m
[35mEval: alphaEq (double 8) 16[0m
[35mAlpha left:  16[0m
[35mAlpha right: 16[0m
[32mAlpha passed - 37/37 (100.00%)[0m
[34mTime: 2.3 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 58 <<: alphaEq (half 9) 4[0m
[35mEval: alphaEq (half 9) 4[0m
[35mAlpha left:  4[0m
[35mAlpha right: 4[0m
[32mAlpha passed - 38/38 (100.00%)[0m
[34mTime: 1.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 59 <<: alphaEq (pow 2 5) 32[0m
[35mEval: alphaEq (pow 2 5) 32[0m
[35mAlpha left:  32[0m
[35mAlpha right: 32[0m
[32mAlpha passed - 39/39 (100.00%)[0m
[34mTime: 3.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 60 <<: [0m
[90mline 61 <<: [33m# --- List Operations ---[0m[0m
[90mline 62 <<: alphaEq nil nil[0m
[35mEval: alphaEq [] [][0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 40/40 (100.00%)[0m
[34mTime: 0.2 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 63 <<: alphaEq (isnil nil) true[0m
[35mEval: alphaEq (isnil []) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 41/41 (100.00%)[0m
[34mTime: 0.3 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 64 <<: alphaEq (isnil (cons 1 nil)) false[0m
[35mEval: alphaEq (isnil ([1])) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 42/42 (100.00%)[0m
[34mTime: 0.7 ms, iterations: 39[0m
[32m-> true[0m
[0m [0m
[90mline 65 <<: alphaEq (cons 1 (cons 2 (cons 3 nil))) [1,2,3][0m
[35mEval: alphaEq ([1, 2, 3]) ([1, 2, 3])[0m
[35mAlpha left:  [1, 2, 3][0m
[35mAlpha right: [1, 2, 3][0m
[32mAlpha passed - 43/43 (100.00%)[0m
[34mTime: 3.7 ms, iterations: 27[0m
[32m-> true[0m
[0m [0m
[90mline 66 <<: alphaEq (head (cons 1 (cons 2 (cons 3 nil)))) 1[0m
[35mEval: alphaEq (head ([1, 2, 3])) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 44/44 (100.00%)[0m
[34mTime: 1.8 ms, iterations: 63[0m
[32m-> true[0m
[0m [0m
[90mline 67 <<: alphaEq (tail (cons 1 (cons 2 (cons 3 nil)))) [2,3][0m
[35mEval: alphaEq (tail ([1, 2, 3])) ([2, 3])[0m
[35mAlpha left:  [2, 3][0m
[35mAlpha right: [2, 3][0m
[32mAlpha passed - 45/45 (100.00%)[0m
[34mTime: 2.9 ms, iterations: 183[0m
[32m-> true[0m
[0m [0m
[90mline 68 <<: alphaEq (length (cons 1 (cons 2 (cons 3 nil)))) 3[0m
[35mEval: alphaEq (length ([1, 2, 3])) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 46/46 (100.00%)[0m
[34mTime: 1.8 ms, iterations: 75[0m
[32m-> true[0m
[0m [0m
[90mline 69 <<: alphaEq (reverse (cons 1 (cons 2 (cons 3 nil)))) [3,2,1][0m
[35mEval: alphaEq (reverse ([1, 2, 3])) ([3, 2, 1])[0m
[35mAlpha left:  [3, 2, 1][0m
[35mAlpha right: [3, 2, 1][0m
[32mAlpha passed - 47/47 (100.00%)[0m
[34mTime: 3.3 ms, iterations: 155[0m
[32m-> true[0m
[0m [0m
[90mline 70 <<: alphaEq (append (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil))) [1,2,3,4,5][0m
[35mEval: alphaEq (append ([1, 2, 3]) ([4, 5])) ([1, 2, 3, 4, 5])[0m
[35mAlpha left:  [1, 2, 3, 4, 5][0m
[35mAlpha right: [1, 2, 3, 4, 5][0m
[32mAlpha passed - 48/48 (100.00%)[0m
[34mTime: 5.2 ms, iterations: 107[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::9[0m
[90mline 71 <<: alphaEq (map succ (cons 1 (cons 2 (cons 3 nil)))) [2,3,4][0m
[35mEval: alphaEq (map succ ([1, 2, 3])) ([2, 3, 4])[0m
[35mAlpha left:  [2, 3, 4][0m
[35mAlpha right: [2, 3, 4][0m
[32mAlpha passed - 49/49 (100.00%)[0m
[34mTime: 3.2 ms, iterations: 127[0m
[32m-> true[0m
[0m [0m
[90mline 72 <<: alphaEq (filter even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) [2,4][0m
[35mEval: alphaEq (filter even ([1, 2, 3, 4])) ([2, 4])[0m
[35mAlpha left:  [2, 4][0m
[35mAlpha right: [2, 4][0m
[32mAlpha passed - 50/50 (100.00%)[0m
[34mTime: 4.2 ms, iterations: 139[0m
[32m-> true[0m
[0m [0m
[90mline 73 <<: alphaEq (foldr plus 0 (cons 1 (cons 2 (cons 3 nil)))) 6[0m
[35mEval: alphaEq (foldr plus false ([1, 2, 3])) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 51/51 (100.00%)[0m
[34mTime: 2.5 ms, iterations: 71[0m
[32m-> true[0m
[0m [0m
[90mline 74 <<: alphaEq (foldl plus 0 (cons 1 (cons 2 (cons 3 nil)))) 6[0m
[35mEval: alphaEq (foldl plus false ([1, 2, 3])) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 52/52 (100.00%)[0m
[34mTime: 2.3 ms, iterations: 111[0m
[32m-> true[0m
[0m [0m
[90mline 75 <<: [0m
[90mline 76 <<: [33m# --- Advanced List Operations ---[0m[0m
[90mline 77 <<: alphaEq (range 5) [0,1,2,3,4][0m
[35mEval: alphaEq (range 5) ([false, 1, 2, 3, 4])[0m
[35mAlpha left:  [false, 1, 2, 3, 4][0m
[35mAlpha right: [false, 1, 2, 3, 4][0m
[32mAlpha passed - 53/53 (100.00%)[0m
[34mTime: 4.5 ms, iterations: 107[0m
[32m-> true[0m
[0m [0m
[90mline 78 <<: alphaEq (countdown 3) [3,2,1,0][0m
[35mEval: alphaEq (countdown 3) ([3, 2, 1, false])[0m
[35mAlpha left:  [3, 2, 1, false][0m
[35mAlpha right: [3, 2, 1, false][0m
[32mAlpha passed - 54/54 (100.00%)[0m
[34mTime: 2.1 ms, iterations: 109[0m
[32m-> true[0m
[0m [0m
[90mline 79 <<: alphaEq (zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil))) (zip (cons 1 (cons 2 (cons 3 nil))) (cons 4 (cons 5 nil)))  [33m# structural tuple pairs may need dedicated eq[0m[0m[32m;[0m[90m kept identity[0m
[35mEval: alphaEq (zip ([1, 2, 3]) ([4, 5])) (zip ([1, 2, 3]) ([4, 5]))[0m
[35mAlpha left:  [Î»f.f 1 4, Î»f.f 2 5][0m
[35mAlpha right: [Î»f.f 1 4, Î»f.f 2 5][0m
[32mAlpha passed - 55/55 (100.00%)[0m
[35mEval: kept identity[0m
[34mTime: 6.6 ms, iterations: 591[0m
[32m-> true
-> kept identity[0m
[0m [0m
[90mline 80 <<: alphaEq (concat (cons (cons 1 (cons 2 (cons 3 nil))) (cons (cons 4 nil) nil))) [1,2,3,4][0m
[35mEval: alphaEq (concat ([[1, 2, 3], [4]])) ([1, 2, 3, 4])[0m
[35mAlpha left:  [1, 2, 3, 4][0m
[35mAlpha right: [1, 2, 3, 4][0m
[32mAlpha passed - 56/56 (100.00%)[0m
[34mTime: 4.4 ms, iterations: 155[0m
[32m-> true[0m
[0m [0m
[90mline 81 <<: [0m
[90mline 82 <<: [33m# --- Combinators and Utilities ---[0m[0m
[90mline 83 <<: alphaEq (K 42 99) 42[0m
[35mEval: alphaEq (K 42 99) 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 57/57 (100.00%)[0m
[34mTime: 14.4 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 84 <<: alphaEq (I 77) 77[0m
[35mEval: alphaEq (I 77) 77[0m
[35mAlpha left:  77[0m
[35mAlpha right: 77[0m
[32mAlpha passed - 58/58 (100.00%)[0m
[34mTime: 12.2 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 85 <<: alphaEq (S (K succ) (K 3) 0) 4[0m
[35mEval: alphaEq (S (K succ) (K 3) false) 4[0m
[35mAlpha left:  4[0m
[35mAlpha right: 4[0m
[32mAlpha passed - 59/59 (100.00%)[0m
[34mTime: 1.5 ms, iterations: 35[0m
[32m-> true[0m
[0m [0m
[90mline 86 <<: alphaEq (B succ succ 1) 3[0m
[35mEval: alphaEq (B succ succ 1) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 60/60 (100.00%)[0m
[34mTime: 0.9 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 87 <<: alphaEq (C minus 5 2) 0[0m
[35mEval: alphaEq (C minus 5 2) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 61/61 (100.00%)[0m
[34mTime: 1.3 ms, iterations: 51[0m
[32m-> true[0m
[0m [0m
[90mline 88 <<: [0m
[90mline 89 <<: [33m# --- Recursion and Advanced Functions ---[0m[0m
[90mline 90 <<: alphaEq (fact 5) 120[0m
[35mEval: alphaEq (fact 5) 120[0m
[35mAlpha left:  120[0m
[35mAlpha right: 120[0m
[32mAlpha passed - 62/62 (100.00%)[0m
[34mTime: 12.9 ms, iterations: 323[0m
[32m-> true[0m
[0m [0m
[90mline 91 <<: alphaEq (fib 7) 13[0m
[35mEval: alphaEq (fib 7) 13[0m
[35mAlpha left:  13[0m
[35mAlpha right: 13[0m
[32mAlpha passed - 63/63 (100.00%)[0m
[34mTime: 3.0 ms, iterations: 367[0m
[32m-> true[0m
[0m [0m
[90mline 92 <<: alphaEq (gcd 18 24) 6[0m
[35mEval: alphaEq (gcd 18 24) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 64/64 (100.00%)[0m
[34mTime: 4.5 ms, iterations: 54[0m
[32m-> true[0m
[0m [0m
[90mline 93 <<: alphaEq (lcm 6 8) 24[0m
[35mEval: alphaEq (lcm 6 8) 24[0m
[35mAlpha left:  24[0m
[35mAlpha right: 24[0m
[32mAlpha passed - 65/65 (100.00%)[0m
[34mTime: 7.7 ms, iterations: 485[0m
[32m-> true[0m
[0m [0m
[90mline 94 <<: [0m
[90mline 95 <<: [33m# --- Infix Operators ---[0m[0m
[90mline 96 <<: alphaEq (2 + 3) 5[0m
[35mEval: alphaEq (+ 2 3) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 66/66 (100.00%)[0m
[34mTime: 1.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 97 <<: alphaEq (7 - 4) 3[0m
[35mEval: alphaEq (- 7 4) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 67/67 (100.00%)[0m
[34mTime: 1.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 98 <<: alphaEq (3 * 4) 12[0m
[35mEval: alphaEq (* 3 4) 12[0m
[35mAlpha left:  12[0m
[35mAlpha right: 12[0m
[32mAlpha passed - 68/68 (100.00%)[0m
[34mTime: 2.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 99 <<: alphaEq (9 / 2) 4[0m
[35mEval: alphaEq (/ 9 2) 4[0m
[35mAlpha left:  4[0m
[35mAlpha right: 4[0m
[32mAlpha passed - 69/69 (100.00%)[0m
[34mTime: 1.7 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 100 <<: alphaEq (9 % 4) 1[0m
[35mEval: alphaEq (% 9 4) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 70/70 (100.00%)[0m
[34mTime: 1.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 101 <<: alphaEq (2 ^ 4) 16[0m
[35mEval: alphaEq (^ 2 4) 16[0m
[35mAlpha left:  16[0m
[35mAlpha right: 16[0m
[32mAlpha passed - 71/71 (100.00%)[0m
[34mTime: 2.2 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 102 <<: alphaEq (true && false) false[0m
[35mEval: alphaEq (&& true false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 72/72 (100.00%)[0m
[34mTime: 0.6 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 103 <<: alphaEq (false || true) true[0m
[35mEval: alphaEq (|| false true) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 73/73 (100.00%)[0m
[34mTime: 0.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 104 <<: alphaEq (5 == 5) true[0m
[35mEval: alphaEq (== 5 5) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 74/74 (100.00%)[0m
[34mTime: 1.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 105 <<: alphaEq (5 != 4) true[0m
[35mEval: alphaEq (!= 5 4) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 75/75 (100.00%)[0m
[34mTime: 1.1 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 106 <<: alphaEq (2 < 3) true[0m
[35mEval: alphaEq (< 2 3) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 76/76 (100.00%)[0m
[34mTime: 0.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 107 <<: alphaEq (2 <= 2) true[0m
[35mEval: alphaEq (<= 2 2) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 77/77 (100.00%)[0m
[34mTime: 1.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 108 <<: alphaEq (4 > 3) true[0m
[35mEval: alphaEq (> 4 3) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 78/78 (100.00%)[0m
[34mTime: 1.0 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 109 <<: alphaEq (4 >= 4) true[0m
[35mEval: alphaEq (>= 4 4) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 79/79 (100.00%)[0m
[34mTime: 1.1 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 110 <<: [0m
[0mPROGRESS::14[0m
[90mline 111 <<: [33m# --- Maybe/Optional Type ---[0m[0m
[90mline 112 <<: alphaEq (just 42) (just 42)[0m
[35mEval: alphaEq (just 42) (just 42)[0m
[35mAlpha left:  Î»f.f (true) 42[0m
[35mAlpha right: Î»f.f (true) 42[0m
[32mAlpha passed - 80/80 (100.00%)[0m
[34mTime: 6.8 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 113 <<: alphaEq nothing nil[0m
[35mEval: alphaEq nothing [][0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 81/81 (100.00%)[0m
[34mTime: 0.2 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 114 <<: alphaEq (isJust (just 1)) true[0m
[35mEval: alphaEq (isJust (just 1)) true[0m
[35mAlpha left:  Î»y.y[0m
[35mAlpha right: true[0m
[31mAlpha failed - 1/82 (1.22%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 0.6 ms, iterations: 51[0m
[32m-> false[0m
[0m [0m
[90mline 115 <<: alphaEq (isNothing nothing) true[0m
[35mEval: alphaEq (isNothing nothing) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 82/83 (98.80%)[0m
[34mTime: 0.4 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 116 <<: alphaEq (fromJust (just 7)) 7[0m
[35mEval: alphaEq (fromJust (just 7)) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 83/84 (98.81%)[0m
[34mTime: 1.8 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 117 <<: alphaEq (fromMaybe 99 (just 5)) 5[0m
[35mEval: alphaEq (fromMaybe 99 (just 5)) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 84/85 (98.82%)[0m
[34mTime: 9.0 ms, iterations: 61[0m
[32m-> true[0m
[0m [0m
[90mline 118 <<: alphaEq (fromMaybe 99 nothing) 99[0m
[35mEval: alphaEq (fromMaybe 99 nothing) 99[0m
[35mAlpha left:  99[0m
[35mAlpha right: 99[0m
[32mAlpha passed - 85/86 (98.84%)[0m
[34mTime: 15.4 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 119 <<: alphaEq (maybe 0 succ (just 3)) 4[0m
[35mEval: alphaEq (maybe false succ (just 3)) 4[0m
[35mAlpha left:  4[0m
[35mAlpha right: 4[0m
[32mAlpha passed - 86/87 (98.85%)[0m
[34mTime: 1.3 ms, iterations: 69[0m
[32m-> true[0m
[0m [0m
[90mline 120 <<: alphaEq (maybe 0 succ nothing) 0[0m
[35mEval: alphaEq (maybe false succ nothing) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 87/88 (98.86%)[0m
[34mTime: 0.6 ms, iterations: 29[0m
[32m-> true[0m
[0m [0m
[90mline 121 <<: [0m
[90mline 122 <<: [33m# --- Either Type ---[0m[0m
[90mline 123 <<: alphaEq (left 1) (left 1)[0m
[35mEval: alphaEq (left 1) (left 1)[0m
[35mAlpha left:  Î»f.f false 1[0m
[35mAlpha right: Î»f.f false 1[0m
[32mAlpha passed - 88/89 (98.88%)[0m
[34mTime: 0.7 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 124 <<: alphaEq (right 2) (right 2)[0m
[35mEval: alphaEq (right 2) (right 2)[0m
[35mAlpha left:  Î»f.f (true) 2[0m
[35mAlpha right: Î»f.f (true) 2[0m
[32mAlpha passed - 89/90 (98.89%)[0m
[34mTime: 0.8 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 125 <<: alphaEq (isLeft (left 5)) true[0m
[35mEval: alphaEq (isLeft (left 5)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 90/91 (98.90%)[0m
[34mTime: 1.0 ms, iterations: 47[0m
[32m-> true[0m
[0m [0m
[90mline 126 <<: alphaEq (isRight (right 6)) true[0m
[35mEval: alphaEq (isRight (right 6)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 91/92 (98.91%)[0m
[34mTime: 0.9 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 127 <<: alphaEq (either succ pred (left 10)) 11[0m
[35mEval: alphaEq (either succ pred (left 10)) 11[0m
[35mAlpha left:  11[0m
[35mAlpha right: 11[0m
[32mAlpha passed - 92/93 (98.92%)[0m
[34mTime: 2.3 ms, iterations: 81[0m
[32m-> true[0m
[0m [0m
[90mline 128 <<: alphaEq (either succ pred (right 10)) 9[0m
[35mEval: alphaEq (either succ pred (right 10)) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 93/94 (98.94%)[0m
[34mTime: 2.6 ms, iterations: 81[0m
[32m-> true[0m
[0m [0m
[90mline 129 <<: [0m
[90mline 130 <<: [33m# --- Tree Data Structure ---[0m[0m
[90mline 131 <<: alphaEq (leaf 7) (leaf 7)[0m
[35mEval: alphaEq (leaf 7) (leaf 7)[0m
[35mAlpha left:  Î»f.f 7 (Î»f.f false false)[0m
[35mAlpha right: Î»f.f 7 (Î»f.f false false)[0m
[32mAlpha passed - 94/95 (98.95%)[0m
[34mTime: 1.6 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 132 <<: alphaEq (node 1 (leaf 2) (leaf 3)) (node 1 (leaf 2) (leaf 3))[0m
[35mEval: alphaEq (node 1 (leaf 2) (leaf 3)) (node 1 (leaf 2) (leaf 3))[0m
[35mAlpha left:  Î»f.f 1 (Î»f.f (Î»f.f 2 (Î»f.f false false)) (Î»f.f 3 (Î»f.f false false)))[0m
[35mAlpha right: Î»f.f 1 (Î»f.f (Î»f.f 2 (Î»f.f false false)) (Î»f.f 3 (Î»f.f false false)))[0m
[32mAlpha passed - 95/96 (98.96%)[0m
[34mTime: 2.6 ms, iterations: 55[0m
[32m-> true[0m
[0m [0m
[90mline 133 <<: alphaEq (treeValue (leaf 8)) 8[0m
[35mEval: alphaEq (treeValue (leaf 8)) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 96/97 (98.97%)[0m
[34mTime: 1.7 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 134 <<: alphaEq (treeLeft (node 1 (leaf 2) (leaf 3))) (leaf 2)[0m
[35mEval: alphaEq (treeLeft (node 1 (leaf 2) (leaf 3))) (leaf 2)[0m
[35mAlpha left:  Î»f.f 2 (Î»f.f false false)[0m
[35mAlpha right: Î»f.f 2 (Î»f.f false false)[0m
[32mAlpha passed - 97/98 (98.98%)[0m
[34mTime: 1.7 ms, iterations: 39[0m
[32m-> true[0m
[0m [0m
[90mline 135 <<: alphaEq (treeRight (node 1 (leaf 2) (leaf 3))) (leaf 3)[0m
[35mEval: alphaEq (treeRight (node 1 (leaf 2) (leaf 3))) (leaf 3)[0m
[35mAlpha left:  Î»f.f 3 (Î»f.f false false)[0m
[35mAlpha right: Î»f.f 3 (Î»f.f false false)[0m
[32mAlpha passed - 98/99 (98.99%)[0m
[34mTime: 2.0 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 136 <<: alphaEq (isLeaf (leaf 9)) true[0m
[35mEval: alphaEq (isLeaf (leaf 9)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 99/100 (99.00%)[0m
[34mTime: 1.3 ms, iterations: 115[0m
[32m-> true[0m
[0m [0m
[90mline 137 <<: alphaEq (isLeaf (node 1 (leaf 2) (leaf 3))) false[0m
[35mEval: alphaEq (isLeaf (node 1 (leaf 2) (leaf 3))) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 100/101 (99.01%)[0m
[34mTime: 1.4 ms, iterations: 103[0m
[32m-> true[0m
[0m [0m
[90mline 138 <<: [0m
[90mline 139 <<: [33m# --- zipWith, scan*, find, partition, splitAt ---[0m[0m
[90mline 140 <<: alphaEq (zipWith plus (cons 1 (cons 2 nil)) (cons 10 (cons 20 nil))) [11,22][0m
[35mEval: alphaEq (zipWith plus ([1, 2]) ([10, 20])) ([11, 22])[0m
[35mAlpha left:  [11, 22][0m
[35mAlpha right: [11, 22][0m
[32mAlpha passed - 101/102 (99.02%)[0m
[34mTime: 11.1 ms, iterations: 695[0m
[32m-> true[0m
[0m [0m
[90mline 141 <<: alphaEq (scanl plus 0 (cons 1 (cons 2 (cons 3 nil)))) [0,1,3,6][0m
[35mEval: alphaEq (scanl plus false ([1, 2, 3])) ([false, 1, 3, 6])[0m
[35mAlpha left:  [false, 1, 3, 6][0m
[35mAlpha right: [false, 1, 3, 6][0m
[32mAlpha passed - 102/103 (99.03%)[0m
[34mTime: 5.2 ms, iterations: 459[0m
[32m-> true[0m
[0m [0m
[90mline 142 <<: alphaEq (scanr plus 0 (cons 1 (cons 2 (cons 3 nil)))) [6,5,3,0][0m
[35mEval: alphaEq (scanr plus false ([1, 2, 3])) ([6, 5, 3, false])[0m
[35mAlpha left:  [6, 5, 3, false][0m
[35mAlpha right: [6, 5, 3, false][0m
[32mAlpha passed - 103/104 (99.04%)[0m
[34mTime: 4.7 ms, iterations: 211[0m
[32m-> true[0m
[0m [0m
[90mline 143 <<: alphaEq (find (eq 2) (cons 1 (cons 2 (cons 3 nil)))) 2[0m
[35mEval: alphaEq (find (eq 2) ([1, 2, 3])) 2[0m
[35mAlpha left:  2[0m
[35mAlpha right: 2[0m
[32mAlpha passed - 104/105 (99.05%)[0m
[34mTime: 2.5 ms, iterations: 257[0m
[32m-> true[0m
[0m [0m
[90mline 144 <<: alphaEq (partition even (cons 1 (cons 2 (cons 3 (cons 4 nil))))) (partition even (cons 1 (cons 2 (cons 3 (cons 4 nil)))))  [33m# complex tuple result[0m[0m[32m;[0m[90m identity check[0m
[35mEval: alphaEq (partition even ([1, 2, 3, 4])) (partition even ([1, 2, 3, 4]))[0m
[35mAlpha left:  Î»f.f ([2, 4]) ([1, 3])[0m
[35mAlpha right: Î»f.f ([2, 4]) ([1, 3])[0m
[32mAlpha passed - 105/106 (99.06%)[0m
[35mEval: identity check[0m
[34mTime: 4.8 ms, iterations: 237[0m
[32m-> true
-> identity check[0m
[0m [0m
[90mline 145 <<: alphaEq (splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))) (splitAt 2 (cons 1 (cons 2 (cons 3 (cons 4 nil)))))[0m
[35mEval: alphaEq (splitAt 2 ([1, 2, 3, 4])) (splitAt 2 ([1, 2, 3, 4]))[0m
[35mAlpha left:  Î»f.f ([1, 2]) ([3, 4])[0m
[35mAlpha right: Î»f.f ([1, 2]) ([3, 4])[0m
[32mAlpha passed - 106/107 (99.07%)[0m
[34mTime: 5.4 ms, iterations: 547[0m
[32m-> true[0m
[0m [0m
[90mline 146 <<: [0m
[90mline 147 <<: [33m# --- Edge Cases and Safe Functions ---[0m[0m
[90mline 148 <<: alphaEq (safeMinimum nil) nothing[0m
[35mEval: alphaEq (safeMinimum []) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 107/108 (99.07%)[0m
[34mTime: 0.4 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 149 <<: alphaEq (safeMaximum nil) nothing[0m
[35mEval: alphaEq (safeMaximum []) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 108/109 (99.08%)[0m
[34mTime: 0.5 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::19[0m
[90mline 150 <<: alphaEq (safeMinimum (cons 3 (cons 1 (cons 2 nil)))) (just 1)[0m
[35mEval: alphaEq (safeMinimum ([3, 1, 2])) (just 1)[0m
[35mAlpha left:  Î»f.f (true) 1[0m
[35mAlpha right: Î»f.f (true) 1[0m
[32mAlpha passed - 109/110 (99.09%)[0m
[34mTime: 2.8 ms, iterations: 253[0m
[32m-> true[0m
[0m [0m
[90mline 151 <<: alphaEq (safeMaximum (cons 3 (cons 1 (cons 2 nil)))) (just 3)[0m
[35mEval: alphaEq (safeMaximum ([3, 1, 2])) (just 3)[0m
[35mAlpha left:  Î»f.f (true) 3[0m
[35mAlpha right: Î»f.f (true) 3[0m
[32mAlpha passed - 110/111 (99.10%)[0m
[34mTime: 2.0 ms, iterations: 119[0m
[32m-> true[0m
[0m [0m
[90mline 152 <<: alphaEq (clamp 2 4 1) 2[0m
[35mEval: alphaEq (clamp 2 4 1) 2[0m
[35mAlpha left:  2[0m
[35mAlpha right: 2[0m
[32mAlpha passed - 111/112 (99.11%)[0m
[34mTime: 1.8 ms, iterations: 17[0m
[32m-> true[0m
[0m [0m
[90mline 153 <<: alphaEq (clamp 2 4 3) 3[0m
[35mEval: alphaEq (clamp 2 4 3) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 112/113 (99.12%)[0m
[34mTime: 1.6 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 154 <<: alphaEq (clamp 2 4 5) 4[0m
[35mEval: alphaEq (clamp 2 4 5) 4[0m
[35mAlpha left:  4[0m
[35mAlpha right: 4[0m
[32mAlpha passed - 113/114 (99.12%)[0m
[34mTime: 1.8 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 155 <<: [0m
[90mline 156 <<: [33m# --- Miscellaneous ---[0m[0m
[90mline 157 <<: alphaEq (compose succ succ 1) 3[0m
[34mMacro  0 compose in   compose succ succ 1[0m
[34mMacro  0         out  succ (succ 1)[0m
[34mMacro  0 compose done succ (succ 1)[0m
[35mEval: alphaEq (succ (succ 1)) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 114/115 (99.13%)[0m
[34mTime: 0.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 158 <<: alphaEq (flip minus 2 5) 3[0m
[35mEval: alphaEq (flip minus 2 5) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 115/116 (99.14%)[0m
[34mTime: 1.7 ms, iterations: 39[0m
[32m-> true[0m
[0m [0m
[90mline 159 <<: alphaEq (on plus succ 2 3) 7[0m
[35mEval: alphaEq (on plus succ 2 3) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 116/117 (99.15%)[0m
[34mTime: 2.0 ms, iterations: 27[0m
[32m-> true[0m
[0m [0m
[90mline 160 <<: alphaEq (apply succ 4) 5[0m
[35mEval: alphaEq (apply succ 4) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 117/118 (99.15%)[0m
[34mTime: 1.2 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 161 <<: alphaEq (partial plus 2 3) 5[0m
[35mEval: alphaEq (partial plus 2 3) 5[0m
[35mAlpha left:  3[0m
[35mAlpha right: 5[0m
[31mAlpha failed - 2/119 (1.68%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 1.7 ms, iterations: 5[0m
[32m-> false[0m
[0m [0m
[90mline 162 <<: alphaEq (partial2 plus 2 3 4) 1024[0m
[35mEval: alphaEq (partial2 plus 2 3 4) 1024[0m
[35mAlpha left:  1024[0m
[35mAlpha right: 1024[0m
[32mAlpha passed - 118/120 (98.33%)[0m
[34mTime: 98.5 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 163 <<: alphaEq (memoize succ 10) 11[0m
[35mEval: alphaEq (memoize succ 10) 11[0m
[35mAlpha left:  11[0m
[35mAlpha right: 11[0m
[32mAlpha passed - 119/121 (98.35%)[0m
[34mTime: 2.2 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 164 <<: alphaEq (id2 123) 123[0m
[35mEval: alphaEq (id2 123) 123[0m
[35mAlpha left:  123[0m
[35mAlpha right: 123[0m
[32mAlpha passed - 120/122 (98.36%)[0m
[34mTime: 20.9 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 165 <<: alphaEq (const2 7 8) 7[0m
[35mEval: alphaEq (const2 7 8) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 121/123 (98.37%)[0m
[34mTime: 2.3 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 166 <<: [0m
[90mline 167 <<: [33m# --- Additional List Operations ---[0m[0m
[90mline 168 <<: alphaEq (take 3 (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))) [1,2,3][0m
[35mEval: alphaEq (take 3 ([1, 2, 3, 4, 5])) ([1, 2, 3])[0m
[35mAlpha left:  [1, 2, 3][0m
[35mAlpha right: [1, 2, 3][0m
[32mAlpha passed - 122/124 (98.39%)[0m
[34mTime: 5.1 ms, iterations: 565[0m
[32m-> true[0m
[0m [0m
[90mline 169 <<: alphaEq (drop 2 (cons 1 (cons 2 (cons 3 (cons 4 nil))))) [3,4][0m
[35mEval: alphaEq (drop 2 ([1, 2, 3, 4])) ([3, 4])[0m
[35mAlpha left:  [3, 4][0m
[35mAlpha right: [3, 4][0m
[32mAlpha passed - 123/125 (98.40%)[0m
[34mTime: 3.9 ms, iterations: 39[0m
[32m-> true[0m
[0m [0m
[90mline 170 <<: alphaEq (nth 2 (cons 10 (cons 20 (cons 30 (cons 40 nil))))) 30[0m
[35mEval: alphaEq (nth 2 ([10, 20, 30, 40])) 30[0m
[35mAlpha left:  30[0m
[35mAlpha right: 30[0m
[32mAlpha passed - 124/126 (98.41%)[0m
[34mTime: 12.2 ms, iterations: 335[0m
[32m-> true[0m
[0m [0m
[90mline 171 <<: alphaEq (any (Î»x.gt x 3) (cons 1 (cons 2 (cons 5 nil)))) true[0m
[35mEval: alphaEq (any (Î»x.gt x 3) ([1, 2, 5])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 125/127 (98.43%)[0m
[34mTime: 2.6 ms, iterations: 155[0m
[32m-> true[0m
[0m [0m
[90mline 172 <<: alphaEq (all even (cons 2 (cons 4 (cons 6 nil)))) true[0m
[35mEval: alphaEq (all even ([2, 4, 6])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 126/128 (98.44%)[0m
[34mTime: 2.2 ms, iterations: 147[0m
[32m-> true[0m
[0m [0m
[90mline 173 <<: alphaEq (all even (cons 2 (cons 3 (cons 6 nil)))) false[0m
[35mEval: alphaEq (all even ([2, 3, 6])) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 127/129 (98.45%)[0m
[34mTime: 2.1 ms, iterations: 95[0m
[32m-> true[0m
[0m [0m
[90mline 174 <<: alphaEq (sum (cons 1 (cons 2 (cons 3 (cons 4 nil))))) 10[0m
[35mEval: alphaEq (sum ([1, 2, 3, 4])) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 128/130 (98.46%)[0m
[34mTime: 2.8 ms, iterations: 83[0m
[32m-> true[0m
[0m [0m
[90mline 175 <<: alphaEq (product (cons 2 (cons 3 (cons 4 nil)))) 24[0m
[35mEval: alphaEq (product ([2, 3, 4])) 24[0m
[35mAlpha left:  24[0m
[35mAlpha right: 24[0m
[32mAlpha passed - 129/131 (98.47%)[0m
[34mTime: 3.7 ms, iterations: 75[0m
[32m-> true[0m
[0m [0m
[90mline 176 <<: alphaEq (maximum (cons 1 (cons 5 (cons 3 (cons 2 nil))))) 5[0m
[35mEval: alphaEq (maximum ([1, 5, 3, 2])) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 130/132 (98.48%)[0m
[34mTime: 5.6 ms, iterations: 97[0m
[32m-> true[0m
[0m [0m
[90mline 177 <<: alphaEq (minimum (cons 4 (cons 1 (cons 3 (cons 2 nil))))) 1[0m
[35mEval: alphaEq (minimum ([4, 1, 3, 2])) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 131/133 (98.50%)[0m
[34mTime: 2.7 ms, iterations: 297[0m
[32m-> true[0m
[0m [0m
[90mline 178 <<: [0m
[90mline 179 <<: [33m# --- Advanced List Utilities ---[0m[0m
[90mline 180 <<: alphaEq (elem 3 (cons 1 (cons 2 (cons 3 nil)))) true[0m
[35mEval: alphaEq (elem 3 ([1, 2, 3])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 132/134 (98.51%)[0m
[34mTime: 2.6 ms, iterations: 199[0m
[32m-> true[0m
[0m [0m
[90mline 181 <<: alphaEq (elem 5 (cons 1 (cons 2 (cons 3 nil)))) false[0m
[35mEval: alphaEq (elem 5 ([1, 2, 3])) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 133/135 (98.52%)[0m
[34mTime: 2.3 ms, iterations: 199[0m
[32m-> true[0m
[0m [0m
[90mline 182 <<: alphaEq (notElem 5 (cons 1 (cons 2 (cons 3 nil)))) true[0m
[35mEval: alphaEq (notElem 5 ([1, 2, 3])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 134/136 (98.53%)[0m
[34mTime: 2.3 ms, iterations: 83[0m
[32m-> true[0m
[0m [0m
[90mline 183 <<: alphaEq (nub (cons 1 (cons 2 (cons 1 (cons 3 (cons 2 nil)))))) [3, 2, 1][0m
[35mEval: alphaEq (nub ([1, 2, 1, 3, 2])) ([3, 2, 1])[0m
[35mAlpha left:  [3, 2, 1][0m
[35mAlpha right: [3, 2, 1][0m
[32mAlpha passed - 135/137 (98.54%)[0m
[34mTime: 4.8 ms, iterations: 685[0m
[32m-> true[0m
[0m [0m
[90mline 184 <<: alphaEq (unique (cons 1 (cons 2 (cons 1 (cons 3 nil))))) [3, 2, 1][0m
[35mEval: alphaEq (unique ([1, 2, 1, 3])) ([3, 2, 1])[0m
[35mAlpha left:  [3, 2, 1][0m
[35mAlpha right: [3, 2, 1][0m
[32mAlpha passed - 136/138 (98.55%)[0m
[34mTime: 3.0 ms, iterations: 127[0m
[32m-> true[0m
[0m [0m
[90mline 185 <<: alphaEq (last (cons 1 (cons 2 (cons 3 nil)))) 3[0m
[35mEval: alphaEq (last ([1, 2, 3])) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 137/139 (98.56%)[0m
[34mTime: 2.0 ms, iterations: 107[0m
[32m-> true[0m
[0m [0m
[90mline 186 <<: alphaEq (init (cons 1 (cons 2 (cons 3 nil)))) [1,2][0m
[35mEval: alphaEq (init ([1, 2, 3])) ([1, 2])[0m
[35mAlpha left:  [1, 2][0m
[35mAlpha right: [1, 2][0m
[32mAlpha passed - 138/140 (98.57%)[0m
[34mTime: 2.4 ms, iterations: 247[0m
[32m-> true[0m
[0m [0m
[90mline 187 <<: alphaEq (safeInit nil) nil[0m
[35mEval: alphaEq (safeInit []) [][0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 139/141 (98.58%)[0m
[34mTime: 0.4 ms, iterations: 65[0m
[32m-> true[0m
[0m [0m
[90mline 188 <<: alphaEq (safeInit (cons 1 nil)) nil[0m
[35mEval: alphaEq (safeInit ([1])) [][0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 140/142 (98.59%)[0m
[34mTime: 0.7 ms, iterations: 101[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::24[0m
[90mline 189 <<: alphaEq (safeDiv 10 2) (just 5)[0m
[35mEval: alphaEq (safeDiv 10 2) (just 5)[0m
[35mAlpha left:  Î»f.f (true) 5[0m
[35mAlpha right: Î»f.f (true) 5[0m
[32mAlpha passed - 141/143 (98.60%)[0m
[34mTime: 2.3 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 190 <<: alphaEq (safeDiv 10 0) nothing[0m
[35mEval: alphaEq (safeDiv 10 false) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 142/144 (98.61%)[0m
[34mTime: 1.2 ms, iterations: 13[0m
[32m-> true[0m
[0m [0m
[90mline 191 <<: alphaEq (safeInitMaybe nil) nothing[0m
[35mEval: alphaEq (safeInitMaybe []) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 143/145 (98.62%)[0m
[34mTime: 0.3 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 192 <<: alphaEq (safeInitMaybe (cons 1 nil)) nothing[0m
[35mEval: alphaEq (safeInitMaybe ([1])) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 144/146 (98.63%)[0m
[34mTime: 0.6 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 193 <<: alphaEq (safeInitMaybe (cons 1 (cons 2 nil))) (just [1])[0m
[35mEval: alphaEq (safeInitMaybe ([1, 2])) (just ([1]))[0m
[35mAlpha left:  Î»f.f (true) ([1])[0m
[35mAlpha right: Î»f.f (true) ([1])[0m
[32mAlpha passed - 145/147 (98.64%)[0m
[34mTime: 1.7 ms, iterations: 197[0m
[32m-> true[0m
[0m [0m
[90mline 194 <<: alphaEq (safeInit (cons 1 (cons 2 nil))) [1][0m
[35mEval: alphaEq (safeInit ([1, 2])) ([1])[0m
[35mAlpha left:  [1][0m
[35mAlpha right: [1][0m
[32mAlpha passed - 146/148 (98.65%)[0m
[34mTime: 1.3 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 195 <<: alphaEq (safeInitMaybe (cons 1 (cons 2 (cons 3 nil)))) (just [1,2])[0m
[35mEval: alphaEq (safeInitMaybe ([1, 2, 3])) (just ([1, 2]))[0m
[35mAlpha left:  Î»f.f (true) ([1, 2])[0m
[35mAlpha right: Î»f.f (true) ([1, 2])[0m
[32mAlpha passed - 147/149 (98.66%)[0m
[34mTime: 2.4 ms, iterations: 113[0m
[32m-> true[0m
[0m [0m
[90mline 196 <<: alphaEq (safeDiv 10 2) (safediv 10 2)[0m
[35mEval: alphaEq (safeDiv 10 2) (safediv 10 2)[0m
[35mAlpha left:  Î»f.f (true) 5[0m
[35mAlpha right: Î»f.f (true) 5[0m
[32mAlpha passed - 148/150 (98.67%)[0m
[34mTime: 2.8 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 197 <<: [0m
[90mline 198 <<: [33m# --- Enumeration and Range Functions ---[0m[0m
[90mline 199 <<: alphaEq (enumFromTo 3 7) [3,4,5,6,7][0m
[35mEval: alphaEq (enumFromTo 3 7) ([3, 4, 5, 6, 7])[0m
[35mAlpha left:  [3, 4, 5, 6, 7][0m
[35mAlpha right: [3, 4, 5, 6, 7][0m
[32mAlpha passed - 149/151 (98.68%)[0m
[34mTime: 4.9 ms, iterations: 230[0m
[32m-> true[0m
[0m [0m
[90mline 200 <<: alphaEq (enumFrom 5 4) [5,6,7,8][0m
[35mEval: alphaEq (enumFrom 5 4) ([5, 6, 7, 8])[0m
[35mAlpha left:  [5, 6, 7, 8][0m
[35mAlpha right: [5, 6, 7, 8][0m
[32mAlpha passed - 150/152 (98.68%)[0m
[34mTime: 4.8 ms, iterations: 256[0m
[32m-> true[0m
[0m [0m
[90mline 201 <<: alphaEq (iota 4) [0,1,2,3][0m
[35mEval: alphaEq (iota 4) ([false, 1, 2, 3])[0m
[35mAlpha left:  [false, 1, 2, 3][0m
[35mAlpha right: [false, 1, 2, 3][0m
[32mAlpha passed - 151/153 (98.69%)[0m
[34mTime: 2.0 ms, iterations: 30[0m
[32m-> true[0m
[0m [0m
[90mline 202 <<: alphaEq (replicate 3 7) [7,7,7][0m
[35mEval: alphaEq (replicate 3 7) ([7, 7, 7])[0m
[35mAlpha left:  [7, 7, 7][0m
[35mAlpha right: [7, 7, 7][0m
[32mAlpha passed - 152/154 (98.70%)[0m
[34mTime: 3.8 ms, iterations: 71[0m
[32m-> true[0m
[0m [0m
[90mline 203 <<: alphaEq (repeat 3 9) [9,9,9][0m
[35mEval: alphaEq (repeat 3 9) ([9, 9, 9])[0m
[35mAlpha left:  [9, 9, 9][0m
[35mAlpha right: [9, 9, 9][0m
[32mAlpha passed - 153/155 (98.71%)[0m
[34mTime: 4.3 ms, iterations: 79[0m
[32m-> true[0m
[0m [0m
[90mline 204 <<: [0m
[90mline 205 <<: [33m# --- Iteration and Application ---[0m[0m
[90mline 206 <<: alphaEq (iterate succ 5 0) 5[0m
[35mEval: alphaEq (iterate succ 5 false) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 154/156 (98.72%)[0m
[34mTime: 1.4 ms, iterations: 43[0m
[32m-> true[0m
[0m [0m
[90mline 207 <<: alphaEq (times 3 succ 0) 3[0m
[35mEval: alphaEq (times 3 succ false) 3[0m
[35mAlpha left:  false[0m
[35mAlpha right: 3[0m
[31mAlpha failed - 3/157 (1.91%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 1.1 ms, iterations: 5[0m
[32m-> false[0m
[0m [0m
[90mline 208 <<: alphaEq (when true succ 5) 6[0m
[34mMacro  0 when in   when true succ[0m
[34mMacro  0      out  if true succ I[0m
[34mMacro  0 when done if true succ I[0m
[35mEval: alphaEq (if true succ I 5) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 155/158 (98.10%)[0m
[34mTime: 2.1 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 209 <<: alphaEq (when false succ 5) 5[0m
[34mMacro  0 when in   when false succ[0m
[34mMacro  0      out  if false succ I[0m
[34mMacro  0 when done if false succ I[0m
[35mEval: alphaEq (if false succ I 5) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 156/159 (98.11%)[0m
[34mTime: 1.4 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 210 <<: alphaEq (unless true succ 5) 5[0m
[34mMacro  0 unless in   unless true succ[0m
[34mMacro  0        out  if true I succ[0m
[34mMacro  0 unless done if true I succ[0m
[35mEval: alphaEq (if true I succ 5) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 157/160 (98.12%)[0m
[34mTime: 1.4 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 211 <<: alphaEq (unless false succ 5) 6[0m
[34mMacro  0 unless in   unless false succ[0m
[34mMacro  0        out  if false I succ[0m
[34mMacro  0 unless done if false I succ[0m
[35mEval: alphaEq (if false I succ 5) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 158/161 (98.14%)[0m
[34mTime: 1.8 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 212 <<: alphaEq (cond true 42 99) 42[0m
[35mEval: alphaEq (cond true 42 99) 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 159/162 (98.15%)[0m
[34mTime: 14.1 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 213 <<: [0m
[90mline 214 <<: [33m# --- Pair Operations ---[0m[0m
[90mline 215 <<: alphaEq (pair 1 2) (pair 1 2)[0m
[35mEval: alphaEq (pair 1 2) (pair 1 2)[0m
[35mAlpha left:  Î»f.f 1 2[0m
[35mAlpha right: Î»f.f 1 2[0m
[32mAlpha passed - 160/163 (98.16%)[0m
[34mTime: 1.5 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 216 <<: alphaEq (first (pair 10 20)) 10[0m
[35mEval: alphaEq (first (pair 10 20)) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 161/164 (98.17%)[0m
[34mTime: 3.6 ms, iterations: 27[0m
[32m-> true[0m
[0m [0m
[90mline 217 <<: alphaEq (second (pair 10 20)) 20[0m
[35mEval: alphaEq (second (pair 10 20)) 20[0m
[35mAlpha left:  20[0m
[35mAlpha right: 20[0m
[32mAlpha passed - 162/165 (98.18%)[0m
[34mTime: 4.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 218 <<: alphaEq (swap (pair 1 2)) (pair 2 1)[0m
[35mEval: alphaEq (swap (pair 1 2)) (pair 2 1)[0m
[35mAlpha left:  Î»f.f 2 1[0m
[35mAlpha right: Î»f.f 2 1[0m
[32mAlpha passed - 163/166 (98.19%)[0m
[34mTime: 1.5 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 219 <<: [0m
[90mline 220 <<: [33m# --- Advanced Numeric Functions ---[0m[0m
[90mline 221 <<: alphaEq (abs 5) 5[0m
[35mEval: alphaEq (abs 5) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 164/167 (98.20%)[0m
[34mTime: 1.3 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 222 <<: alphaEq (sqrt 16) 4[0m
[35mEval: alphaEq (sqrt 16) 4[0m
[35mAlpha left:  4[0m
[35mAlpha right: 4[0m
[32mAlpha passed - 165/168 (98.21%)[0m
[34mTime: 1.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 223 <<: alphaEq (sqrt 25) 5[0m
[35mEval: alphaEq (sqrt 25) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 166/169 (98.22%)[0m
[34mTime: 2.7 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 224 <<: alphaEq (isPrime 7) true[0m
[35mEval: alphaEq (isPrime 7) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 167/170 (98.24%)[0m
[34mTime: 1.2 ms, iterations: 43[0m
[32m-> true[0m
[0m [0m
[90mline 225 <<: alphaEq (isPrime 8) false[0m
[35mEval: alphaEq (isPrime 8) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 168/171 (98.25%)[0m
[34mTime: 1.1 ms, iterations: 29[0m
[32m-> true[0m
[0m [0m
[90mline 226 <<: alphaEq (isPrime 2) true[0m
[35mEval: alphaEq (isPrime 2) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 169/172 (98.26%)[0m
[34mTime: 0.6 ms, iterations: 27[0m
[32m-> true[0m
[0m [0m
[90mline 227 <<: alphaEq (isPrime 1) false[0m
[35mEval: alphaEq (isPrime 1) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 170/173 (98.27%)[0m
[34mTime: 0.5 ms, iterations: 16[0m
[32m-> true[0m
[0m [0m
[90mline 228 <<: alphaEq (primes 10) [2,3,5,7][0m
[35mEval: alphaEq (primes 10) ([2, 3, 5, 7])[0m
[35mAlpha left:  [2, 3, 5, 7][0m
[35mAlpha right: [2, 3, 5, 7][0m
[32mAlpha passed - 171/174 (98.28%)[0m
[34mTime: 70.3 ms, iterations: 24,002[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::29[0m
[90mline 229 <<: [0m
[90mline 230 <<: [33m# --- String/Character Operations ---[0m[0m
[90mline 231 <<: [33m# words / unwords expectations left descriptive due to encoding specifics[0m[0m
[90mline 232 <<: [33m# words (cons 104 (cons 101 (cons 108 (cons 108 (cons 111 nil)))))[0m[0m
[90mline 233 <<: [33m# unwords (cons (cons 104 (cons 105 nil)) (cons (cons 121 (cons 111 nil)) nil))[0m[0m
[90mline 234 <<: [0m
[90mline 235 <<: [33m# --- Set Operations on Lists ---[0m[0m
[90mline 236 <<: alphaEq (union (cons 1 (cons 2 nil)) (cons 2 (cons 3 nil))) [1,2,3][0m
[35mEval: alphaEq (union ([1, 2]) ([2, 3])) ([1, 2, 3])[0m
[35mAlpha left:  [1, 2, 3][0m
[35mAlpha right: [1, 2, 3][0m
[32mAlpha passed - 172/175 (98.29%)[0m
[34mTime: 4.4 ms, iterations: 351[0m
[32m-> true[0m
[0m [0m
[90mline 237 <<: alphaEq (intersect (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 3 (cons 4 nil)))) [2,3][0m
[35mEval: alphaEq (intersect ([1, 2, 3]) ([2, 3, 4])) ([2, 3])[0m
[35mAlpha left:  [2, 3][0m
[35mAlpha right: [2, 3][0m
[32mAlpha passed - 173/176 (98.30%)[0m
[34mTime: 5.0 ms, iterations: 561[0m
[32m-> true[0m
[0m [0m
[90mline 238 <<: alphaEq (difference (cons 1 (cons 2 (cons 3 nil))) (cons 2 (cons 4 nil))) [1,3][0m
[35mEval: alphaEq (difference ([1, 2, 3]) ([2, 4])) ([1, 3])[0m
[35mAlpha left:  [1, 3][0m
[35mAlpha right: [1, 3][0m
[32mAlpha passed - 174/177 (98.31%)[0m
[34mTime: 4.3 ms, iterations: 349[0m
[32m-> true[0m
[0m [0m
[90mline 239 <<: alphaEq (isSubset (cons 1 (cons 2 nil)) (cons 1 (cons 2 (cons 3 nil)))) true[0m
[35mEval: alphaEq (isSubset ([1, 2]) ([1, 2, 3])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 175/178 (98.31%)[0m
[34mTime: 2.7 ms, iterations: 359[0m
[32m-> true[0m
[0m [0m
[90mline 240 <<: alphaEq (isSuperset (cons 1 (cons 2 (cons 3 nil))) (cons 1 (cons 2 nil))) true[0m
[35mEval: alphaEq (isSuperset ([1, 2, 3]) ([1, 2])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 176/179 (98.32%)[0m
[34mTime: 2.4 ms, iterations: 71[0m
[32m-> true[0m
[0m [0m
[90mline 241 <<: [0m
[90mline 242 <<: [33m# --- Advanced Combinators ---[0m[0m
[90mline 243 <<: alphaEq (omega I) I[0m
[35mEval: alphaEq (omega I) I[0m
[35mAlpha left:  Î»x.x[0m
[35mAlpha right: Î»x.x[0m
[32mAlpha passed - 177/180 (98.33%)[0m
[34mTime: 0.3 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 244 <<: alphaEq (mockingbird I) I[0m
[35mEval: alphaEq (mockingbird I) I[0m
[35mAlpha left:  Î»x.x[0m
[35mAlpha right: Î»x.x[0m
[32mAlpha passed - 178/181 (98.34%)[0m
[34mTime: 0.3 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 245 <<: alphaEq (thrush 5 succ) 6[0m
[35mEval: alphaEq (thrush 5 succ) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 179/182 (98.35%)[0m
[34mTime: 1.3 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 246 <<: alphaEq (cardinal minus 3 10) 7[0m
[35mEval: alphaEq (cardinal minus 3 10) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 180/183 (98.36%)[0m
[34mTime: 2.5 ms, iterations: 43[0m
[32m-> true[0m
[0m [0m
[90mline 247 <<: alphaEq (bluebird succ pred 5) 5[0m
[35mEval: alphaEq (bluebird succ pred 5) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 181/184 (98.37%)[0m
[34mTime: 1.5 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 248 <<: alphaEq (kestrel 42 99) 42[0m
[35mEval: alphaEq (kestrel 42 99) 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 182/185 (98.38%)[0m
[34mTime: 16.1 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 249 <<: alphaEq (warbler plus 3) 6[0m
[35mEval: alphaEq (warbler plus 3) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 183/186 (98.39%)[0m
[34mTime: 1.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 250 <<: alphaEq (starling (K succ) (K 2) 0) 3[0m
[35mEval: alphaEq (starling (K succ) (K 2) false) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 184/187 (98.40%)[0m
[34mTime: 1.4 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 251 <<: [0m
[90mline 252 <<: [33m# --- Curry and Uncurry Functions ---[0m[0m
[90mline 253 <<: alphaEq (curry3 (Î»t.plus (first t) (plus (first (second t)) (second (second t)))) 1 2 3) 6[0m
[35mEval: alphaEq (curry3 (Î»t.plus (first t) (plus (first (second t)) (second (second t)))) 1 2 3) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 185/188 (98.40%)[0m
[34mTime: 3.9 ms, iterations: 119[0m
[32m-> true[0m
[0m [0m
[90mline 254 <<: alphaEq (uncurry plus (pair 7 3)) 10[0m
[35mEval: alphaEq (uncurry plus (pair 7 3)) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 186/189 (98.41%)[0m
[34mTime: 2.4 ms, iterations: 59[0m
[32m-> true[0m
[0m [0m
[90mline 255 <<: alphaEq (uncurry3 (Î»x y z.plus x (plus y z)) (pair 1 (pair 2 3))) 6[0m
[35mEval: alphaEq (uncurry3 (Î»x.Î»y.Î»z.plus x (plus y z)) (pair 1 (pair 2 3))) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 187/190 (98.42%)[0m
[34mTime: 2.9 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 256 <<: [0m
[90mline 257 <<: [33m# --- More Maybe Operations ---[0m[0m
[90mline 258 <<: alphaEq (maybeMap succ (just 5)) (just 6)[0m
[35mEval: alphaEq (maybeMap succ (just 5)) (just 6)[0m
[35mAlpha left:  Î»f.f (true) 6[0m
[35mAlpha right: Î»f.f (true) 6[0m
[32mAlpha passed - 188/191 (98.43%)[0m
[34mTime: 1.8 ms, iterations: 73[0m
[32m-> true[0m
[0m [0m
[90mline 259 <<: alphaEq (maybeMap succ nothing) nothing[0m
[35mEval: alphaEq (maybeMap succ nothing) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 189/192 (98.44%)[0m
[34mTime: 0.5 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 260 <<: [0m
[90mline 261 <<: [33m# --- State Monad (simplified) ---[0m[0m
[90mline 262 <<: alphaEq (runState (returnState 42) 0) (runState (returnState 42) 0)[0m
[35mEval: alphaEq (runState (returnState 42) false) (runState (returnState 42) false)[0m
[35mAlpha left:  Î»f.f 42 false[0m
[35mAlpha right: Î»f.f 42 false[0m
[32mAlpha passed - 190/193 (98.45%)[0m
[34mTime: 8.7 ms, iterations: 27[0m
[32m-> true[0m
[0m [0m
[90mline 263 <<: alphaEq (runState getState 123) (runState getState 123)[0m
[35mEval: alphaEq (runState getState 123) (runState getState 123)[0m
[35mAlpha left:  Î»f.f 123 123[0m
[35mAlpha right: Î»f.f 123 123[0m
[32mAlpha passed - 191/194 (98.45%)[0m
[34mTime: 21.1 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 264 <<: [0m
[90mline 265 <<: [33m# --- Advanced Tree Operations ---[0m[0m
[90mline 266 <<: alphaEq (treeSize (leaf 1)) 1[0m
[35mEval: alphaEq (treeSize (leaf 1)) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 192/195 (98.46%)[0m
[34mTime: 1.1 ms, iterations: 121[0m
[32m-> true[0m
[0m [0m
[90mline 267 <<: alphaEq (treeSize nil) 0[0m
[35mEval: alphaEq (treeSize []) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 193/196 (98.47%)[0m
[34mTime: 0.5 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::34[0m
[90mline 268 <<: alphaEq (treeDepth (leaf 1)) 1[0m
[35mEval: alphaEq (treeDepth (leaf 1)) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 194/197 (98.48%)[0m
[34mTime: 1.0 ms, iterations: 55[0m
[32m-> true[0m
[0m [0m
[90mline 269 <<: alphaEq (treeDepth nil) 0[0m
[35mEval: alphaEq (treeDepth []) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 195/198 (98.48%)[0m
[34mTime: 0.4 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 270 <<: alphaEq (inOrder (leaf 5)) [5][0m
[35mEval: alphaEq (inOrder (leaf 5)) ([5])[0m
[35mAlpha left:  [5][0m
[35mAlpha right: [5][0m
[32mAlpha passed - 196/199 (98.49%)[0m
[34mTime: 1.7 ms, iterations: 159[0m
[32m-> true[0m
[0m [0m
[90mline 271 <<: alphaEq (preOrder (leaf 5)) [5][0m
[35mEval: alphaEq (preOrder (leaf 5)) ([5])[0m
[35mAlpha left:  [5][0m
[35mAlpha right: [5][0m
[32mAlpha passed - 197/200 (98.50%)[0m
[34mTime: 1.7 ms, iterations: 75[0m
[32m-> true[0m
[0m [0m
[90mline 272 <<: alphaEq (postOrder (leaf 5)) [5][0m
[35mEval: alphaEq (postOrder (leaf 5)) ([5])[0m
[35mAlpha left:  [5][0m
[35mAlpha right: [5][0m
[32mAlpha passed - 198/201 (98.51%)[0m
[34mTime: 1.3 ms, iterations: 91[0m
[32m-> true[0m
[0m [0m
[90mline 273 <<: [0m
[90mline 274 <<: [33m# --- Edge Cases and Error Conditions ---[0m[0m
[90mline 275 <<: alphaEq (div 5 0) 0[0m
[35mEval: alphaEq (div 5 false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 199/202 (98.51%)[0m
[34mTime: 0.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 276 <<: alphaEq (mod 5 0) 0[0m
[35mEval: alphaEq (mod 5 false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 200/203 (98.52%)[0m
[34mTime: 0.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 277 <<: alphaEq (head nil) nil[0m
[35mEval: alphaEq (head []) [][0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 201/204 (98.53%)[0m
[34mTime: 0.3 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 278 <<: alphaEq (tail nil) nil[0m
[35mEval: alphaEq (tail []) [][0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 202/205 (98.54%)[0m
[34mTime: 0.3 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 279 <<: alphaEq (pred 0) 0[0m
[35mEval: alphaEq (pred false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 203/206 (98.54%)[0m
[34mTime: 0.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 280 <<: alphaEq (minus 3 5) 0[0m
[35mEval: alphaEq (minus 3 5) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 204/207 (98.55%)[0m
[34mTime: 1.0 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 281 <<: [0m
[90mline 282 <<: [33m# --- Complex Expressions ---[0m[0m
[90mline 283 <<: alphaEq (map (Î»x.mult x x) (range 5)) [0,1,4,9,16][0m
[35mEval: alphaEq (map (Î»x.mult x x) (range 5)) ([false, 1, 4, 9, 16])[0m
[35mAlpha left:  [false, 1, 4, 9, 16][0m
[35mAlpha right: [false, 1, 4, 9, 16][0m
[32mAlpha passed - 205/208 (98.56%)[0m
[34mTime: 4.2 ms, iterations: 199[0m
[32m-> true[0m
[0m [0m
[90mline 284 <<: alphaEq (filter (Î»x.eq (mod x 3) 0) (range 10)) [0,3,6,9][0m
[35mEval: alphaEq (filter (Î»x.eq (mod x 3) false) (range 10)) ([false, 3, 6, 9])[0m
[35mAlpha left:  [false, 3, 6, 9][0m
[35mAlpha right: [false, 3, 6, 9][0m
[32mAlpha passed - 206/209 (98.56%)[0m
[34mTime: 5.1 ms, iterations: 466[0m
[32m-> true[0m
[0m [0m
[90mline 285 <<: alphaEq (foldr max 0 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil)))))) 9[0m
[35mEval: alphaEq (foldr max false ([3, 7, 2, 9, 1])) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 207/210 (98.57%)[0m
[34mTime: 3.9 ms, iterations: 145[0m
[32m-> true[0m
[0m [0m
[90mline 286 <<: alphaEq (foldl min 999 (cons 3 (cons 7 (cons 2 (cons 9 (cons 1 nil)))))) 1[0m
[35mEval: alphaEq (foldl min 999 ([3, 7, 2, 9, 1])) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 208/211 (98.58%)[0m
[34mTime: 94.2 ms, iterations: 177[0m
[32m-> true[0m
[0m [0m
[90mline 287 <<: [0m
[90mline 288 <<: [33m# --- Recursive Function Tests ---[0m[0m
[90mline 289 <<: alphaEq (factRec 4) 24[0m
[35mEval: alphaEq (factRec 4) 24[0m
[35mAlpha left:  24[0m
[35mAlpha right: 24[0m
[32mAlpha passed - 209/212 (98.58%)[0m
[34mTime: 2.9 ms, iterations: 77[0m
[32m-> true[0m
[0m [0m
[90mline 290 <<: alphaEq (fibRec 6) 8[0m
[35mEval: alphaEq (fibRec 6) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 210/213 (98.59%)[0m
[34mTime: 2.8 ms, iterations: 121[0m
[32m-> true[0m
[0m [0m
[90mline 291 <<: alphaEq (sumUptoRec 5) 15[0m
[35mEval: alphaEq (sumUptoRec 5) 15[0m
[35mAlpha left:  15[0m
[35mAlpha right: 15[0m
[32mAlpha passed - 211/214 (98.60%)[0m
[34mTime: 13.2 ms, iterations: 80[0m
[32m-> true[0m
[0m [0m
[90mline 292 <<: [0m
[90mline 293 <<: [33m# --- Performance / Stress (sanity) ---[0m[0m
[90mline 294 <<: alphaEq (length (range 50)) 50[0m
[35mEval: alphaEq (length (range 50)) 50[0m
[35mAlpha left:  50[0m
[35mAlpha right: 50[0m
[32mAlpha passed - 212/215 (98.60%)[0m
[34mTime: 31.7 ms, iterations: 1,590[0m
[32m-> true[0m
[0m [0m
[90mline 295 <<: alphaEq (sum (range 10)) 45[0m
[35mEval: alphaEq (sum (range 10)) 45[0m
[35mAlpha left:  45[0m
[35mAlpha right: 45[0m
[32mAlpha passed - 213/216 (98.61%)[0m
[34mTime: 6.2 ms, iterations: 179[0m
[32m-> true[0m
[0m [0m
[90mline 296 <<: alphaEq (fact 6) 720[0m
[35mEval: alphaEq (fact 6) 720[0m
[35mAlpha left:  720[0m
[35mAlpha right: 720[0m
[32mAlpha passed - 214/217 (98.62%)[0m
[34mTime: 69.1 ms, iterations: 103[0m
[32m-> true[0m
[0m [0m
[90mline 297 <<: alphaEq (fib 10) 55[0m
[35mEval: alphaEq (fib 10) 55[0m
[35mAlpha left:  55[0m
[35mAlpha right: 55[0m
[32mAlpha passed - 215/218 (98.62%)[0m
[34mTime: 7.6 ms, iterations: 203[0m
[32m-> true[0m
[0m [0m
[90mline 298 <<: [0m
[90mline 299 <<: [33m# --- Y combinator derived functions ---[0m[0m
[90mline 300 <<: alphaEq (factY 4) 24[0m
[35mEval: alphaEq (factY 4) 24[0m
[35mAlpha left:  24[0m
[35mAlpha right: 24[0m
[32mAlpha passed - 216/219 (98.63%)[0m
[34mTime: 3.5 ms, iterations: 77[0m
[32m-> true[0m
[0m [0m
[90mline 301 <<: alphaEq (fibY 6) 8[0m
[35mEval: alphaEq (fibY 6) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 217/220 (98.64%)[0m
[34mTime: 2.0 ms, iterations: 121[0m
[32m-> true[0m
[0m [0m
[90mline 302 <<: alphaEq (sumUptoY 5) 15[0m
[35mEval: alphaEq (sumUptoY 5) 15[0m
[35mAlpha left:  15[0m
[35mAlpha right: 15[0m
[32mAlpha passed - 218/221 (98.64%)[0m
[34mTime: 2.3 ms, iterations: 92[0m
[32m-> true[0m
[0m [0m
[90mline 303 <<: alphaEq (expY 2 5) 32[0m
[35mEval: alphaEq (expY 2 5) 32[0m
[35mAlpha left:  32[0m
[35mAlpha right: 32[0m
[32mAlpha passed - 219/222 (98.65%)[0m
[34mTime: 4.5 ms, iterations: 116[0m
[32m-> true[0m
[0m [0m
[90mline 304 <<: alphaEq (rangeY 10) [0,1,2,3,4,5,6,7,8,9][0m
[35mEval: alphaEq (rangeY 10) ([false, 1, 2, 3, 4, 5, 6, 7, 8, 9])[0m
[35mAlpha left:  [false, 1, 2, 3, 4, 5, 6, 7, 8, 9][0m
[35mAlpha right: [false, 1, 2, 3, 4, 5, 6, 7, 8, 9][0m
[32mAlpha passed - 220/223 (98.65%)[0m
[34mTime: 8.6 ms, iterations: 246[0m
[32m-> true[0m
[0m [0m
[90mline 305 <<: alphaEq (countdownY 5) [5,4,3,2,1,0][0m
[35mEval: alphaEq (countdownY 5) ([5, 4, 3, 2, 1, false])[0m
[35mAlpha left:  [5, 4, 3, 2, 1, false][0m
[35mAlpha right: [5, 4, 3, 2, 1, false][0m
[32mAlpha passed - 221/224 (98.66%)[0m
[34mTime: 3.8 ms, iterations: 115[0m
[32m-> true[0m
[0m [0m
[90mline 306 <<: alphaEq (gcdY 48 18) 6[0m
[35mEval: alphaEq (gcdY 48 18) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 222/225 (98.67%)[0m
[34mTime: 6.9 ms, iterations: 54[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::39[0m
[90mline 307 <<: alphaEq (lcmY 12 15) 60[0m
[35mEval: alphaEq (lcmY 12 15) 60[0m
[35mAlpha left:  60[0m
[35mAlpha right: 60[0m
[32mAlpha passed - 223/226 (98.67%)[0m
[34mTime: 18.9 ms, iterations: 1,022[0m
[32m-> true[0m
[0m [0m
[90mline 308 <<: alphaEq (mapY succ (range 5)) [1,2,3,4,5][0m
[35mEval: alphaEq (mapY succ (range 5)) ([1, 2, 3, 4, 5])[0m
[35mAlpha left:  [1, 2, 3, 4, 5][0m
[35mAlpha right: [1, 2, 3, 4, 5][0m
[32mAlpha passed - 224/227 (98.68%)[0m
[34mTime: 5.4 ms, iterations: 508[0m
[32m-> true[0m
[0m [0m
[90mline 309 <<: alphaEq (filterY (Î»x.eq (mod x 2) 0) (range 10)) [0,2,4,6,8][0m
[35mEval: alphaEq (filterY (Î»x.eq (mod x 2) false) (range 10)) ([false, 2, 4, 6, 8])[0m
[35mAlpha left:  [false, 2, 4, 6, 8][0m
[35mAlpha right: [false, 2, 4, 6, 8][0m
[32mAlpha passed - 225/228 (98.68%)[0m
[34mTime: 9.9 ms, iterations: 1,831[0m
[32m-> true[0m
[0m [0m
[90mline 310 <<: alphaEq (lengthY (range 50)) 50[0m
[35mEval: alphaEq (lengthY (range 50)) 50[0m
[35mAlpha left:  50[0m
[35mAlpha right: 50[0m
[32mAlpha passed - 226/229 (98.69%)[0m
[34mTime: 58.0 ms, iterations: 7,111[0m
[32m-> true[0m
[0m [0m
[90mline 311 <<: alphaEq (reverseY (range 5)) [4,3,2,1,0][0m
[35mEval: alphaEq (reverseY (range 5)) ([4, 3, 2, 1, false])[0m
[35mAlpha left:  [4, 3, 2, 1, false][0m
[35mAlpha right: [4, 3, 2, 1, false][0m
[32mAlpha passed - 227/230 (98.70%)[0m
[34mTime: 3.6 ms, iterations: 223[0m
[32m-> true[0m
[0m [0m
[90mline 312 <<: alphaEq (sumY (range 5)) 10[0m
[35mEval: alphaEq (sumY (range 5)) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 228/231 (98.70%)[0m
[34mTime: 2.6 ms, iterations: 192[0m
[32m-> true[0m
[0m [0m
[90mline 313 <<: alphaEq (productY (tail (range 7))) 720[0m
[35mEval: alphaEq (productY (tail (range 7))) 720[0m
[35mAlpha left:  720[0m
[35mAlpha right: 720[0m
[32mAlpha passed - 229/232 (98.71%)[0m
[34mTime: 68.4 ms, iterations: 1,237[0m
[32m-> true[0m
[0m [0m
[90mline 314 <<: alphaEq (anyY (Î»x.gt x 3) (range 5)) true[0m
[35mEval: alphaEq (anyY (Î»x.gt x 3) (range 5)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 230/233 (98.71%)[0m
[34mTime: 2.5 ms, iterations: 276[0m
[32m-> true[0m
[0m [0m
[90mline 315 <<: alphaEq (allY (Î»x.leq x 5) (range 5)) true[0m
[35mEval: alphaEq (allY (Î»x.leq x 5) (range 5)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 231/234 (98.72%)[0m
[34mTime: 2.2 ms, iterations: 276[0m
[32m-> true[0m
[0m [0m
[90mline 316 <<: alphaEq (findY (Î»x.eq x 3) (range 5)) 3[0m
[35mEval: alphaEq (findY (Î»x.eq x 3) (range 5)) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 232/235 (98.72%)[0m
[34mTime: 2.3 ms, iterations: 158[0m
[32m-> true[0m
[0m [0m
[90mline 317 <<: [0m
[90mline 318 <<: alphaEq [1,2,3] [1,2,3][0m
[35mEval: alphaEq ([1, 2, 3]) ([1, 2, 3])[0m
[34mTime: 2.7 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 319 <<: alphaEq [1,3 .. 6] [1,3,5][0m
[35mEval: alphaEq ([1, 3, 5]) ([1, 3, 5])[0m
[35mAlpha left:  [1, 3, 5][0m
[35mAlpha right: [1, 3, 5][0m
[32mAlpha passed - 233/236 (98.73%)[0m
[34mTime: 3.7 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 320 <<: alphaEq [1,2,3,[4..7],[11 .. 8]] [1,2,3,[4,5,6,7],[11,10,9,8]][0m
[35mEval: alphaEq ([1, 2, 3, [4, 5, 6, 7], [11, 10, 9, 8]]) ([1, 2, 3, [4, 5, 6, 7], [11, 10, 9, 8]])[0m
[35mAlpha left:  [1, 2, 3, [4, 5, 6, 7], [11, 10, 9, 8]][0m
[35mAlpha right: [1, 2, 3, [4, 5, 6, 7], [11, 10, 9, 8]][0m
[32mAlpha passed - 234/237 (98.73%)[0m
[34mTime: 18.0 ms, iterations: 67[0m
[32m-> true[0m
[0m [0m
[90mline 321 <<: [0m
[90mline 322 <<: alphaEq (mapY (ackermann 2) [2..10]) [7,9,11,13,15,17,19,21,23][0m
[35mEval: alphaEq (mapY (ackermann 2) ([2, 3, 4, 5, 6, 7, 8, 9, 10])) ([7, 9, 11, 13, 15, 17, 19, 21, 23])[0m
[35mAlpha left:  [7, 9, 11, 13, 15, 17, 19, 21, 23][0m
[35mAlpha right: [7, 9, 11, 13, 15, 17, 19, 21, 23][0m
[32mAlpha passed - 235/238 (98.74%)[0m
[34mTime: 25.8 ms, iterations: 2,324[0m
[32m-> true[0m
[0m [0m
[90mline 323 <<: [0m
[90mline 324 <<: [33m# --- Let and Let Rec Examples ---[0m[0m
[90mline 325 <<: alphaEq (let x = 5 in x + 2) 7[0m
[35mEval: alphaEq ((Î»x.+ x 2) 5) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 236/239 (98.74%)[0m
[34mTime: 1.9 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 326 <<: alphaEq (let x = 1, y = 2 in x + y) 3[0m
[35mEval: alphaEq ((Î»x.Î»y.+ x y) 1 2) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 237/240 (98.75%)[0m
[34mTime: 1.4 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 327 <<: alphaEq (let a = 10, b = 20, c = 30 in a + b + c) 60[0m
[35mEval: alphaEq ((Î»a.Î»b.Î»c.+ (+ a b) c) 10 20 30) 60[0m
[35mAlpha left:  60[0m
[35mAlpha right: 60[0m
[32mAlpha passed - 238/241 (98.76%)[0m
[34mTime: 11.5 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 328 <<: alphaEq (let x = 2, y = 3 in x * (y + 1)) 8[0m
[35mEval: alphaEq ((Î»x.Î»y.* x (+ y 1)) 2 3) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 239/242 (98.76%)[0m
[34mTime: 2.4 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 329 <<: alphaEq (let rec fact = \n. if (eq n 0) 1 (mult n (fact (pred n))) in fact 5) 120[0m
[35mEval: alphaEq ((Î»fact.fact 5) (Y (Î»fact.Î»n.if (eq n false) 1 (mult n (fact (pred n)))))) 120[0m
[35mAlpha left:  120[0m
[35mAlpha right: 120[0m
[32mAlpha passed - 240/243 (98.77%)[0m
[34mTime: 12.1 ms, iterations: 91[0m
[32m-> true[0m
[0m [0m
[90mline 330 <<: alphaEq (let rec fib = \n. if (leq n 1) n (plus (fib (pred n)) (fib (minus n 2))) in fib 6) 8[0m
[35mEval: alphaEq ((Î»fib.fib 6) (Y (Î»fib.Î»n.if (leq n 1) n (plus (fib (pred n)) (fib (minus n 2)))))) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 241/244 (98.77%)[0m
[34mTime: 3.8 ms, iterations: 145[0m
[32m-> true[0m
[0m [0m
[90mline 331 <<: alphaEq (let rec sumTo = \n. if (eq n 0) 0 (plus n (sumTo (pred n))) in sumTo 4) 10[0m
[35mEval: alphaEq ((Î»sumTo.sumTo 4) (Y (Î»sumTo.Î»n.if (eq n false) false (plus n (sumTo (pred n)))))) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 242/245 (98.78%)[0m
[34mTime: 2.9 ms, iterations: 69[0m
[32m-> true[0m
[0m [0m
[90mline 332 <<: [0m
[90mline 333 <<: [33m# --- Pipeline Operator (|>) ---[0m[0m
[90mline 334 <<: alphaEq (5 |> succ) 6[0m
[35mEval: alphaEq (succ 5) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 243/246 (98.78%)[0m
[34mTime: 1.5 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 335 <<: alphaEq (5 |> square) 25[0m
[34mMacro  0 square in   square 5[0m
[34mMacro  0        out  mult 5 5[0m
[34mMacro  0 square done mult 5 5[0m
[35mEval: alphaEq (mult 5 5) 25[0m
[35mAlpha left:  25[0m
[35mAlpha right: 25[0m
[32mAlpha passed - 244/247 (98.79%)[0m
[34mTime: 3.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 336 <<: alphaEq (5 |> square |> succ) 26[0m
[34mMacro  0 square in   square 5[0m
[34mMacro  0        out  mult 5 5[0m
[34mMacro  0 square done mult 5 5[0m
[35mEval: alphaEq (succ (mult 5 5)) 26[0m
[35mAlpha left:  26[0m
[35mAlpha right: 26[0m
[32mAlpha passed - 245/248 (98.79%)[0m
[34mTime: 4.2 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 337 <<: alphaEq (5 |> succ |> square) 36[0m
[34mMacro  0 square in   square (succ 5)[0m
[34mMacro  0        out  mult (succ 5) (succ 5)[0m
[34mMacro  0 square done mult (succ 5) (succ 5)[0m
[35mEval: alphaEq (mult (succ 5) (succ 5)) 36[0m
[35mAlpha left:  36[0m
[35mAlpha right: 36[0m
[32mAlpha passed - 246/249 (98.80%)[0m
[34mTime: 4.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 338 <<: alphaEq (1 |> succ |> succ |> succ) 4[0m
[35mEval: alphaEq (succ (succ (succ 1))) 4[0m
[35mAlpha left:  4[0m
[35mAlpha right: 4[0m
[32mAlpha passed - 247/250 (98.80%)[0m
[34mTime: 1.0 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 339 <<: alphaEq ((5 |> square) |> succ) 26[0m
[34mMacro  0 square in   square 5[0m
[34mMacro  0        out  mult 5 5[0m
[34mMacro  0 square done mult 5 5[0m
[35mEval: alphaEq (succ (mult 5 5)) 26[0m
[34mTime: 3.7 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 340 <<: alphaEq (5 |> (square |> succ)) 26[0m
[35mEval: alphaEq (succ square 5) 26[0m
[35mAlpha left:  125[0m
[35mAlpha right: 26[0m
[31mAlpha failed - 4/251 (1.59%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 3.3 ms, iterations: 11[0m
[32m-> false[0m
[0m [0m
[90mline 341 <<: alphaEq (2 |> succ |> square |> pred) 8[0m
[34mMacro  0 square in   square (succ 2)[0m
[34mMacro  0        out  mult (succ 2) (succ 2)[0m
[34mMacro  0 square done mult (succ 2) (succ 2)[0m
[35mEval: alphaEq (pred (mult (succ 2) (succ 2))) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 248/252 (98.41%)[0m
[34mTime: 2.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 342 <<: [0m
[90mline 343 <<: [33m# --- Arrow Function Syntax ---[0m[0m
[90mline 344 <<: alphaEq ((x -> x + 1) 5) 6[0m
[35mEval: alphaEq ((Î»x.+ x 1) 5) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 249/253 (98.42%)[0m
[34mTime: 1.9 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 345 <<: alphaEq ((x -> succ x) 4) 5[0m
[35mEval: alphaEq ((Î»x.succ x) 4) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 250/254 (98.43%)[0m
[34mTime: 1.3 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 346 <<: alphaEq ((x, y -> x + y) 3 2) 5[0m
[35mEval: alphaEq ((Î»x.Î»y.+ x y) 3 2) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 251/255 (98.43%)[0m
[34mTime: 1.7 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::44[0m
[90mline 347 <<: alphaEq ((x, y -> mult x y) 4 3) 12[0m
[35mEval: alphaEq ((Î»x.Î»y.mult x y) 4 3) 12[0m
[35mAlpha left:  12[0m
[35mAlpha right: 12[0m
[32mAlpha passed - 252/256 (98.44%)[0m
[34mTime: 2.6 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 348 <<: alphaEq ((x -> x * x) 6) 36[0m
[35mEval: alphaEq ((Î»x.* x x) 6) 36[0m
[35mAlpha left:  36[0m
[35mAlpha right: 36[0m
[32mAlpha passed - 253/257 (98.44%)[0m
[34mTime: 4.3 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 349 <<: alphaEq ((x, y, z -> x + y + z) 1 2 3) 6[0m
[35mEval: alphaEq ((Î»x.Î»y.Î»z.+ (+ x y) z) 1 2 3) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 254/258 (98.45%)[0m
[34mTime: 2.5 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 350 <<: alphaEq (let f = x -> x + 1 in f 10) 11[0m
[35mEval: alphaEq ((Î»f.f 10) (Î»x.+ x 1)) 11[0m
[35mAlpha left:  11[0m
[35mAlpha right: 11[0m
[32mAlpha passed - 255/259 (98.46%)[0m
[34mTime: 3.0 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 351 <<: alphaEq (let add = x, y -> x + y in add 7 8) 15[0m
[35mEval: alphaEq ((Î»add.add 7 8) (Î»x.Î»y.+ x y)) 15[0m
[35mAlpha left:  15[0m
[35mAlpha right: 15[0m
[32mAlpha passed - 256/260 (98.46%)[0m
[34mTime: 3.5 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 352 <<: alphaEq (let add = x -> y -> x + y in let mult2 = x -> x * 2 in let div2 = x -> x / 2 in (add 5 3) |> mult2 |> div2) 8[0m
[35mEval: alphaEq ((Î»add.(Î»mult2.(Î»div2.div2 (mult2 (add 5 3))) (Î»x./ x 2)) (Î»x.* x 2)) (Î»x.Î»y.+ x y)) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 257/261 (98.47%)[0m
[34mTime: 3.9 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 353 <<: alphaEq (let add = x, y -> x + y in let mult2 = x -> x * 2 in let div2 = x -> x / 2 in (add 5 3) |> mult2 |> div2) 8[0m
[35mEval: alphaEq ((Î»add.(Î»mult2.(Î»div2.div2 (mult2 (add 5 3))) (Î»x./ x 2)) (Î»x.* x 2)) (Î»x.Î»y.+ x y)) 8[0m
[34mTime: 1.7 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 354 <<: alphaEq (3 |> (x -> x + 1) |> (y -> y * 2)) 8[0m
[35mEval: alphaEq ((Î»y.* y 2) ((Î»x.+ x 1) 3)) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 258/262 (98.47%)[0m
[34mTime: 1.4 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 355 <<: alphaEq ((x -> y -> x + y) 5 3) 8[0m
[35mEval: alphaEq ((Î»x.Î»y.+ x y) 5 3) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 259/263 (98.48%)[0m
[34mTime: 1.7 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 356 <<: alphaEq ((f -> x -> f (f x)) succ 0) 2[0m
[35mEval: alphaEq (2 succ false) 2[0m
[35mAlpha left:  2[0m
[35mAlpha right: 2[0m
[32mAlpha passed - 260/264 (98.48%)[0m
[34mTime: 0.5 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 357 <<: alphaEq (map (x -> x + 1) [1,2,3]) [2,3,4][0m
[35mEval: alphaEq (map (Î»x.+ x 1) ([1, 2, 3])) ([2, 3, 4])[0m
[35mAlpha left:  [2, 3, 4][0m
[35mAlpha right: [2, 3, 4][0m
[32mAlpha passed - 261/265 (98.49%)[0m
[34mTime: 1.6 ms, iterations: 99[0m
[32m-> true[0m
[0m [0m
[90mline 358 <<: alphaEq (filter (x -> x > 2) [1,2,3,4,5]) [3,4,5][0m
[35mEval: alphaEq (filter (Î»x.> x 2) ([1, 2, 3, 4, 5])) ([3, 4, 5])[0m
[35mAlpha left:  [3, 4, 5][0m
[35mAlpha right: [3, 4, 5][0m
[32mAlpha passed - 262/266 (98.50%)[0m
[34mTime: 2.4 ms, iterations: 153[0m
[32m-> true[0m
[0m [0m
[90mline 359 <<: [33m# Parsing sanity (expression form) - cannot structural test without full desugaring[0m[0m[32m;[0m[90m skip[0m
[90mline 360 <<: [0m
[90mline 361 <<: [33m# --- Infix Composition Operator (.) ---[0m[0m
[90mline 362 <<: inc = x -> x + 1[0m
[32m-> inc = Î»x.+ x 1[0m
[0m [0m
[90mline 363 <<: double2 = x -> x * 2   [33m# renamed from 'double' to avoid shadowing stdlib/native name[0m[0m
[32m-> double2 = Î»x.* x 2[0m
[0m [0m
[90mline 364 <<: square = x -> x * x[0m
[32m-> square = Î»x.* x x[0m
[0m [0m
[90mline 365 <<: alphaEq (inc . double2 . 3) 7[0m
[34mMacro  0 inc in   inc (double2 3)[0m
[34mMacro  0     out  succ (double2 3)[0m
[34mMacro  0 inc done succ (double2 3)[0m
[35mEval: alphaEq (succ (double2 3)) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 263/267 (98.50%)[0m
[34mTime: 0.8 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 366 <<: alphaEq (double2 . inc . 3) 8[0m
[34mMacro  0 inc in   inc 3[0m
[34mMacro  0     out  succ 3[0m
[34mMacro  0 inc done succ 3[0m
[35mEval: alphaEq (double2 (succ 3)) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 264/268 (98.51%)[0m
[34mTime: 0.6 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 367 <<: alphaEq (square . inc . 4) 25[0m
[34mMacro  0 square  in   square (inc 4)[0m
[34mMacro  0         out  mult (inc 4) (inc 4)[0m
[34mMacro  1 .inc    in   inc 4[0m
[34mMacro  1 .       out  succ 4[0m
[34mMacro  1 .inc    done succ 4[0m
[34mMacro  1 .inc    in   inc 4[0m
[34mMacro  1 .       out  succ 4[0m
[34mMacro  1 .inc    done succ 4[0m
[34mMacro  0 square  done mult (succ 4) (succ 4)[0m
[35mEval: alphaEq (mult (succ 4) (succ 4)) 25[0m
[35mAlpha left:  25[0m
[35mAlpha right: 25[0m
[32mAlpha passed - 265/269 (98.51%)[0m
[34mTime: 1.5 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 368 <<: alphaEq (inc . double2 . square . 2) 9[0m
[34mMacro  0 inc     in   inc (double2 (square 2))[0m
[34mMacro  0         out  succ (double2 (square 2))[0m
[34mMacro  1 .square in   square 2[0m
[34mMacro  1 .       out  mult 2 2[0m
[34mMacro  1 .square done mult 2 2[0m
[34mMacro  0 inc     done succ (double2 (mult 2 2))[0m
[35mEval: alphaEq (succ (double2 (mult 2 2))) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 266/270 (98.52%)[0m
[34mTime: 0.8 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 369 <<: alphaEq (double2 . inc . square . 2) 10[0m
[34mMacro  0 inc     in   inc (square 2)[0m
[34mMacro  0         out  succ (square 2)[0m
[34mMacro  1 .square in   square 2[0m
[34mMacro  1 .       out  mult 2 2[0m
[34mMacro  1 .square done mult 2 2[0m
[34mMacro  0 inc     done succ (mult 2 2)[0m
[35mEval: alphaEq (double2 (succ (mult 2 2))) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 267/271 (98.52%)[0m
[34mTime: 0.8 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 370 <<: alphaEq (inc . double2 . 3 |> square) 49[0m
[34mMacro  0 square  in   square (inc (double2 3))[0m
[34mMacro  0         out  mult (inc (double2 3)) (inc (double2 3))[0m
[34mMacro  1 .inc    in   inc (double2 3)[0m
[34mMacro  1 .       out  succ (double2 3)[0m
[34mMacro  1 .inc    done succ (double2 3)[0m
[34mMacro  1 .inc    in   inc (double2 3)[0m
[34mMacro  1 .       out  succ (double2 3)[0m
[34mMacro  1 .inc    done succ (double2 3)[0m
[34mMacro  0 square  done mult (succ (double2 3)) (succ (double2 3))[0m
[35mEval: alphaEq (mult (succ (double2 3)) (succ (double2 3))) 49[0m
[35mAlpha left:  49[0m
[35mAlpha right: 49[0m
[32mAlpha passed - 268/272 (98.53%)[0m
[34mTime: 2.3 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 371 <<: [0m
[90mline 372 <<: [33m# --- Application operator ($) tests ---[0m[0m
[90mline 373 <<: [38;5;205m:infix $ 1 right[0m[0m
[0mInfix operator '$' defined with precedence 1 and right associativity[0m
[0m [0m
[90mline 374 <<: $ = f,x -> f x[0m
[32m-> $ = 1[0m
[0m [0m
[90mline 375 <<: alphaEq (succ (pred 5)) (succ $ pred 5)[0m
[35mEval: alphaEq (succ (pred 5)) (succ (pred 5))[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 269/273 (98.53%)[0m
[34mTime: 0.7 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 376 <<: alphaEq (succ (pred (succ 4))) (succ $ pred $ succ 4)[0m
[35mEval: alphaEq (succ (pred (succ 4))) (succ (pred (succ 4)))[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 270/274 (98.54%)[0m
[34mTime: 0.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 377 <<: alphaEq (map (Î»x.mult x x) (filter (Î»x.gt x 2) (range 6))) (map (Î»x.mult x x) $ filter (Î»x.gt x 2) $ range 6)[0m
[35mEval: alphaEq (map (Î»x.mult x x) (filter (Î»x.gt x 2) (range 6))) (map (Î»x.mult x x) (filter (Î»x.gt x 2) (range 6)))[0m
[35mAlpha left:  [9, 16, 25][0m
[35mAlpha right: [9, 16, 25][0m
[32mAlpha passed - 271/275 (98.55%)[0m
[34mTime: 2.4 ms, iterations: 370[0m
[32m-> true[0m
[0m [0m
[90mline 378 <<: [0m
[90mline 379 <<: [33m# Macro with $ usage[0m[0m
[90mline 380 <<: [38;5;205m:macro (m $x) => succ $x[0m[0m
[34mMacro 'm' defined successfully[0m
[0m [0m
[90mline 381 <<: alphaEq (m 4) 5[0m
[34mMacro  0 m in   m 4[0m
[34mMacro  0   out  succ 4[0m
[34mMacro  0 m done succ 4[0m
[35mEval: alphaEq (succ 4) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 272/276 (98.55%)[0m
[34mTime: 0.5 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 382 <<: [0m
[90mline 383 <<: [33m# --- Advanced Multi-Feature Tests ---[0m[0m
[90mline 384 <<: alphaEq (foldr plus 0 (filter (Î»x.gt x 2) (map (Î»x.mult x x) (range 5)))) 29[0m
[35mEval: alphaEq (foldr plus false (filter (Î»x.gt x 2) (map (Î»x.mult x x) (range 5)))) 29[0m
[35mAlpha left:  29[0m
[35mAlpha right: 29[0m
[32mAlpha passed - 273/277 (98.56%)[0m
[34mTime: 2.5 ms, iterations: 205[0m
[32m-> true[0m
[0m [0m
[90mline 385 <<: alphaEq (let double2 = x -> x * 2 in (map double2 [1,2,3,4]) |> (filter (x -> x > 4))) [6,8][0m
[35mEval: alphaEq ((Î»double2.filter (Î»x.> x 4) (map double2 ([1, 2, 3, 4]))) (Î»x.* x 2)) ([6, 8])[0m
[35mAlpha left:  [6, 8][0m
[35mAlpha right: [6, 8][0m
[32mAlpha passed - 274/278 (98.56%)[0m
[34mTime: 2.8 ms, iterations: 255[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::49[0m
[90mline 386 <<: alphaEq (let rec sumEvens = \xs. if (isnil xs) 0 (if (even (head xs)) (plus (head xs) (sumEvens (tail xs))) (sumEvens (tail xs))) in sumEvens [1,2,3,4,5,6]) 12[0m
[35mEval: alphaEq ((Î»sumEvens.sumEvens ([1, 2, 3, 4, 5, 6])) (Y (Î»sumEvens.Î»xs.if (isnil xs) false (if (even (head xs)) (plus (head xs) (sumEvens (tail xs))) (sumEvens (tail xs)))))) 12[0m
[35mAlpha left:  12[0m
[35mAlpha right: 12[0m
[32mAlpha passed - 275/279 (98.57%)[0m
[34mTime: 3.3 ms, iterations: 277[0m
[32m-> true[0m
[0m [0m
[90mline 387 <<: alphaEq ((maybeMap (x -> x * x) (just 7)) |> (maybe 0 (x -> x + 1))) 50[0m
[35mEval: alphaEq (maybe false (Î»x.+ x 1) (maybeMap (Î»x.* x x) (just 7))) 50[0m
[35mAlpha left:  50[0m
[35mAlpha right: 50[0m
[32mAlpha passed - 276/280 (98.57%)[0m
[34mTime: 2.8 ms, iterations: 111[0m
[32m-> true[0m
[0m [0m
[90mline 388 <<: alphaEq (let tree = node 1 (leaf 2) (node 3 (leaf 4) (leaf 5)) in foldr plus 0 (inOrder tree)) 15[0m
[35mEval: alphaEq ((Î»tree.foldr plus false (inOrder tree)) (node 1 (leaf 2) (node 3 (leaf 4) (leaf 5)))) 15[0m
[35mAlpha left:  15[0m
[35mAlpha right: 15[0m
[32mAlpha passed - 277/281 (98.58%)[0m
[34mTime: 2.9 ms, iterations: 761[0m
[32m-> true[0m
[0m [0m
[90mline 389 <<: alphaEq (map (x -> map (y -> x * y) [1,2,3]) [4,5]) [[4,8,12],[5,10,15]][0m
[35mEval: alphaEq (map (Î»x.map (Î»y.* x y) ([1, 2, 3])) ([4, 5])) ([[4, 8, 12], [5, 10, 15]])[0m
[35mAlpha left:  [[4, 8, 12], [5, 10, 15]][0m
[35mAlpha right: [[4, 8, 12], [5, 10, 15]][0m
[32mAlpha passed - 278/282 (98.58%)[0m
[34mTime: 4.8 ms, iterations: 339[0m
[32m-> true[0m
[0m [0m
[90mline 390 <<: alphaEq (let add3 = x -> y -> z -> x + y + z in (add3 1 2) |> (f -> f 3)) 6[0m
[35mEval: alphaEq ((Î»add3.(Î»f.f 3) (add3 1 2)) (Î»x.Î»y.Î»z.+ (+ x y) z)) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 279/283 (98.59%)[0m
[34mTime: 1.0 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 391 <<: alphaEq (find (x -> x % 6 == 0) (map (x -> x + 1) [1,3,5,7,8])) 6[0m
[35mEval: alphaEq (find (Î»x.== (% x 6) false) (map (Î»x.+ x 1) ([1, 3, 5, 7, 8]))) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 280/284 (98.59%)[0m
[34mTime: 3.5 ms, iterations: 477[0m
[32m-> true[0m
[0m [0m
[90mline 392 <<: alphaEq (foldl mult 1 (map (pair -> plus (first pair) (second pair)) (zip [1,2,3] [4,5,6]))) 315[0m
[35mEval: alphaEq (foldl mult 1 (map (Î»pair.plus (first pair) (second pair)) (zip ([1, 2, 3]) ([4, 5, 6])))) 315[0m
[35mAlpha left:  315[0m
[35mAlpha right: 315[0m
[32mAlpha passed - 281/285 (98.60%)[0m
[34mTime: 14.5 ms, iterations: 610[0m
[32m-> true[0m
[0m [0m
[90mline 393 <<: alphaEq (let f = x -> x * 3 in (map f (filter (x -> x > 2) (range 7))) |> (foldl plus 0)) 54[0m
[35mEval: alphaEq ((Î»f.foldl plus false (map f (filter (Î»x.> x 2) (range 7)))) (Î»x.* x 3)) 54[0m
[35mAlpha left:  54[0m
[35mAlpha right: 54[0m
[32mAlpha passed - 282/286 (98.60%)[0m
[34mTime: 4.0 ms, iterations: 457[0m
[32m-> true[0m
[0m [0m
[90mline 394 <<: [0m
[90mline 395 <<: [33m# Maybe monad tests using stdlib encoding (pair-based)[0m[0m
[90mline 396 <<: bind = Î»m f. if (isNothing m) nothing (f (fromJust m))[0m
[32m-> bind = Î»m.Î»f.if (isNothing m) nothing (f (fromJust m))[0m
[0m [0m
[90mline 397 <<: alphaEq (bind (just 3) (Î»x. just (x + 1))) (just 4)[0m
[35mEval: alphaEq (bind (just 3) (Î»x.just (+ x 1))) (just 4)[0m
[35mAlpha left:  Î»f.f (true) 4[0m
[35mAlpha right: Î»f.f (true) 4[0m
[32mAlpha passed - 283/287 (98.61%)[0m
[34mTime: 1.1 ms, iterations: 57[0m
[32m-> true[0m
[0m [0m
[90mline 398 <<: alphaEq (bind nothing (Î»x. just (x + 1))) nothing[0m
[35mEval: alphaEq (bind nothing (Î»x.just (+ x 1))) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 284/288 (98.61%)[0m
[34mTime: 0.4 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 399 <<: [0m
[90mline 400 <<: [33m# Lambda placeholder examples[0m[0m
[90mline 401 <<: alphaEq ((\_ . 42) 123) 42[0m
[35mEval: alphaEq ((Î»_placeholder1.42) 123) 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 285/289 (98.62%)[0m
[34mTime: 8.2 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 402 <<: alphaEq ((\_ _ . 99) 1 2) 99[0m
[35mEval: alphaEq ((Î»_placeholder1.Î»_placeholder2.99) 1 2) 99[0m
[35mAlpha left:  99[0m
[35mAlpha right: 99[0m
[32mAlpha passed - 286/290 (98.62%)[0m
[34mTime: 7.4 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 403 <<: alphaEq ((\x _ . x) 7 8) 7[0m
[35mEval: alphaEq ((true) 7 8) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 287/291 (98.63%)[0m
[34mTime: 1.3 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 404 <<: alphaEq ((\_ y . y) 5 6) 6[0m
[35mEval: alphaEq (false 5 6) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 288/292 (98.63%)[0m
[34mTime: 0.8 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 405 <<: alphaEq ((_ , _ -> 0) 10 20) 0[0m
[35mEval: alphaEq ((Î»_.Î»_.false) 10 20) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 289/293 (98.63%)[0m
[34mTime: 1.7 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 406 <<: alphaEq ((x, _ -> x) 42 99) 42[0m
[35mEval: alphaEq ((true) 42 99) 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 290/294 (98.64%)[0m
[34mTime: 7.7 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 407 <<: alphaEq (let f = \_ . 123 in f 456) 123[0m
[35mEval: alphaEq ((Î»f.f 456) (Î»_placeholder1.123)) 123[0m
[35mAlpha left:  123[0m
[35mAlpha right: 123[0m
[32mAlpha passed - 291/295 (98.64%)[0m
[34mTime: 26.4 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 408 <<: alphaEq (let g = \_ _ . 1 in g 2 3) 1[0m
[35mEval: alphaEq ((Î»g.g 2 3) (Î»_placeholder1.Î»_placeholder2.1)) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 292/296 (98.65%)[0m
[34mTime: 0.6 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 409 <<: alphaEq (let h = \_ y . y in h 0 9) 9[0m
[35mEval: alphaEq ((Î»h.h false 9) false) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 293/297 (98.65%)[0m
[34mTime: 1.1 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 410 <<: [0m
[90mline 411 <<: [33m# --- def function definition sugar ---[0m[0m
[90mline 412 <<: def inc2 x = x + 1[0m
[32m-> inc2 = Î»x.+ x 1[0m
[0m [0m
[90mline 413 <<: def add2 x y = x + y[0m
[32m-> add2 = Î»x.Î»y.+ x y[0m
[0m [0m
[90mline 414 <<: def const42 = 42[0m
[32m-> const42 = 42[0m
[0m [0m
[90mline 415 <<: alphaEq (inc2 5) 6[0m
[35mEval: alphaEq (inc2 5) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 294/298 (98.66%)[0m
[34mTime: 0.7 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 416 <<: alphaEq (add2 3 4) 7[0m
[35mEval: alphaEq (add2 3 4) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 295/299 (98.66%)[0m
[34mTime: 0.7 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 417 <<: alphaEq const42 42[0m
[35mEval: alphaEq const42 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 296/300 (98.67%)[0m
[34mTime: 1.5 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 418 <<: alphaEq (let z = 10 in add2 (inc2 z) const42) 53[0m
[35mEval: alphaEq ((Î»z.add2 (inc2 z) const42) 10) 53[0m
[35mAlpha left:  53[0m
[35mAlpha right: 53[0m
[32mAlpha passed - 297/301 (98.67%)[0m
[34mTime: 2.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 419 <<: [0m
[90mline 420 <<: [33m# Macro System Tests[0m[0m
[90mline 421 <<: [38;5;205m:macro (letbind $var $val $expr) => ((Î»$var.$expr) $val)[0m[0m
[34mMacro 'letbind' defined successfully[0m
[0m [0m
[90mline 422 <<: alphaEq ((letbind x 42 (plus x 10))) 52[0m
[34mMacro  0 letbind in   letbind x 42 (plus x 10)[0m
[34mMacro  0         out  (Î»x.plus x 10) 42[0m
[34mMacro  0 letbind done (Î»x.plus x 10) 42[0m
[35mEval: alphaEq ((Î»x.plus x 10) 42) 52[0m
[35mAlpha left:  52[0m
[35mAlpha right: 52[0m
[32mAlpha passed - 298/302 (98.68%)[0m
[34mTime: 4.1 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 423 <<: alphaEq ((letbind y 5 (mult y y))) 25[0m
[34mMacro  0 letbind in   letbind y 5 (mult y y)[0m
[34mMacro  0         out  (Î»y.mult y y) 5[0m
[34mMacro  0 letbind done (Î»y.mult y y) 5[0m
[35mEval: alphaEq ((Î»y.mult y y) 5) 25[0m
[35mAlpha left:  25[0m
[35mAlpha right: 25[0m
[32mAlpha passed - 299/303 (98.68%)[0m
[34mTime: 1.2 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 424 <<: alphaEq ((letbind z 3 (exp 2 z))) 8[0m
[34mMacro  0 letbind in   letbind z 3 (exp 2 z)[0m
[34mMacro  0         out  (Î»z.exp 2 z) 3[0m
[34mMacro  0 letbind done (Î»z.exp 2 z) 3[0m
[35mEval: alphaEq ((Î»z.exp 2 z) 3) 8[0m
[35mAlpha left:  8[0m
[35mAlpha right: 8[0m
[32mAlpha passed - 300/304 (98.68%)[0m
[34mTime: 0.7 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::54[0m
[90mline 425 <<: [38;5;205m:macro (dup $x) => (pl[33mus $x $x)  # renamed from (double $x)[0m[0m[0m
[34mMacro 'dup' defined successfully[0m
[0m [0m
[90mline 426 <<: alphaEq ((dup 7)) 14[0m
[34mMacro  0 dup in   dup 7[0m
[34mMacro  0     out  plus 7 7[0m
[34mMacro  0 dup done plus 7 7[0m
[35mEval: alphaEq (plus 7 7) 14[0m
[35mAlpha left:  14[0m
[35mAlpha right: 14[0m
[32mAlpha passed - 301/305 (98.69%)[0m
[34mTime: 1.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 427 <<: alphaEq ((dup (succ 4))) 10[0m
[34mMacro  0 dup in   dup (succ 4)[0m
[34mMacro  0     out  plus (succ 4) (succ 4)[0m
[34mMacro  0 dup done plus (succ 4) (succ 4)[0m
[35mEval: alphaEq (plus (succ 4) (succ 4)) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 302/306 (98.69%)[0m
[34mTime: 1.1 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 428 <<: [38;5;205m:macro (triple $x) => (plus $x (plus $x $x))[0m[0m
[34mMacro 'triple' defined successfully[0m
[0m [0m
[90mline 429 <<: alphaEq ((triple 8)) 24[0m
[34mMacro  0 triple in   triple 8[0m
[34mMacro  0        out  plus 8 (plus 8 8)[0m
[34mMacro  0 triple done plus 8 (plus 8 8)[0m
[35mEval: alphaEq (plus 8 (plus 8 8)) 24[0m
[35mAlpha left:  24[0m
[35mAlpha right: 24[0m
[32mAlpha passed - 303/307 (98.70%)[0m
[34mTime: 1.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 430 <<: [38;5;205m:macro (when $cond $expr) => (if $cond $expr I)[0m[0m
[34mMacro 'when' defined successfully[0m
[0m [0m
[90mline 431 <<: alphaEq ((when true (succ 10))) 11[0m
[34mMacro  0 when in   when true (succ 10)[0m
[34mMacro  0      out  if true (succ 10) I[0m
[34mMacro  0 when done if true (succ 10) I[0m
[35mEval: alphaEq (if true (succ 10) I) 11[0m
[35mAlpha left:  11[0m
[35mAlpha right: 11[0m
[32mAlpha passed - 304/308 (98.70%)[0m
[34mTime: 1.2 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 432 <<: alphaEq ((when false (succ 10))) I[0m
[34mMacro  0 when in   when false (succ 10)[0m
[34mMacro  0      out  if false (succ 10) I[0m
[34mMacro  0 when done if false (succ 10) I[0m
[35mEval: alphaEq (if false (succ 10) I) I[0m
[35mAlpha left:  Î»x.x[0m
[35mAlpha right: Î»x.x[0m
[32mAlpha passed - 305/309 (98.71%)[0m
[34mTime: 0.6 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 433 <<: [38;5;205m:macro (unless $cond $expr) => (if $cond I $expr)[0m[0m
[34mMacro 'unless' defined successfully[0m
[0m [0m
[90mline 434 <<: alphaEq ((unless false (succ 20))) 21[0m
[34mMacro  0 unless in   unless false (succ 20)[0m
[34mMacro  0        out  if false I (succ 20)[0m
[34mMacro  0 unless done if false I (succ 20)[0m
[35mEval: alphaEq (if false I (succ 20)) 21[0m
[35mAlpha left:  21[0m
[35mAlpha right: 21[0m
[32mAlpha passed - 306/310 (98.71%)[0m
[34mTime: 1.8 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 435 <<: alphaEq ((unless true (succ 20))) I[0m
[34mMacro  0 unless in   unless true (succ 20)[0m
[34mMacro  0        out  if true I (succ 20)[0m
[34mMacro  0 unless done if true I (succ 20)[0m
[35mEval: alphaEq (if true I (succ 20)) I[0m
[35mAlpha left:  Î»x.x[0m
[35mAlpha right: Î»x.x[0m
[32mAlpha passed - 307/311 (98.71%)[0m
[34mTime: 1.2 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 436 <<: for x at [1..10] do (succ x)  [33m# retains list output[0m[0m
[34mMacro  0 for in   for x at ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) do (succ x)[0m
[34mMacro  0     out  map (Î»x.succ x) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[34mMacro  0 for done map (Î»x.succ x) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[35mEval: map (Î»x.succ x) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[34mTime: 4.0 ms, iterations: 301[0m
[32m-> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11][0m
[0m [0m
[90mline 437 <<: for x at [1..10] do (square x)[0m
[34mMacro  0 for     in   for x at ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) do (square x)[0m
[34mMacro  0         out  map (Î»x.square x) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[34mMacro  1 .square in   square x[0m
[34mMacro  1 .       out  mult x x[0m
[34mMacro  1 .square done mult x x[0m
[34mMacro  0 for     done map (Î»x.mult x x) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[35mEval: map (Î»x.mult x x) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[34mTime: 4.3 ms, iterations: 269[0m
[32m-> [1, 4, 9, 16, 25, 36, 49, 64, 81, 100][0m
[0m [0m
[90mline 438 <<: for x at [1..10] do (div x 2)[0m
[34mMacro  0 for in   for x at ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) do (div x 2)[0m
[34mMacro  0     out  map (Î»x.div x 2) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[34mMacro  0 for done map (Î»x.div x 2) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[35mEval: map (Î»x.div x 2) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[34mTime: 4.3 ms, iterations: 297[0m
[32m-> [false, 1, 1, 2, 2, 3, 3, 4, 4, 5][0m
[0m [0m
[90mline 439 <<: for x at [1..10] do (mod x 2)[0m
[34mMacro  0 for in   for x at ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) do (mod x 2)[0m
[34mMacro  0     out  map (Î»x.mod x 2) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[34mMacro  0 for done map (Î»x.mod x 2) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[35mEval: map (Î»x.mod x 2) ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[0m
[34mTime: 4.2 ms, iterations: 297[0m
[32m-> [1, false, 1, false, 1, false, 1, false, 1, false][0m
[0m [0m
[90mline 440 <<: alphaEq (iff false then 42 else 9) 9[0m
[34mMacro  0 iff in   iff false then 42 else 9[0m
[34mMacro  0     out  if false 42 9[0m
[34mMacro  0 iff done if false 42 9[0m
[35mEval: alphaEq (if false 42 9) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 308/312 (98.72%)[0m
[34mTime: 3.1 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 441 <<: alphaEq (iff true then 42 else 9) 42[0m
[34mMacro  0 iff in   iff true then 42 else 9[0m
[34mMacro  0     out  if true 42 9[0m
[34mMacro  0 iff done if true 42 9[0m
[35mEval: alphaEq (if true 42 9) 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 309/313 (98.72%)[0m
[34mTime: 3.7 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 442 <<: [38;5;205m:macro (swappair $p) => (pair (second $p) (first $p))[0m[0m
[34mMacro 'swappair' defined successfully[0m
[0m [0m
[90mline 443 <<: alphaEq ((swappair (pair 1 2))) (pair 2 1)[0m
[34mMacro  0 swappair in   swappair (pair 1 2)[0m
[34mMacro  0          out  pair (second (pair 1 2)) (first (pair 1 2))[0m
[34mMacro  0 swappair done pair (second (pair 1 2)) (first (pair 1 2))[0m
[35mEval: alphaEq (pair (second (pair 1 2)) (first (pair 1 2))) (pair 2 1)[0m
[35mAlpha left:  Î»f.f 2 1[0m
[35mAlpha right: Î»f.f 2 1[0m
[32mAlpha passed - 310/314 (98.73%)[0m
[34mTime: 1.0 ms, iterations: 43[0m
[32m-> true[0m
[0m [0m
[90mline 444 <<: [38;5;205m:macro (list3 $a $b $c) => (cons $a (cons $b (cons $c nil)))[0m[0m
[34mMacro 'list3' defined successfully[0m
[0m [0m
[90mline 445 <<: alphaEq ((list3 1 2 3)) [1,2,3][0m
[34mMacro  0 list3 in   list3 1 2 3[0m
[34mMacro  0       out  [1, 2, 3][0m
[34mMacro  0 list3 done [1, 2, 3][0m
[35mEval: alphaEq ([1, 2, 3]) ([1, 2, 3])[0m
[34mTime: 1.2 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 446 <<: [38;5;205m:macro (square $x) => (mult $x $x)[0m[0m
[34mMacro 'square' defined successfully[0m
[0m [0m
[90mline 447 <<: alphaEq ((square 6)) 36[0m
[34mMacro  0 square in   square 6[0m
[34mMacro  0        out  mult 6 6[0m
[34mMacro  0 square done mult 6 6[0m
[35mEval: alphaEq (mult 6 6) 36[0m
[34mTime: 2.0 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 448 <<: alphaEq ((square (plus 3 2))) 25[0m
[34mMacro  0 square in   square (plus 3 2)[0m
[34mMacro  0        out  mult (plus 3 2) (plus 3 2)[0m
[34mMacro  0 square done mult (plus 3 2) (plus 3 2)[0m
[35mEval: alphaEq (mult (plus 3 2) (plus 3 2)) 25[0m
[35mAlpha left:  25[0m
[35mAlpha right: 25[0m
[32mAlpha passed - 311/315 (98.73%)[0m
[34mTime: 1.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 449 <<: [38;5;205m:macro (cube $x) => (mult $x (mult $x $x))[0m[0m
[34mMacro 'cube' defined successfully[0m
[0m [0m
[90mline 450 <<: alphaEq ((cube 3)) 27[0m
[34mMacro  0 cube in   cube 3[0m
[34mMacro  0      out  mult 3 (mult 3 3)[0m
[34mMacro  0 cube done mult 3 (mult 3 3)[0m
[35mEval: alphaEq (mult 3 (mult 3 3)) 27[0m
[35mAlpha left:  27[0m
[35mAlpha right: 27[0m
[32mAlpha passed - 312/316 (98.73%)[0m
[34mTime: 1.7 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 451 <<: [38;5;205m:macro (between $x $low $high) => (and (geq $x $low) (leq $x $high))[0m[0m
[34mMacro 'between' defined successfully[0m
[0m [0m
[90mline 452 <<: alphaEq ((between 5 3 7)) true[0m
[34mMacro  0 between in   between 5 3 7[0m
[34mMacro  0         out  and (geq 5 3) (leq 5 7)[0m
[34mMacro  0 between done and (geq 5 3) (leq 5 7)[0m
[35mEval: alphaEq (and (geq 5 3) (leq 5 7)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 313/317 (98.74%)[0m
[34mTime: 1.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 453 <<: alphaEq ((between 2 3 7)) false[0m
[34mMacro  0 between in   between 2 3 7[0m
[34mMacro  0         out  and (geq 2 3) (leq 2 7)[0m
[34mMacro  0 between done and (geq 2 3) (leq 2 7)[0m
[35mEval: alphaEq (and (geq 2 3) (leq 2 7)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 314/318 (98.74%)[0m
[34mTime: 1.0 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 454 <<: alphaEq ((between 8 3 7)) false[0m
[34mMacro  0 between in   between 8 3 7[0m
[34mMacro  0         out  and (geq 8 3) (leq 8 7)[0m
[34mMacro  0 between done and (geq 8 3) (leq 8 7)[0m
[35mEval: alphaEq (and (geq 8 3) (leq 8 7)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 315/319 (98.75%)[0m
[34mTime: 1.6 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 455 <<: [38;5;205m:macro (inc $x) => (succ $x)[0m[0m
[34mMacro 'inc' defined successfully[0m
[0m [0m
[90mline 456 <<: [38;5;205m:macro (dec $x) => (pred $x)[0m[0m
[34mMacro 'dec' defined successfully[0m
[0m [0m
[90mline 457 <<: alphaEq ((inc 10)) 11[0m
[34mMacro  0 inc in   inc 10[0m
[34mMacro  0     out  succ 10[0m
[34mMacro  0 inc done succ 10[0m
[35mEval: alphaEq (succ 10) 11[0m
[35mAlpha left:  11[0m
[35mAlpha right: 11[0m
[32mAlpha passed - 316/320 (98.75%)[0m
[34mTime: 1.1 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 458 <<: alphaEq ((dec 10)) 9[0m
[34mMacro  0 dec in   dec 10[0m
[34mMacro  0     out  pred 10[0m
[34mMacro  0 dec done pred 10[0m
[35mEval: alphaEq (pred 10) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 317/321 (98.75%)[0m
[34mTime: 1.0 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 459 <<: alphaEq ((inc (square 4))) 17[0m
[34mMacro  0 inc     in   inc (square 4)[0m
[34mMacro  0         out  succ (square 4)[0m
[34mMacro  1 .square in   square 4[0m
[34mMacro  1 .       out  mult 4 4[0m
[34mMacro  1 .square done mult 4 4[0m
[34mMacro  0 inc     done succ (mult 4 4)[0m
[35mEval: alphaEq (succ (mult 4 4)) 17[0m
[35mAlpha left:  17[0m
[35mAlpha right: 17[0m
[32mAlpha passed - 318/322 (98.76%)[0m
[34mTime: 1.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 460 <<: alphaEq ((square (inc 4))) 25[0m
[34mMacro  0 square  in   square (inc 4)[0m
[34mMacro  0         out  mult (inc 4) (inc 4)[0m
[34mMacro  1 .inc    in   inc 4[0m
[34mMacro  1 .       out  succ 4[0m
[34mMacro  1 .inc    done succ 4[0m
[34mMacro  1 .inc    in   inc 4[0m
[34mMacro  1 .       out  succ 4[0m
[34mMacro  1 .inc    done succ 4[0m
[34mMacro  0 square  done mult (succ 4) (succ 4)[0m
[35mEval: alphaEq (mult (succ 4) (succ 4)) 25[0m
[34mTime: 1.5 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 461 <<: [38;5;205m:macro (quadratic $a $b $c $x) => (plus (mult $a (square $x)) (plus (mult $b $x) $c))[0m[0m
[34mMacro 'quadratic' defined successfully[0m
[0m [0m
[90mline 462 <<: alphaEq ((quadratic 2 3 1 4)) 45[0m
[34mMacro  0 quadratic  in   quadratic 2 3 1 4[0m
[34mMacro  0            out  plus (mult 2 (square 4)) (plus (mult 3 4) 1)[0m
[34mMacro  1 .square    in   square 4[0m
[34mMacro  1 .          out  mult 4 4[0m
[34mMacro  1 .square    done mult 4 4[0m
[34mMacro  0 quadratic  done plus (mult 2 (mult 4 4)) (plus (mult 3 4) 1)[0m
[35mEval: alphaEq (plus (mult 2 (mult 4 4)) (plus (mult 3 4) 1)) 45[0m
[35mAlpha left:  45[0m
[35mAlpha right: 45[0m
[32mAlpha passed - 319/323 (98.76%)[0m
[34mTime: 3.2 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 463 <<: [38;5;205m:macro (fact2 $n) => (if (iszero $n) 1 (mult $n (fact2 (pr[33med $n))))  # not structurally testable (recursive macro) left as definition[0m[0m[0m
[34mMacro 'fact2' defined successfully[0m
[0m [0m
[90mline 464 <<: [0m
[0mPROGRESS::59[0m
[90mline 465 <<: [33m# Additional macro capability tests already at end of original file (kept as-is or identity comparisons)[0m[0m
[90mline 466 <<: [0m
[90mline 467 <<: [33m# ============================================================================[0m[0m
[90mline 468 <<: [33m# Extended Coverage: Advanced Macro / Variadic / Guards / Ordering / Lazy / Church Lists[0m[0m
[90mline 469 <<: [33m# ============================================================================[0m[0m
[90mline 470 <<: [0m
[90mline 471 <<: [33m# --- Advanced Macro System (Arity & Ordering) ---[0m[0m
[90mline 472 <<: [38;5;205m:macro (arityDemo) => 0[0m[0m
[34mMacro 'arityDemo' defined successfully[0m
[0m [0m
[90mline 473 <<: [38;5;205m:macro (arityDemo $a) => 1[0m[0m
[34mMacro 'arityDemo' defined successfully[0m
[0m [0m
[90mline 474 <<: [38;5;205m:macro (arityDemo $a $b) => 2[0m[0m
[34mMacro 'arityDemo' defined successfully[0m
[0m [0m
[90mline 475 <<: alphaEq (arityDemo) 0[0m
[34mMacro  0 arityDemo in   arityDemo[0m
[34mMacro  0           out  false[0m
[34mMacro  0 arityDemo done false[0m
[35mEval: alphaEq false false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 320/324 (98.77%)[0m
[34mTime: 0.5 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 476 <<: alphaEq (arityDemo 42) 1[0m
[34mMacro  0 arityDemo in   arityDemo 42[0m
[34mMacro  0           out  1[0m
[34mMacro  0 arityDemo done 1[0m
[35mEval: alphaEq 1 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 321/325 (98.77%)[0m
[34mTime: 0.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 477 <<: alphaEq (arityDemo 7 8) 2[0m
[34mMacro  0 arityDemo in   arityDemo 7 8[0m
[34mMacro  0           out  2[0m
[34mMacro  0 arityDemo done 2[0m
[35mEval: alphaEq 2 2[0m
[35mAlpha left:  2[0m
[35mAlpha right: 2[0m
[32mAlpha passed - 322/326 (98.77%)[0m
[34mTime: 0.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 478 <<: [0m
[90mline 479 <<: [33m# --- Variadic Macros ---[0m[0m
[90mline 480 <<: [38;5;205m:macro (listify $xs...) => $xs[0m[0m
[34mMacro 'listify' defined successfully[0m
[0m [0m
[90mline 481 <<: alphaEq (listify) nil[0m
[34mMacro  0 listify in   listify[0m
[34mMacro  0         out  [][0m
[34mMacro  0 listify done [][0m
[35mEval: alphaEq [] [][0m
[34mTime: 0.2 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 482 <<: alphaEq (listify 1) [1][0m
[34mMacro  0 listify in   listify 1[0m
[34mMacro  0         out  [1][0m
[34mMacro  0 listify done [1][0m
[35mEval: alphaEq ([1]) ([1])[0m
[35mAlpha left:  [1][0m
[35mAlpha right: [1][0m
[32mAlpha passed - 323/327 (98.78%)[0m
[34mTime: 0.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 483 <<: alphaEq (listify 1 2 3) [1,2,3][0m
[34mMacro  0 listify in   listify 1 2 3[0m
[34mMacro  0         out  [1, 2, 3][0m
[34mMacro  0 listify done [1, 2, 3][0m
[35mEval: alphaEq ([1, 2, 3]) ([1, 2, 3])[0m
[34mTime: 1.2 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 484 <<: [0m
[90mline 485 <<: [33m# Variadic with fixed prefix[0m[0m
[90mline 486 <<: [38;5;205m:macro (sumall $x $rest...) => (foldl plus $x $rest)[0m[0m
[34mMacro 'sumall' defined successfully[0m
[0m [0m
[90mline 487 <<: alphaEq (sumall 5) 5[0m
[34mMacro  0 sumall in   sumall 5[0m
[34mMacro  0        out  foldl plus 5 [][0m
[34mMacro  0 sumall done foldl plus 5 [][0m
[35mEval: alphaEq (foldl plus 5 []) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 324/328 (98.78%)[0m
[34mTime: 0.9 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 488 <<: alphaEq (sumall 1 2 3 4) 10[0m
[34mMacro  0 sumall in   sumall 1 2 3 4[0m
[34mMacro  0        out  foldl plus 1 ([2, 3, 4])[0m
[34mMacro  0 sumall done foldl plus 1 ([2, 3, 4])[0m
[35mEval: alphaEq (foldl plus 1 ([2, 3, 4])) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 325/329 (98.78%)[0m
[34mTime: 1.7 ms, iterations: 103[0m
[32m-> true[0m
[0m [0m
[90mline 489 <<: [0m
[90mline 490 <<: [33m# --- Guarded Macros & Recency ---[0m[0m
[90mline 491 <<: [38;5;205m:macro (choose $x) when false => 0[0m[0m
[34mMacro 'choose' defined successfully[0m
[0m [0m
[90mline 492 <<: [38;5;205m:macro (choose $x) => $x[0m[0m
[34mMacro 'choose' defined successfully[0m
[0m [0m
[90mline 493 <<: alphaEq (choose 9) 9[0m
[34mMacro  0 choose in   choose 9[0m
[34mMacro  0        out  9[0m
[34mMacro  0 choose done 9[0m
[35mEval: alphaEq 9 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 326/330 (98.79%)[0m
[34mTime: 1.2 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 494 <<: [0m
[90mline 495 <<: [38;5;205m:macro (choose2 $x) => $x[0m[0m
[34mMacro 'choose2' defined successfully[0m
[0m [0m
[90mline 496 <<: [38;5;205m:macro (choose2 $x) when true => 42[0m[0m
[34mMacro 'choose2' defined successfully[0m
[0m [0m
[90mline 497 <<: alphaEq (choose2 7) 42[0m
[34mMacro  0 choose2 in   choose2 7[0m
[34mMacro  0         out  42[0m
[34mMacro  0 choose2 done 42[0m
[35mEval: alphaEq 42 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 327/331 (98.79%)[0m
[34mTime: 4.3 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 498 <<: [0m
[90mline 499 <<: [33m# Guard depending on variable (literal false only fails)[0m[0m
[90mline 500 <<: [38;5;205m:macro (guardVar $flag $x) => 0[0m[0m
[34mMacro 'guardVar' defined successfully[0m
[0m [0m
[90mline 501 <<: [38;5;205m:macro (guardVar $flag $x) when $flag => $x[0m[0m
[34mMacro 'guardVar' defined successfully[0m
[0m [0m
[90mline 502 <<: alphaEq (guardVar true 7) 7[0m
[34mMacro  0 guardVar in   guardVar true 7[0m
[34mMacro  0          out  7[0m
[34mMacro  0 guardVar done 7[0m
[35mEval: alphaEq 7 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 328/332 (98.80%)[0m
[34mTime: 0.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 503 <<: alphaEq (guardVar false 7) 0[0m
[34mMacro  0 guardVar in   guardVar false 7[0m
[34mMacro  0          out  false[0m
[34mMacro  0 guardVar done false[0m
[35mEval: alphaEq false false[0m
[34mTime: 0.2 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::64[0m
[90mline 504 <<: [0m
[90mline 505 <<: [33m# Higher arity precedence[0m[0m
[90mline 506 <<: [38;5;205m:macro (pref $x $y) => (mult $x $y)[0m[0m
[34mMacro 'pref' defined successfully[0m
[0m [0m
[90mline 507 <<: [38;5;205m:macro (pref $x) => (succ $x)[0m[0m
[34mMacro 'pref' defined successfully[0m
[0m [0m
[90mline 508 <<: alphaEq (pref 3 4) 12[0m
[34mMacro  0 pref in   pref 3 4[0m
[34mMacro  0      out  mult 3 4[0m
[34mMacro  0 pref done mult 3 4[0m
[35mEval: alphaEq (mult 3 4) 12[0m
[34mTime: 1.3 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 509 <<: alphaEq (pref 5) 6[0m
[34mMacro  0 pref in   pref 5[0m
[34mMacro  0      out  succ 5[0m
[34mMacro  0 pref done succ 5[0m
[35mEval: alphaEq (succ 5) 6[0m
[34mTime: 0.8 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 510 <<: [0m
[90mline 511 <<: [33m# Recency (shadowing)[0m[0m
[90mline 512 <<: [38;5;205m:macro (shadow $x) => (plus $x 1)[0m[0m
[34mMacro 'shadow' defined successfully[0m
[0m [0m
[90mline 513 <<: [38;5;205m:macro (shadow $x) => (plus $x 2)[0m[0m
[34mMacro 'shadow' defined successfully[0m
[0m [0m
[90mline 514 <<: alphaEq (shadow 3) 5[0m
[34mMacro  0 shadow in   shadow 3[0m
[34mMacro  0        out  plus 3 2[0m
[34mMacro  0 shadow done plus 3 2[0m
[35mEval: alphaEq (plus 3 2) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 329/333 (98.80%)[0m
[34mTime: 0.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 515 <<: [0m
[90mline 516 <<: [33m# Exact match vs rest capture precedence[0m[0m
[90mline 517 <<: [38;5;205m:macro (mix $a $b) => (plus $a $b)[0m[0m
[34mMacro 'mix' defined successfully[0m
[0m [0m
[90mline 518 <<: [38;5;205m:macro (mix $a $rest...) => (foldl plus $a $rest)[0m[0m
[34mMacro 'mix' defined successfully[0m
[0m [0m
[90mline 519 <<: alphaEq (mix 2 3) 5[0m
[34mMacro  0 mix in   mix 2 3[0m
[34mMacro  0     out  foldl plus 2 ([3])[0m
[34mMacro  0 mix done foldl plus 2 ([3])[0m
[35mEval: alphaEq (foldl plus 2 ([3])) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 330/334 (98.80%)[0m
[34mTime: 1.0 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 520 <<: alphaEq (mix 2 3 4 5) 14[0m
[34mMacro  0 mix in   mix 2 3 4 5[0m
[34mMacro  0     out  foldl plus 2 ([3, 4, 5])[0m
[34mMacro  0 mix done foldl plus 2 ([3, 4, 5])[0m
[35mEval: alphaEq (foldl plus 2 ([3, 4, 5])) 14[0m
[35mAlpha left:  14[0m
[35mAlpha right: 14[0m
[32mAlpha passed - 331/335 (98.81%)[0m
[34mTime: 2.4 ms, iterations: 95[0m
[32m-> true[0m
[0m [0m
[90mline 521 <<: [0m
[90mline 522 <<: [33m# --- Pair Equality Helper (uses stdlib pairEq) ---[0m[0m
[90mline 523 <<: alphaEq (pairEq eq eq (pair 1 2) (pair 1 2)) true[0m
[35mEval: alphaEq (pairEq eq eq (pair 1 2) (pair 1 2)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 332/336 (98.81%)[0m
[34mTime: 1.3 ms, iterations: 115[0m
[32m-> true[0m
[0m [0m
[90mline 524 <<: [0m
[90mline 525 <<: [33m# --- Church List Round Trip ---[0m[0m
[90mline 526 <<: [33m# Build a Church-encoded list and fold it with cons/nil to a concrete list[0m[0m
[90mline 527 <<: alphaEq (((Î»f.Î»z.f 1 (f 2 (f 3 z))) (Î»h.Î»t.cons h t)) nil) [1,2,3][0m
[35mEval: alphaEq (([1, 2, 3]) (Î»h.Î»t.cons h t) []) ([1, 2, 3])[0m
[35mAlpha left:  [1, 2, 3][0m
[35mAlpha right: [1, 2, 3][0m
[32mAlpha passed - 333/337 (98.81%)[0m
[34mTime: 2.0 ms, iterations: 59[0m
[32m-> true[0m
[0m [0m
[90mline 528 <<: [0m
[90mline 529 <<: [33m# --- Lazy Evaluation (ensure unused branch not evaluated) ---[0m[0m
[90mline 530 <<: [33m# Î© (diverges if forced) = (Î»x.x x) (Î»x.x x)[0m[0m[32m;[0m[90m use built inline[0m
[90mline 531 <<: alphaEq (if true 1 ((Î»x.x x) (Î»x.x x))) 1[0m
[35mEval: alphaEq (if true 1 ((Î»x.x x) (Î»x.x x))) 1[0m
[35mAlpha left:  1[0m
[35mAlpha right: 1[0m
[32mAlpha passed - 334/338 (98.82%)[0m
[34mTime: 0.7 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 532 <<: [0m
[90mline 533 <<: [33m# --- Variadic / Utility Macro Extensions ---[0m[0m
[90mline 534 <<: [38;5;205m:macro (duplicate $x) => (pair $x $x)[0m[0m
[34mMacro 'duplicate' defined successfully[0m
[0m [0m
[90mline 535 <<: alphaEq (duplicate 7) (pair 7 7)[0m
[34mMacro  0 duplicate in   duplicate 7[0m
[34mMacro  0           out  pair 7 7[0m
[34mMacro  0 duplicate done pair 7 7[0m
[35mEval: alphaEq (pair 7 7) (pair 7 7)[0m
[35mAlpha left:  Î»f.f 7 7[0m
[35mAlpha right: Î»f.f 7 7[0m
[32mAlpha passed - 335/339 (98.82%)[0m
[34mTime: 2.0 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 536 <<: [0m
[90mline 537 <<: [33m# Complex nested macro example for process style (inc (square (dec x)))[0m[0m
[90mline 538 <<: [38;5;205m:macro (dec2 $x) => (pred $x)[0m[0m
[34mMacro 'dec2' defined successfully[0m
[0m [0m
[90mline 539 <<: [38;5;205m:macro (process2 $x) => (inc (square (dec2 $x)))[0m[0m
[34mMacro 'process2' defined successfully[0m
[0m [0m
[90mline 540 <<: alphaEq (process2 5) 17[0m
[34mMacro  0 process2    in   process2 5[0m
[34mMacro  0             out  inc (square (dec2 5))[0m
[34mMacro  1 .inc        in   inc (square (dec2 5))[0m
[34mMacro  1 .           out  succ (square (dec2 5))[0m
[34mMacro  2 ..square    in   square (dec2 5)[0m
[34mMacro  2 ..          out  mult (dec2 5) (dec2 5)[0m
[34mMacro  3 ...dec2     in   dec2 5[0m
[34mMacro  3 ...         out  pred 5[0m
[34mMacro  3 ...dec2     done pred 5[0m
[34mMacro  3 ...dec2     in   dec2 5[0m
[34mMacro  3 ...         out  pred 5[0m
[34mMacro  3 ...dec2     done pred 5[0m
[34mMacro  2 ..square    done mult (pred 5) (pred 5)[0m
[34mMacro  1 .inc        done succ (mult (pred 5) (pred 5))[0m
[34mMacro  0 process2    done succ (mult (pred 5) (pred 5))[0m
[35mEval: alphaEq (succ (mult (pred 5) (pred 5))) 17[0m
[35mAlpha left:  17[0m
[35mAlpha right: 17[0m
[32mAlpha passed - 336/340 (98.82%)[0m
[34mTime: 2.1 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 541 <<: [0m
[90mline 542 <<: [33m# Macro composition ordering (outer/inner)[0m[0m
[90mline 543 <<: [38;5;205m:macro (outer $x) => (inner (plus $x 1))[0m[0m
[34mMacro 'outer' defined successfully[0m
[0m [0m
[0mPROGRESS::69[0m
[90mline 544 <<: [38;5;205m:macro (inner $y) => (mult $y 2)[0m[0m
[34mMacro 'inner' defined successfully[0m
[0m [0m
[90mline 545 <<: alphaEq (outer 4) 10[0m
[34mMacro  0 outer  in   outer 4[0m
[34mMacro  0        out  inner (plus 4 1)[0m
[34mMacro  1 .inner in   inner (plus 4 1)[0m
[34mMacro  1 .      out  mult (plus 4 1) 2[0m
[34mMacro  1 .inner done mult (plus 4 1) 2[0m
[34mMacro  0 outer  done mult (plus 4 1) 2[0m
[35mEval: alphaEq (mult (plus 4 1) 2) 10[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 337/341 (98.83%)[0m
[34mTime: 1.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 546 <<: [0m
[90mline 547 <<: [33m# Apply twice (higher-order macro)[0m[0m
[90mline 548 <<: [38;5;205m:macro (apply_twice $f $x) => ($f ($f $x))[0m[0m
[34mMacro 'apply_twice' defined successfully[0m
[0m [0m
[90mline 549 <<: alphaEq (apply_twice succ 0) 2[0m
[34mMacro  0 apply_twice in   apply_twice succ false[0m
[34mMacro  0             out  succ (succ false)[0m
[34mMacro  0 apply_twice done succ (succ false)[0m
[35mEval: alphaEq (succ (succ false)) 2[0m
[35mAlpha left:  2[0m
[35mAlpha right: 2[0m
[32mAlpha passed - 338/342 (98.83%)[0m
[34mTime: 0.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 550 <<: alphaEq (apply_twice (Î»x.mult x 2) 3) 12[0m
[34mMacro  0 apply_twice in   apply_twice (Î»x.mult x 2) 3[0m
[34mMacro  0             out  (Î»x.mult x 2) ((Î»x.mult x 2) 3)[0m
[34mMacro  0 apply_twice done (Î»x.mult x 2) ((Î»x.mult x 2) 3)[0m
[35mEval: alphaEq ((Î»x.mult x 2) ((Î»x.mult x 2) 3)) 12[0m
[35mAlpha left:  12[0m
[35mAlpha right: 12[0m
[32mAlpha passed - 339/343 (98.83%)[0m
[34mTime: 1.9 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 551 <<: [0m
[90mline 552 <<: [33m# Composition macro reuse with new 'dup' macro already defined earlier[0m[0m
[90mline 553 <<: [38;5;205m:macro (compose2b $f $g $x) => ($f ($g $x))[0m[0m
[34mMacro 'compose2b' defined successfully[0m
[0m [0m
[90mline 554 <<: alphaEq (compose2b succ dup 5) 11[0m
[34mMacro  0 compose2b  in   compose2b succ dup 5[0m
[34mMacro  0            out  succ (dup 5)[0m
[34mMacro  1 .dup       in   dup 5[0m
[34mMacro  1 .          out  plus 5 5[0m
[34mMacro  1 .dup       done plus 5 5[0m
[34mMacro  0 compose2b  done succ (plus 5 5)[0m
[35mEval: alphaEq (succ (plus 5 5)) 11[0m
[35mAlpha left:  11[0m
[35mAlpha right: 11[0m
[32mAlpha passed - 340/344 (98.84%)[0m
[34mTime: 1.7 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 555 <<: [0m
[90mline 556 <<: [33m# Final complex macro calculation (mirrors complex_calc)[0m[0m
[90mline 557 <<: [38;5;205m:macro (complex_calc $a $b $c) => (letbind x (plus $a $b) (letbind y (mult x $c) (square y)))[0m[0m
[34mMacro 'complex_calc' defined successfully[0m
[0m [0m
[90mline 558 <<: alphaEq (complex_calc 2 3 4) 400[0m
[34mMacro  0 complex_calc    in   complex_calc 2 3 4[0m
[34mMacro  0                 out  letbind x (plus 2 3) (letbind y (mult x 4) (square y))[0m
[34mMacro  1 .letbind        in   letbind x (plus 2 3) (letbind y (mult x 4) (square y))[0m
[34mMacro  1 .               out  (Î»x.letbind y (mult x 4) (square y)) (plus 2 3)[0m
[34mMacro  2 ..letbind       in   letbind y (mult x 4) (square y)[0m
[34mMacro  2 ..              out  (Î»y.square y) (mult x 4)[0m
[34mMacro  3 ...square       in   square y[0m
[34mMacro  3 ...             out  mult y y[0m
[34mMacro  3 ...square       done mult y y[0m
[34mMacro  2 ..letbind       done (Î»y.mult y y) (mult x 4)[0m
[34mMacro  1 .letbind        done (Î»x.(Î»y.mult y y) (mult x 4)) (plus 2 3)[0m
[34mMacro  0 complex_calc    done (Î»x.(Î»y.mult y y) (mult x 4)) (plus 2 3)[0m
[35mEval: alphaEq ((Î»x.(Î»y.mult y y) (mult x 4)) (plus 2 3)) 400[0m
[35mAlpha left:  400[0m
[35mAlpha right: 400[0m
[32mAlpha passed - 341/345 (98.84%)[0m
[34mTime: 25.8 ms, iterations: 11[0m
[32m-> true[0m
[0m [0m
[90mline 559 <<: [0m
[90mline 560 <<: [33m# Note: Eta-equivalence not tested (Î»x.f x vs f) â€“ current equality is alpha only.[0m[0m
[90mline 561 <<: [0m
[90mline 562 <<: [33m# ============================================================================[0m[0m
[90mline 563 <<: [33m# Essential Additional Core Law Tests[0m[0m
[90mline 564 <<: [33m# ============================================================================[0m[0m
[90mline 565 <<: [0m
[90mline 566 <<: [33m# Alpha-equivalence (binder renaming) & capture avoidance[0m[0m
[90mline 567 <<: alphaEq (Î»x.Î»y.x) (Î»a.Î»b.a)[0m
[35mEval: alphaEq (true) (true)[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 342/346 (98.84%)[0m
[34mTime: 0.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 568 <<: alphaEq ((Î»x.Î»y.x) 1) (Î»z.1)[0m
[35mEval: alphaEq ((true) 1) (Î»z.1)[0m
[35mAlpha left:  Î»y.1[0m
[35mAlpha right: Î»z.1[0m
[32mAlpha passed - 343/347 (98.85%)[0m
[34mTime: 0.5 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 569 <<: alphaEq (Î»x.Î»x.Î»x.x) (Î»a.Î»b.Î»c.c)  [33m# inner shadowing[0m[0m
[35mEval: alphaEq (Î»x.true) (Î»a.false)[0m
[35mAlpha left:  Î»x.true[0m
[35mAlpha right: Î»a.false[0m
[31mAlpha failed - 5/348 (1.44%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 0.3 ms, iterations: 3[0m
[32m-> false[0m
[0m [0m
[90mline 570 <<: alphaEq ((Î»x.Î»x.Î»x.x) 1 2 3) ((Î»a.Î»b.Î»c.c) 1 2 3) [33m# inner shadowing with application[0m[0m
[35mEval: alphaEq ((Î»x.true) 1 2 3) ((Î»a.false) 1 2 3)[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 344/349 (98.57%)[0m
[34mTime: 1.8 ms, iterations: 27[0m
[32m-> true[0m
[0m [0m
[90mline 571 <<: [0m
[90mline 572 <<: [33m# Combinator Laws[0m[0m
[90mline 573 <<: alphaEq ((S K K) 5) 5[0m
[35mEval: alphaEq (S K K 5) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 345/350 (98.57%)[0m
[34mTime: 0.9 ms, iterations: 27[0m
[32m-> true[0m
[0m [0m
[90mline 574 <<: alphaEq ((S K I) 7) 7[0m
[35mEval: alphaEq (S K I 7) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 346/351 (98.58%)[0m
[34mTime: 1.3 ms, iterations: 27[0m
[32m-> true[0m
[0m [0m
[90mline 575 <<: [0m
[90mline 576 <<: [33m# Arithmetic Identity Laws[0m[0m
[90mline 577 <<: alphaEq (plus 7 0) 7[0m
[35mEval: alphaEq (plus 7 false) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 347/352 (98.58%)[0m
[34mTime: 1.1 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 578 <<: alphaEq (plus 0 9) 9[0m
[35mEval: alphaEq (plus false 9) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 348/353 (98.58%)[0m
[34mTime: 1.4 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 579 <<: alphaEq (mult 9 1) 9[0m
[35mEval: alphaEq (mult 9 1) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 349/354 (98.59%)[0m
[34mTime: 1.5 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 580 <<: alphaEq (mult 9 0) 0[0m
[35mEval: alphaEq (mult 9 false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 350/355 (98.59%)[0m
[34mTime: 0.8 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 581 <<: alphaEq (minus 5 0) 5[0m
[35mEval: alphaEq (minus 5 false) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 351/356 (98.60%)[0m
[34mTime: 1.1 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 582 <<: [0m
[0mPROGRESS::74[0m
[90mline 583 <<: [33m# List Functor Identity[0m[0m
[90mline 584 <<: alphaEq (map I [1,2,3]) [1,2,3][0m
[35mEval: alphaEq (map I ([1, 2, 3])) ([1, 2, 3])[0m
[35mAlpha left:  [1, 2, 3][0m
[35mAlpha right: [1, 2, 3][0m
[32mAlpha passed - 352/357 (98.60%)[0m
[34mTime: 2.1 ms, iterations: 103[0m
[32m-> true[0m
[0m [0m
[90mline 585 <<: [0m
[90mline 586 <<: [33m# Lazy Evaluation (false branch)[0m[0m
[90mline 587 <<: alphaEq (if false ((Î»x.x x) (Î»x.x x)) 2) 2[0m
[35mEval: alphaEq (if false ((Î»x.x x) (Î»x.x x)) 2) 2[0m
[35mAlpha left:  2[0m
[35mAlpha right: 2[0m
[32mAlpha passed - 353/358 (98.60%)[0m
[34mTime: 0.8 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 588 <<: [0m
[90mline 589 <<: [33m# Nested Pair Equality using pairEq[0m[0m
[90mline 590 <<: [33m# alphaEq (pairEq eq eq (pair (pair 1 2) (pair 3 4)) (pair (pair 1 2) (pair 3 4))) true[0m[0m
[90mline 591 <<: [0m
[90mline 592 <<: [33m# ============================================================================[0m[0m
[90mline 593 <<: [33m# Additional Positive Law / Property Tests (no negatives)[0m[0m
[90mline 594 <<: [33m# ============================================================================[0m[0m
[90mline 595 <<: [0m
[90mline 596 <<: [33m# Maybe Functor Laws[0m[0m
[90mline 597 <<: alphaEq (maybeMap I (just 5)) (just 5)                     [33m# identity[0m[0m
[35mEval: alphaEq (maybeMap I (just 5)) (just 5)[0m
[35mAlpha left:  Î»f.f (true) 5[0m
[35mAlpha right: Î»f.f (true) 5[0m
[32mAlpha passed - 354/359 (98.61%)[0m
[34mTime: 1.2 ms, iterations: 45[0m
[32m-> true[0m
[0m [0m
[90mline 598 <<: alphaEq (maybeMap (Î»x.mult x x) (maybeMap succ (just 3))) (just 16)   [33m# composition exemplar[0m[0m
[35mEval: alphaEq (maybeMap (Î»x.mult x x) (maybeMap succ (just 3))) (just 16)[0m
[35mAlpha left:  Î»f.f (true) 16[0m
[35mAlpha right: Î»f.f (true) 16[0m
[32mAlpha passed - 355/360 (98.61%)[0m
[34mTime: 2.4 ms, iterations: 123[0m
[32m-> true[0m
[0m [0m
[90mline 599 <<: [0m
[90mline 600 <<: [33m# Either usage (Right-biased behavior already covered)[0m[0m
[90mline 601 <<: alphaEq (either succ succ (left 5)) 6[0m
[35mEval: alphaEq (either succ succ (left 5)) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 356/361 (98.61%)[0m
[34mTime: 1.0 ms, iterations: 53[0m
[32m-> true[0m
[0m [0m
[90mline 602 <<: alphaEq (either succ succ (right 5)) 6[0m
[35mEval: alphaEq (either succ succ (right 5)) 6[0m
[35mAlpha left:  6[0m
[35mAlpha right: 6[0m
[32mAlpha passed - 357/362 (98.62%)[0m
[34mTime: 1.2 ms, iterations: 81[0m
[32m-> true[0m
[0m [0m
[90mline 603 <<: [0m
[90mline 604 <<: [33m# Append associativity[0m[0m
[90mline 605 <<: alphaEq (append (append [1] [2]) [3]) (append [1] (append [2] [3]))[0m
[35mEval: alphaEq (append (append ([1]) ([2])) ([3])) (append ([1]) (append ([2]) ([3])))[0m
[35mAlpha left:  [1, 2, 3][0m
[35mAlpha right: [1, 2, 3][0m
[32mAlpha passed - 358/363 (98.62%)[0m
[34mTime: 2.2 ms, iterations: 115[0m
[32m-> true[0m
[0m [0m
[90mline 606 <<: [0m
[90mline 607 <<: [33m# Reverse distributes over append: reverse (xs ++ ys) = reverse ys ++ reverse xs[0m[0m
[90mline 608 <<: alphaEq (reverse (append [1,2] [3,4,5])) (append (reverse [3,4,5]) (reverse [1,2]))[0m
[35mEval: alphaEq (reverse (append ([1, 2]) ([3, 4, 5]))) (append (reverse ([3, 4, 5])) (reverse ([1, 2])))[0m
[35mAlpha left:  [5, 4, 3, 2, 1][0m
[35mAlpha right: [5, 4, 3, 2, 1][0m
[32mAlpha passed - 359/364 (98.63%)[0m
[34mTime: 4.4 ms, iterations: 391[0m
[32m-> true[0m
[0m [0m
[90mline 609 <<: [0m
[90mline 610 <<: [33m# Map length invariant[0m[0m
[90mline 611 <<: alphaEq (length (map succ [1,2,3,4])) (length [1,2,3,4])[0m
[35mEval: alphaEq (length (map succ ([1, 2, 3, 4]))) (length ([1, 2, 3, 4]))[0m
[35mAlpha left:  4[0m
[35mAlpha right: 4[0m
[32mAlpha passed - 360/365 (98.63%)[0m
[34mTime: 3.1 ms, iterations: 271[0m
[32m-> true[0m
[0m [0m
[90mline 612 <<: [0m
[90mline 613 <<: [33m# Sum via fold equivalence[0m[0m
[90mline 614 <<: alphaEq (sum [1,2,3,4]) (foldl plus 0 [1,2,3,4])[0m
[35mEval: alphaEq (sum ([1, 2, 3, 4])) (foldl plus false ([1, 2, 3, 4]))[0m
[35mAlpha left:  10[0m
[35mAlpha right: 10[0m
[32mAlpha passed - 361/366 (98.63%)[0m
[34mTime: 3.0 ms, iterations: 75[0m
[32m-> true[0m
[0m [0m
[90mline 615 <<: [0m
[90mline 616 <<: [33m# Maybe bind laws (using bind defined above)[0m[0m
[90mline 617 <<: alphaEq (bind (just 5) (Î»x.just (plus x 1))) (just 6)      [33m# left identity exemplar[0m[0m
[35mEval: alphaEq (bind (just 5) (Î»x.just (plus x 1))) (just 6)[0m
[35mAlpha left:  Î»f.f (true) 6[0m
[35mAlpha right: Î»f.f (true) 6[0m
[32mAlpha passed - 362/367 (98.64%)[0m
[34mTime: 1.3 ms, iterations: 45[0m
[32m-> true[0m
[0m [0m
[90mline 618 <<: alphaEq (bind (just 7) just) (just 7)                     [33m# right identity exemplar[0m[0m
[35mEval: alphaEq (bind (just 7) just) (just 7)[0m
[35mAlpha left:  Î»f.f (true) 7[0m
[35mAlpha right: Î»f.f (true) 7[0m
[32mAlpha passed - 363/368 (98.64%)[0m
[34mTime: 1.4 ms, iterations: 41[0m
[32m-> true[0m
[0m [0m
[90mline 619 <<: [0m
[90mline 620 <<: [33m# Tree: size equals length of inorder traversal[0m[0m
[90mline 621 <<: alphaEq (treeSize (node 1 (leaf 2) (leaf 3))) (length (inOrder (node 1 (leaf 2) (leaf 3))))[0m
[35mEval: alphaEq (treeSize (node 1 (leaf 2) (leaf 3))) (length (inOrder (node 1 (leaf 2) (leaf 3))))[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 364/369 (98.64%)[0m
[34mTime: 2.3 ms, iterations: 447[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::79[0m
[90mline 622 <<: [0m
[90mline 623 <<: [33m# test multiple commands in a single line[0m[0m
[90mline 624 <<: plus 1 3[0m[32m;[0m[90m mult 2 4[0m[32m;[0m[90m minus 5 1[0m[32m;[0m[90m fib 10[0m
[35mEval: plus 1 3[0m
[35mEval: mult 2 4[0m
[35mEval: minus 5 1[0m
[35mEval: fib 10[0m
[34mName: [Church numeral: 55] [0m
[34mTime: 2.3 ms, iterations: 4[0m
[32m-> 4
-> 8
-> 4
-> 55[0m
[0m [0m
[90mline 625 <<: plus 4 3[0m[32m;[0m[90m [38;5;205m:macro (aa $a) => (plus $a $a)[0m[0m[32m;[0m[90m aa 4[0m
[35mEval: plus 4 3[0m
[34mMacro  0 aa in   aa 4[0m
[34mMacro  0    out  plus 4 4[0m
[34mMacro  0 aa done plus 4 4[0m
[35mEval: plus 4 4[0m
[34mName: [Church numeral: 8] [0m
[34mTime: 1.5 ms, iterations: 2[0m
[32m-> 7
Macro 'aa' defined successfully
-> 8[0m
[0m [0m
[90mline 626 <<: plus 4 3[0m[32m;[0m[90m [38;5;205m:macro (bb $a) => (plus $a $a)[0m[0m[32m;[0m[90m bb 4[0m[32m;[0m[90m [38;5;205m:macro (cc $b) => (mult $b $b)[0m[0m[32m;[0m[90m cc 5 [33m# define and call macros[0m[0m
[35mEval: plus 4 3[0m
[34mMacro  0 bb in   bb 4[0m
[34mMacro  0    out  plus 4 4[0m
[34mMacro  0 bb done plus 4 4[0m
[35mEval: plus 4 4[0m
[34mMacro  0 cc in   cc 5[0m
[34mMacro  0    out  mult 5 5[0m
[34mMacro  0 cc done mult 5 5[0m
[35mEval: mult 5 5[0m
[34mName: [Church numeral: 25] [0m
[34mTime: 2.3 ms, iterations: 3[0m
[32m-> 7
Macro 'bb' defined successfully
-> 8
Macro 'cc' defined successfully
-> 25[0m
[0m [0m
[90mline 627 <<: [0m
[90mline 628 <<: [0m
[90mline 629 <<: [33m# test different ways to define and use fibonacci[0m[0m
[90mline 630 <<: alphaEq (let rec fib2 = n -> if (n <= 2) 1 ((n - 1 |> fib2) + (n - 2 |> fib2)) in fib2 10) 55[0m
[35mEval: alphaEq ((Î»fib2.fib2 10) (Y (Î»fib2.Î»n.if (<= n 2) 1 (+ (fib2 (- n 1)) (fib2 (- n 2)))))) 55[0m
[35mAlpha left:  55[0m
[35mAlpha right: 55[0m
[32mAlpha passed - 365/370 (98.65%)[0m
[34mTime: 6.6 ms, iterations: 229[0m
[32m-> true[0m
[0m [0m
[90mline 631 <<: alphaEq (let rec fib3 = n -> if (n <= 2) 1 (fib3(n - 1) + fib3(n - 2)) in fib3 10) 55[0m
[35mEval: alphaEq ((Î»fib3.fib3 10) (Y (Î»fib3.Î»n.if (<= n 2) 1 (+ (fib3 (- n 1)) (fib3 (- n 2)))))) 55[0m
[35mAlpha left:  55[0m
[35mAlpha right: 55[0m
[32mAlpha passed - 366/371 (98.65%)[0m
[34mTime: 5.9 ms, iterations: 229[0m
[32m-> true[0m
[0m [0m
[90mline 632 <<: fib4 = n -> if (n <= 2) 1 ((n - 1 |> fib4) + (n - 2 |> fib4))[0m
[32m-> fib4 = Î»n.if (<= n 2) 1 (+ (fib4 (- n 1)) (fib4 (- n 2)))[0m
[0m [0m
[90mline 633 <<: fib5 = n -> if (n <= 2) 1 (fib5(n - 1) + fib5(n - 2))[0m
[32m-> fib5 = Î»n.if (<= n 2) 1 (+ (fib5 (- n 1)) (fib5 (- n 2)))[0m
[0m [0m
[90mline 634 <<: alphaEq (fib4 10) 55[0m
[35mEval: alphaEq (fib4 10) 55[0m
[35mAlpha left:  55[0m
[35mAlpha right: 55[0m
[32mAlpha passed - 367/372 (98.66%)[0m
[34mTime: 4.6 ms, iterations: 217[0m
[32m-> true[0m
[0m [0m
[90mline 635 <<: alphaEq (fib5 10) 55[0m
[35mEval: alphaEq (fib5 10) 55[0m
[35mAlpha left:  55[0m
[35mAlpha right: 55[0m
[32mAlpha passed - 368/373 (98.66%)[0m
[34mTime: 4.7 ms, iterations: 217[0m
[32m-> true[0m
[0m [0m
[90mline 636 <<: fib6 = Y (\f.\n. if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n)))))[0m
[32m-> fib6 = <thunk:(Î»f.Î»n.if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n))))) (Y (Î»f.Î»n.if (leq n 2) 1 (plus (f (pred n)) (f (pred (pred n))))))>[0m
[0m [0m
[90mline 637 <<: alphaEq (fib6 10) 55[0m
[35mEval: alphaEq (fib6 10) 55[0m
[35mAlpha left:  55[0m
[35mAlpha right: 55[0m
[32mAlpha passed - 369/374 (98.66%)[0m
[34mTime: 4.0 ms, iterations: 130[0m
[32m-> true[0m
[0m [0m
[90mline 638 <<: fib7 = Y (\f. \n. if (n <= 2) 1 ((f (n - 1)) + (f (n - 2))))[0m
[32m-> fib7 = <thunk:(Î»f.Î»n.if (<= n 2) 1 (+ (f (- n 1)) (f (- n 2)))) (Y (Î»f.Î»n.if (<= n 2) 1 (+ (f (- n 1)) (f (- n 2)))))>[0m
[0m [0m
[90mline 639 <<: alphaEq (fib7 10) 55[0m
[35mEval: alphaEq (fib7 10) 55[0m
[35mAlpha left:  55[0m
[35mAlpha right: 55[0m
[32mAlpha passed - 370/375 (98.67%)[0m
[34mTime: 4.0 ms, iterations: 130[0m
[32m-> true[0m
[0m [0m
[90mline 640 <<: [0m
[90mline 641 <<: [33m# ============================================================================[0m[0m
[90mline 642 <<: [33m# Added Extended Coverage (new)[0m[0m
[90mline 643 <<: [33m# Focus: WHILE combinator, gcd1, ackermann small cases, State monad sequencing,[0m[0m
[90mline 644 <<: [33m# structural equality helper families, safe* functions, ASCII predicates,[0m[0m
[90mline 645 <<: [33m# unzip, listEq/maybeEq/eitherEq negative cases, tolower/toupper, list unzip.[0m[0m
[90mline 646 <<: [33m# ============================================================================[0m[0m
[90mline 647 <<: [0m
[90mline 648 <<: [33m# WHILE loop basic countdown (should reach 0)[0m[0m
[90mline 649 <<: alphaEq (WHILE (Î»n.gt n 0) pred 5) 0[0m
[35mEval: alphaEq (WHILE (Î»n.gt n false) pred 5) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 371/376 (98.67%)[0m
[34mTime: 2.1 ms, iterations: 660[0m
[32m-> true[0m
[0m [0m
[90mline 650 <<: [0m
[90mline 651 <<: [33m# gcd1 (WHILE-based) correctness vs known value[0m[0m
[90mline 652 <<: alphaEq (gcd1 48 18) 6[0m
[35mEval: alphaEq (gcd1 48 18) 6[0m
[35mAlpha left:  12[0m
[35mAlpha right: 6[0m
[31mAlpha failed - 6/377 (1.59%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 524.4 ms, iterations: 54,003[0m
[32m-> false[0m
[0m [0m
[90mline 653 <<: [0m
[90mline 654 <<: [33m# Ackermann small direct values (pattern observed: ackermann 2 n = 2n + 3)[0m[0m
[90mline 655 <<: alphaEq (ackermann 2 2) 7[0m
[35mEval: alphaEq (ackermann 2 2) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 372/378 (98.41%)[0m
[34mTime: 2.6 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 656 <<: alphaEq (ackermann 2 3) 9[0m
[35mEval: alphaEq (ackermann 2 3) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 373/379 (98.42%)[0m
[34mTime: 1.1 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 657 <<: [0m
[90mline 658 <<: [33m# State monad: putState and bindState sequencing[0m[0m
[90mline 659 <<: alphaEq (runState (putState 99) 42) (pair nil 99)[0m
[35mEval: alphaEq (runState (putState 99) 42) (pair [] 99)[0m
[35mAlpha left:  Î»f.f false 99[0m
[35mAlpha right: Î»f.f false 99[0m
[32mAlpha passed - 374/380 (98.42%)[0m
[34mTime: 15.7 ms, iterations: 35[0m
[32m-> true[0m
[0m [0m
[90mline 660 <<: [0m
[90mline 661 <<: [33m# Construct a composite state computation: double state, then increment value & state[0m[0m
[0mPROGRESS::84[0m
[90mline 662 <<: doubleThenInc = bindState (Î»s.pair (mult s 2) (mult s 2)) (Î»res. Î»s.pair (succ res) (succ s))[0m
[32m-> doubleThenInc = Î»s.(Î»res.Î»s.pair (succ res) (succ s)) (first ((Î»s.pair (mult s 2) (mult s 2)) s)) (second ((Î»s.pair (mult s 2) (mult s 2)) s))[0m
[0m [0m
[90mline 663 <<: alphaEq (runState doubleThenInc 3) (pair 7 7)[0m
[35mEval: alphaEq (runState doubleThenInc 3) (pair 7 7)[0m
[35mAlpha left:  Î»f.f 7 7[0m
[35mAlpha right: Î»f.f 7 7[0m
[32mAlpha passed - 375/381 (98.43%)[0m
[34mTime: 1.7 ms, iterations: 75[0m
[32m-> true[0m
[0m [0m
[90mline 664 <<: [0m
[90mline 665 <<: [33m# Structural equality helpers (listEq / maybeEq / eitherEq)[0m[0m
[90mline 666 <<: alphaEq (listEq eq [1,2,3] [1,2,3]) true[0m
[35mEval: alphaEq (listEq eq ([1, 2, 3]) ([1, 2, 3])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 376/382 (98.43%)[0m
[34mTime: 2.7 ms, iterations: 308[0m
[32m-> true[0m
[0m [0m
[90mline 667 <<: alphaEq (listEq eq [1,2,3] [1,2]) false[0m
[35mEval: alphaEq (listEq eq ([1, 2, 3]) ([1, 2])) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 377/383 (98.43%)[0m
[34mTime: 1.9 ms, iterations: 229[0m
[32m-> true[0m
[0m [0m
[90mline 668 <<: alphaEq (maybeEq eq (just 5) (just 5)) true[0m
[35mEval: alphaEq (maybeEq eq (just 5) (just 5)) true[0m
[35mAlpha left:  false[0m
[35mAlpha right: true[0m
[31mAlpha failed - 7/384 (1.82%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 1.3 ms, iterations: 67[0m
[32m-> false[0m
[0m [0m
[90mline 669 <<: alphaEq (maybeEq eq (just 5) nothing) false[0m
[35mEval: alphaEq (maybeEq eq (just 5) nothing) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 378/385 (98.18%)[0m
[34mTime: 1.1 ms, iterations: 271[0m
[32m-> true[0m
[0m [0m
[90mline 670 <<: alphaEq (eitherEq eq eq (left 3) (left 3)) true[0m
[35mEval: alphaEq (eitherEq eq eq (left 3) (left 3)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 379/386 (98.19%)[0m
[34mTime: 1.2 ms, iterations: 121[0m
[32m-> true[0m
[0m [0m
[90mline 671 <<: alphaEq (eitherEq eq eq (left 3) (right 3)) false[0m
[35mEval: alphaEq (eitherEq eq eq (left 3) (right 3)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 380/387 (98.19%)[0m
[34mTime: 1.0 ms, iterations: 131[0m
[32m-> true[0m
[0m [0m
[90mline 672 <<: [0m
[90mline 673 <<: [33m# Safe head/tail/nth/div operations[0m[0m
[90mline 674 <<: alphaEq (safehead [1,2,3]) (just 1)[0m
[35mEval: alphaEq (safehead ([1, 2, 3])) (just 1)[0m
[35mAlpha left:  Î»f.f (true) 1[0m
[35mAlpha right: Î»f.f (true) 1[0m
[32mAlpha passed - 381/388 (98.20%)[0m
[34mTime: 1.3 ms, iterations: 21[0m
[32m-> true[0m
[0m [0m
[90mline 675 <<: alphaEq (safehead nil) nothing[0m
[35mEval: alphaEq (safehead []) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 382/389 (98.20%)[0m
[34mTime: 0.2 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 676 <<: alphaEq (safetail [1,2,3]) (just [2,3])[0m
[35mEval: alphaEq (safetail ([1, 2, 3])) (just ([2, 3]))[0m
[35mAlpha left:  Î»f.f (true) ([2, 3])[0m
[35mAlpha right: Î»f.f (true) ([2, 3])[0m
[32mAlpha passed - 383/390 (98.21%)[0m
[34mTime: 1.9 ms, iterations: 33[0m
[32m-> true[0m
[0m [0m
[90mline 677 <<: alphaEq (safetail nil) nothing[0m
[35mEval: alphaEq (safetail []) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 384/391 (98.21%)[0m
[34mTime: 0.2 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 678 <<: alphaEq (safenth 1 [10,20,30]) (just 20)[0m
[35mEval: alphaEq (safenth 1 ([10, 20, 30])) (just 20)[0m
[35mAlpha left:  Î»f.f (true) 20[0m
[35mAlpha right: Î»f.f (true) 20[0m
[32mAlpha passed - 385/392 (98.21%)[0m
[34mTime: 6.5 ms, iterations: 461[0m
[32m-> true[0m
[0m [0m
[90mline 679 <<: alphaEq (safenth 5 [10]) nothing[0m
[35mEval: alphaEq (safenth 5 ([10])) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 386/393 (98.22%)[0m
[34mTime: 1.7 ms, iterations: 141[0m
[32m-> true[0m
[0m [0m
[90mline 680 <<: alphaEq (safeDiv 12 3) (just 4)[0m
[35mEval: alphaEq (safeDiv 12 3) (just 4)[0m
[35mAlpha left:  Î»f.f (true) 4[0m
[35mAlpha right: Î»f.f (true) 4[0m
[32mAlpha passed - 387/394 (98.22%)[0m
[34mTime: 1.4 ms, iterations: 25[0m
[32m-> true[0m
[0m [0m
[90mline 681 <<: alphaEq (safeDiv 12 0) nothing[0m
[35mEval: alphaEq (safeDiv 12 false) nothing[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 388/395 (98.23%)[0m
[34mTime: 1.2 ms, iterations: 13[0m
[32m-> true[0m
[0m [0m
[90mline 682 <<: [0m
[90mline 683 <<: [33m# ASCII predicates and case conversion[0m[0m
[90mline 684 <<: alphaEq (isdigit 48) true[0m
[35mEval: alphaEq (isdigit 48) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 389/396 (98.23%)[0m
[34mTime: 2.9 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 685 <<: alphaEq (isdigit 65) false[0m
[35mEval: alphaEq (isdigit 65) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 390/397 (98.24%)[0m
[34mTime: 4.3 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 686 <<: alphaEq (isalpha 65) true[0m
[35mEval: alphaEq (isalpha 65) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 391/398 (98.24%)[0m
[34mTime: 4.2 ms, iterations: 63[0m
[32m-> true[0m
[0m [0m
[90mline 687 <<: alphaEq (isalpha 48) false[0m
[35mEval: alphaEq (isalpha 48) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 392/399 (98.25%)[0m
[34mTime: 3.4 ms, iterations: 63[0m
[32m-> true[0m
[0m [0m
[90mline 688 <<: alphaEq (isspace 32) true[0m
[35mEval: alphaEq (isspace 32) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 393/400 (98.25%)[0m
[34mTime: 2.2 ms, iterations: 39[0m
[32m-> true[0m
[0m [0m
[90mline 689 <<: alphaEq (isspace 65) false[0m
[35mEval: alphaEq (isspace 65) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 394/401 (98.25%)[0m
[34mTime: 4.3 ms, iterations: 39[0m
[32m-> true[0m
[0m [0m
[90mline 690 <<: alphaEq (toupper 97) 65[0m
[35mEval: alphaEq (toupper 97) 65[0m
[35mAlpha left:  65[0m
[35mAlpha right: 65[0m
[32mAlpha passed - 395/402 (98.26%)[0m
[34mTime: 10.1 ms, iterations: 29[0m
[32m-> true[0m
[0m [0m
[90mline 691 <<: alphaEq (toupper 33) 33[0m
[35mEval: alphaEq (toupper 33) 33[0m
[35mAlpha left:  33[0m
[35mAlpha right: 33[0m
[32mAlpha passed - 396/403 (98.26%)[0m
[34mTime: 4.3 ms, iterations: 29[0m
[32m-> true[0m
[0m [0m
[90mline 692 <<: alphaEq (tolower 65) 97[0m
[35mEval: alphaEq (tolower 65) 97[0m
[35mAlpha left:  97[0m
[35mAlpha right: 97[0m
[32mAlpha passed - 397/404 (98.27%)[0m
[34mTime: 9.9 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 693 <<: alphaEq (tolower 48) 48[0m
[35mEval: alphaEq (tolower 48) 48[0m
[35mAlpha left:  48[0m
[35mAlpha right: 48[0m
[32mAlpha passed - 398/405 (98.27%)[0m
[34mTime: 5.3 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 694 <<: [0m
[90mline 695 <<: [33m# unzip (zip round trip)[0m[0m
[90mline 696 <<: alphaEq (unzip (zip [1,2] [3,4])) (pair [1,2] [3,4])[0m
[35mEval: alphaEq (unzip (zip ([1, 2]) ([3, 4]))) (pair ([1, 2]) ([3, 4]))[0m
[35mAlpha left:  Î»f.f ([1, 2]) ([3, 4])[0m
[35mAlpha right: Î»f.f ([1, 2]) ([3, 4])[0m
[32mAlpha passed - 399/406 (98.28%)[0m
[34mTime: 3.5 ms, iterations: 363[0m
[32m-> true[0m
[0m [0m
[90mline 697 <<: [0m
[90mline 698 <<: [33m# listEq nested usage example (list of lists)[0m[0m
[90mline 699 <<: alphaEq (listEq (listEq eq) [[1,2],[3]] [[1,2],[3]]) true[0m
[35mEval: alphaEq (listEq (listEq eq) ([[1, 2], [3]]) ([[1, 2], [3]])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 400/407 (98.28%)[0m
[34mTime: 3.8 ms, iterations: 701[0m
[32m-> true[0m
[0m [0m
[90mline 700 <<: alphaEq (listEq (listEq eq) [[1,2],[3]] [[1,2],[4]]) false[0m
[35mEval: alphaEq (listEq (listEq eq) ([[1, 2], [3]]) ([[1, 2], [4]])) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 401/408 (98.28%)[0m
[34mTime: 3.1 ms, iterations: 602[0m
[32m-> true[0m
[0m [0m
[0mPROGRESS::89[0m
[90mline 701 <<: [0m
[90mline 702 <<: [33m# Additional numeric predicate & helper coverage[0m[0m
[90mline 703 <<: alphaEq (isone 1) true[0m
[35mEval: alphaEq (isone 1) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 402/409 (98.29%)[0m
[34mTime: 0.3 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 704 <<: alphaEq (isone 2) false[0m
[35mEval: alphaEq (isone 2) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 403/410 (98.29%)[0m
[34mTime: 0.6 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 705 <<: alphaEq (istwo 2) true[0m
[35mEval: alphaEq (istwo 2) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 404/411 (98.30%)[0m
[34mTime: 0.4 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 706 <<: alphaEq (istwo 3) false[0m
[35mEval: alphaEq (istwo 3) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 405/412 (98.30%)[0m
[34mTime: 0.4 ms, iterations: 7[0m
[32m-> true[0m
[0m [0m
[90mline 707 <<: alphaEq (ispositive 0) false[0m
[35mEval: alphaEq (ispositive false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 406/413 (98.31%)[0m
[34mTime: 0.3 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 708 <<: alphaEq (ispositive 3) true[0m
[35mEval: alphaEq (ispositive 3) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 407/414 (98.31%)[0m
[34mTime: 0.4 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 709 <<: alphaEq (triple 4) 12[0m
[34mMacro  0 triple in   triple 4[0m
[34mMacro  0        out  plus 4 (plus 4 4)[0m
[34mMacro  0 triple done plus 4 (plus 4 4)[0m
[35mEval: alphaEq (plus 4 (plus 4 4)) 12[0m
[35mAlpha left:  12[0m
[35mAlpha right: 12[0m
[32mAlpha passed - 408/415 (98.31%)[0m
[34mTime: 1.9 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 710 <<: alphaEq (quadruple 3) 12[0m
[35mEval: alphaEq (quadruple 3) 12[0m
[35mAlpha left:  12[0m
[35mAlpha right: 12[0m
[32mAlpha passed - 409/416 (98.32%)[0m
[34mTime: 1.2 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 711 <<: [0m
[90mline 712 <<: [33m# GCD / LCM edge cases with zero[0m[0m
[90mline 713 <<: alphaEq (gcd 0 7) 7[0m
[35mEval: alphaEq (gcd false 7) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 410/417 (98.32%)[0m
[34mTime: 1.3 ms, iterations: 24[0m
[32m-> true[0m
[0m [0m
[90mline 714 <<: alphaEq (gcd 9 0) 9[0m
[35mEval: alphaEq (gcd 9 false) 9[0m
[35mAlpha left:  9[0m
[35mAlpha right: 9[0m
[32mAlpha passed - 411/418 (98.33%)[0m
[34mTime: 1.3 ms, iterations: 13[0m
[32m-> true[0m
[0m [0m
[90mline 715 <<: alphaEq (gcd1 0 7) 7[0m
[35mEval: alphaEq (gcd1 false 7) 7[0m
[35mAlpha left:  7[0m
[35mAlpha right: 7[0m
[32mAlpha passed - 412/419 (98.33%)[0m
[34mTime: 1.3 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 716 <<: alphaEq (lcm 0 5) 0[0m
[35mEval: alphaEq (lcm false 5) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 413/420 (98.33%)[0m
[34mTime: 0.7 ms, iterations: 29[0m
[32m-> true[0m
[0m [0m
[90mline 717 <<: alphaEq (lcm 6 0) 0[0m
[35mEval: alphaEq (lcm 6 false) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 414/421 (98.34%)[0m
[34mTime: 0.8 ms, iterations: 29[0m
[32m-> true[0m
[0m [0m
[90mline 718 <<: [0m
[90mline 719 <<: [33m# Structural equality negative variants[0m[0m
[90mline 720 <<: alphaEq (listEq eq [1,2] [2,1]) false[0m
[35mEval: alphaEq (listEq eq ([1, 2]) ([2, 1])) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 415/422 (98.34%)[0m
[34mTime: 1.6 ms, iterations: 303[0m
[32m-> true[0m
[0m [0m
[90mline 721 <<: alphaEq (pairEq eq eq (pair 1 2) (pair 1 3)) false[0m
[35mEval: alphaEq (pairEq eq eq (pair 1 2) (pair 1 3)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 416/423 (98.35%)[0m
[34mTime: 1.3 ms, iterations: 119[0m
[32m-> true[0m
[0m [0m
[90mline 722 <<: alphaEq (maybeEq eq (just 5) (just 6)) false[0m
[35mEval: alphaEq (maybeEq eq (just 5) (just 6)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 417/424 (98.35%)[0m
[34mTime: 1.2 ms, iterations: 67[0m
[32m-> true[0m
[0m [0m
[90mline 723 <<: alphaEq (eitherEq eq eq (right 2) (right 3)) false[0m
[35mEval: alphaEq (eitherEq eq eq (right 2) (right 3)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 418/425 (98.35%)[0m
[34mTime: 1.0 ms, iterations: 159[0m
[32m-> true[0m
[0m [0m
[90mline 724 <<: [0m
[90mline 725 <<: [33m# Benchmark & lazy helpers[0m[0m
[90mline 726 <<: alphaEq (benchmark 5 succ 1) 2[0m
[35mEval: alphaEq (benchmark 5 succ 1) 2[0m
[35mAlpha left:  1[0m
[35mAlpha right: 2[0m
[31mAlpha failed - 8/426 (1.88%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 1.0 ms, iterations: 17[0m
[32m-> false[0m
[0m [0m
[90mline 727 <<: alphaEq (force (delay 42)) 42[0m
[35mEval: alphaEq (force (delay 42)) 42[0m
[35mAlpha left:  42[0m
[35mAlpha right: 42[0m
[32mAlpha passed - 419/427 (98.13%)[0m
[34mTime: 4.8 ms, iterations: 19[0m
[32m-> true[0m
[0m [0m
[90mline 728 <<: [0m
[90mline 729 <<: [33m# ASCII classification extended[0m[0m
[90mline 730 <<: alphaEq (isupper 65) true[0m
[35mEval: alphaEq (isupper 65) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 420/428 (98.13%)[0m
[34mTime: 3.7 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 731 <<: alphaEq (isupper 97) false[0m
[35mEval: alphaEq (isupper 97) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 421/429 (98.14%)[0m
[34mTime: 5.6 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 732 <<: alphaEq (islower 97) true[0m
[35mEval: alphaEq (islower 97) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 422/430 (98.14%)[0m
[34mTime: 5.6 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 733 <<: alphaEq (islower 65) false[0m
[35mEval: alphaEq (islower 65) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 423/431 (98.14%)[0m
[34mTime: 3.6 ms, iterations: 3[0m
[32m-> true[0m
[0m [0m
[90mline 734 <<: alphaEq (isalnum 65) true[0m
[35mEval: alphaEq (isalnum 65) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 424/432 (98.15%)[0m
[34mTime: 3.8 ms, iterations: 23[0m
[32m-> true[0m
[0m [0m
[90mline 735 <<: alphaEq (isalnum 33) false[0m
[35mEval: alphaEq (isalnum 33) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 425/433 (98.15%)[0m
[34mTime: 2.1 ms, iterations: 103[0m
[32m-> true[0m
[0m [0m
[90mline 736 <<: alphaEq (toupper 65) 65[0m
[35mEval: alphaEq (toupper 65) 65[0m
[35mAlpha left:  65[0m
[35mAlpha right: 65[0m
[32mAlpha passed - 426/434 (98.16%)[0m
[34mTime: 7.5 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 737 <<: alphaEq (tolower 97) 97[0m
[35mEval: alphaEq (tolower 97) 97[0m
[35mAlpha left:  97[0m
[35mAlpha right: 97[0m
[32mAlpha passed - 427/435 (98.16%)[0m
[34mTime: 11.5 ms, iterations: 9[0m
[32m-> true[0m
[0m [0m
[90mline 738 <<: [0m
[90mline 739 <<: [33m# State monad laws (left/right identity exemplars)[0m[0m
[0mPROGRESS::94[0m
[90mline 740 <<: alphaEq (runState (bindState (returnState 5) (Î»x.returnState (succ x))) 0) (pair 6 0)[0m
[35mEval: alphaEq (runState (bindState (returnState 5) (Î»x.returnState (succ x))) false) (pair 6 false)[0m
[35mAlpha left:  Î»f.f 6 false[0m
[35mAlpha right: Î»f.f 6 false[0m
[32mAlpha passed - 428/436 (98.17%)[0m
[34mTime: 1.6 ms, iterations: 95[0m
[32m-> true[0m
[0m [0m
[90mline 741 <<: alphaEq (runState (bindState (returnState 5) returnState) 0) (pair 5 0)[0m
[35mEval: alphaEq (runState (bindState (returnState 5) returnState) false) (pair 5 false)[0m
[35mAlpha left:  Î»f.f 5 false[0m
[35mAlpha right: Î»f.f 5 false[0m
[32mAlpha passed - 429/437 (98.17%)[0m
[34mTime: 1.5 ms, iterations: 47[0m
[32m-> true[0m
[0m [0m
[90mline 742 <<: mState = Î»s.pair 1 (succ s)[0m
[32m-> mState = Î»s.pair 1 (succ s)[0m
[0m [0m
[90mline 743 <<: alphaEq (runState (bindState mState returnState) 0) (runState mState 0)[0m
[35mEval: alphaEq (runState (bindState mState returnState) false) (runState mState false)[0m
[35mAlpha left:  Î»f.f 1 1[0m
[35mAlpha right: Î»f.f 1 1[0m
[32mAlpha passed - 430/438 (98.17%)[0m
[34mTime: 1.1 ms, iterations: 87[0m
[32m-> true[0m
[0m [0m
[90mline 744 <<: [0m
[90mline 745 <<: [33m# --- Additional Macro & Helper Coverage (supplemental) ---[0m[0m
[90mline 746 <<: alphaEq (nand true true) false[0m
[34mMacro  0 nand in   nand true true[0m
[34mMacro  0      out  not (and true true)[0m
[34mMacro  0 nand done not (and true true)[0m
[35mEval: alphaEq (not (and true true)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 431/439 (98.18%)[0m
[34mTime: 0.3 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 747 <<: alphaEq (nand true false) true[0m
[34mMacro  0 nand in   nand true false[0m
[34mMacro  0      out  not (and true false)[0m
[34mMacro  0 nand done not (and true false)[0m
[35mEval: alphaEq (not (and true false)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 432/440 (98.18%)[0m
[34mTime: 0.3 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 748 <<: alphaEq (nor false false) true[0m
[34mMacro  0 nor in   nor false false[0m
[34mMacro  0     out  not (or false false)[0m
[34mMacro  0 nor done not (or false false)[0m
[35mEval: alphaEq (not (or false false)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 433/441 (98.19%)[0m
[34mTime: 0.3 ms, iterations: 31[0m
[32m-> true[0m
[0m [0m
[90mline 749 <<: alphaEq (nor true false) false[0m
[34mMacro  0 nor in   nor true false[0m
[34mMacro  0     out  not (or true false)[0m
[34mMacro  0 nor done not (or true false)[0m
[35mEval: alphaEq (not (or true false)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 434/442 (98.19%)[0m
[34mTime: 0.3 ms, iterations: 15[0m
[32m-> true[0m
[0m [0m
[90mline 750 <<: alphaEq (apply_n succ 3 4) 7[0m
[34mMacro  0 apply_n in   apply_n succ 3 4[0m
[34mMacro  0         out  times 3 succ 4[0m
[34mMacro  0 apply_n done times 3 succ 4[0m
[35mEval: alphaEq (times 3 succ 4) 7[0m
[35mAlpha left:  4[0m
[35mAlpha right: 7[0m
[31mAlpha failed - 9/443 (2.03%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 1.3 ms, iterations: 5[0m
[32m-> false[0m
[0m [0m
[90mline 751 <<: alphaEq (min2 3 5) 3[0m
[34mMacro  0 min2 in   min2 3 5[0m
[34mMacro  0      out  if (leq 3 5) 3 5[0m
[34mMacro  0 min2 done if (leq 3 5) 3 5[0m
[35mEval: alphaEq (if (leq 3 5) 3 5) 3[0m
[35mAlpha left:  3[0m
[35mAlpha right: 3[0m
[32mAlpha passed - 435/444 (97.97%)[0m
[34mTime: 1.8 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 752 <<: alphaEq (max2 3 5) 5[0m
[34mMacro  0 max2 in   max2 3 5[0m
[34mMacro  0      out  if (geq 3 5) 3 5[0m
[34mMacro  0 max2 done if (geq 3 5) 3 5[0m
[35mEval: alphaEq (if (geq 3 5) 3 5) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 436/445 (97.98%)[0m
[34mTime: 2.0 ms, iterations: 5[0m
[32m-> true[0m
[0m [0m
[90mline 753 <<: alphaEq (empty? nil) true[0m
[34mMacro  0 empty? in   empty? [][0m
[34mMacro  0        out  isnil [][0m
[34mMacro  0 empty? done isnil [][0m
[35mEval: alphaEq (isnil []) true[0m
[34mTime: 0.2 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 754 <<: alphaEq (empty? [1]) false[0m
[34mMacro  0 empty? in   empty? ([1])[0m
[34mMacro  0        out  isnil ([1])[0m
[34mMacro  0 empty? done isnil ([1])[0m
[35mEval: alphaEq (isnil ([1])) false[0m
[34mTime: 0.4 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 755 <<: alphaEq (rest [1,2,3]) [2,3][0m
[34mMacro  0 rest in   rest ([1, 2, 3])[0m
[34mMacro  0      out  tail ([1, 2, 3])[0m
[34mMacro  0 rest done tail ([1, 2, 3])[0m
[35mEval: alphaEq (tail ([1, 2, 3])) ([2, 3])[0m
[34mTime: 1.7 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 756 <<: [0m
[90mline 757 <<: [33m# Structural test macros wrappers[0m[0m
[90mline 758 <<: alphaEq (testList [1,2] [1,2]) true[0m
[34mMacro  0 testList in   testList ([1, 2]) ([1, 2])[0m
[34mMacro  0          out  listEq eq ([1, 2]) ([1, 2])[0m
[34mMacro  0 testList done listEq eq ([1, 2]) ([1, 2])[0m
[35mEval: alphaEq (listEq eq ([1, 2]) ([1, 2])) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 437/446 (97.98%)[0m
[34mTime: 1.4 ms, iterations: 63[0m
[32m-> true[0m
[0m [0m
[90mline 759 <<: alphaEq (testPair (pair 1 2) (pair 1 2)) true[0m
[34mMacro  0 testPair in   testPair (pair 1 2) (pair 1 2)[0m
[34mMacro  0          out  pairEq eq eq (pair 1 2) (pair 1 2)[0m
[34mMacro  0 testPair done pairEq eq eq (pair 1 2) (pair 1 2)[0m
[35mEval: alphaEq (pairEq eq eq (pair 1 2) (pair 1 2)) true[0m
[34mTime: 1.1 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 760 <<: alphaEq (testMaybe (just 9) (just 9)) true[0m
[34mMacro  0 testMaybe in   testMaybe (just 9) (just 9)[0m
[34mMacro  0           out  maybeEq eq (just 9) (just 9)[0m
[34mMacro  0 testMaybe done maybeEq eq (just 9) (just 9)[0m
[35mEval: alphaEq (maybeEq eq (just 9) (just 9)) true[0m
[35mAlpha left:  false[0m
[35mAlpha right: true[0m
[31mAlpha failed - 10/447 (2.24%)[0m
[34mName: [Church numeral: 0] [defined: zero][0m
[34mTime: 1.7 ms, iterations: 79[0m
[32m-> false[0m
[0m [0m
[90mline 761 <<: alphaEq (testEither (right 4) (right 4)) true[0m
[34mMacro  0 testEither in   testEither (right 4) (right 4)[0m
[34mMacro  0            out  eitherEq eq eq (right 4) (right 4)[0m
[34mMacro  0 testEither done eitherEq eq eq (right 4) (right 4)[0m
[35mEval: alphaEq (eitherEq eq eq (right 4) (right 4)) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 438/448 (97.77%)[0m
[34mTime: 1.4 ms, iterations: 155[0m
[32m-> true[0m
[0m [0m
[90mline 762 <<: [0m
[90mline 763 <<: [33m# Negative with wrappers[0m[0m
[90mline 764 <<: alphaEq (testList [1,2] [2,1]) false[0m
[34mMacro  0 testList in   testList ([1, 2]) ([2, 1])[0m
[34mMacro  0          out  listEq eq ([1, 2]) ([2, 1])[0m
[34mMacro  0 testList done listEq eq ([1, 2]) ([2, 1])[0m
[35mEval: alphaEq (listEq eq ([1, 2]) ([2, 1])) false[0m
[34mTime: 1.2 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 765 <<: alphaEq (testPair (pair 1 2) (pair 2 1)) false[0m
[34mMacro  0 testPair in   testPair (pair 1 2) (pair 2 1)[0m
[34mMacro  0          out  pairEq eq eq (pair 1 2) (pair 2 1)[0m
[34mMacro  0 testPair done pairEq eq eq (pair 1 2) (pair 2 1)[0m
[35mEval: alphaEq (pairEq eq eq (pair 1 2) (pair 2 1)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 439/449 (97.77%)[0m
[34mTime: 1.4 ms, iterations: 115[0m
[32m-> true[0m
[0m [0m
[90mline 766 <<: alphaEq (testMaybe (just 9) (just 8)) false[0m
[34mMacro  0 testMaybe in   testMaybe (just 9) (just 8)[0m
[34mMacro  0           out  maybeEq eq (just 9) (just 8)[0m
[34mMacro  0 testMaybe done maybeEq eq (just 9) (just 8)[0m
[35mEval: alphaEq (maybeEq eq (just 9) (just 8)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 440/450 (97.78%)[0m
[34mTime: 1.6 ms, iterations: 79[0m
[32m-> true[0m
[0m [0m
[90mline 767 <<: alphaEq (testEither (left 4) (right 4)) false[0m
[34mMacro  0 testEither in   testEither (left 4) (right 4)[0m
[34mMacro  0            out  eitherEq eq eq (left 4) (right 4)[0m
[34mMacro  0 testEither done eitherEq eq eq (left 4) (right 4)[0m
[35mEval: alphaEq (eitherEq eq eq (left 4) (right 4)) false[0m
[35mAlpha left:  false[0m
[35mAlpha right: false[0m
[32mAlpha passed - 441/451 (97.78%)[0m
[34mTime: 1.1 ms, iterations: 115[0m
[32m-> true[0m
[0m [0m
[90mline 768 <<: [0m
[90mline 769 <<: [33m# WHILE with immediately false condition returns initial state[0m[0m
[90mline 770 <<: alphaEq (WHILE (Î»n.lt n 0) succ 5) 5[0m
[35mEval: alphaEq (WHILE (Î»n.lt n false) succ 5) 5[0m
[35mAlpha left:  5[0m
[35mAlpha right: 5[0m
[32mAlpha passed - 442/452 (97.79%)[0m
[34mTime: 1.3 ms, iterations: 21[0m
[32m-> true[0m
[0m [0m
[90mline 771 <<: [0m
[90mline 772 <<: [33m# safeInit vs safeInitMaybe distinction[0m[0m
[90mline 773 <<: alphaEq (safeInit [1,2]) [1][0m
[35mEval: alphaEq (safeInit ([1, 2])) ([1])[0m
[34mTime: 0.8 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 774 <<: alphaEq (safeInitMaybe [1,2]) (just [1])[0m
[35mEval: alphaEq (safeInitMaybe ([1, 2])) (just ([1]))[0m
[34mTime: 1.1 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m
[90mline 775 <<: [0m
[90mline 776 <<: [33m# Single-element safe min/max[0m[0m
[90mline 777 <<: alphaEq (safeMinimum [7]) (just 7)[0m
[35mEval: alphaEq (safeMinimum ([7])) (just 7)[0m
[35mAlpha left:  Î»f.f (true) 7[0m
[35mAlpha right: Î»f.f (true) 7[0m
[32mAlpha passed - 443/453 (97.79%)[0m
[34mTime: 1.3 ms, iterations: 137[0m
[32m-> true[0m
[0m [0m
[90mline 778 <<: alphaEq (safeMaximum [7]) (just 7)[0m
[35mEval: alphaEq (safeMaximum ([7])) (just 7)[0m
[35mAlpha left:  Î»f.f (true) 7[0m
[35mAlpha right: Î»f.f (true) 7[0m
[32mAlpha passed - 444/454 (97.80%)[0m
[34mTime: 1.4 ms, iterations: 75[0m
[32m-> true[0m
[0m [0m
[90mline 779 <<: [0m
[0mPROGRESS::99[0m
[90mline 780 <<: [33m# Nested pair equality positive[0m[0m
[90mline 781 <<: alphaEq (pairEq (pairEq eq eq) (pairEq eq eq) (pair (pair 1 2) (pair 3 4)) (pair (pair 1 2) (pair 3 4))) true[0m
[35mEval: alphaEq (pairEq (pairEq eq eq) (pairEq eq eq) (pair (pair 1 2) (pair 3 4)) (pair (pair 1 2) (pair 3 4))) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 445/455 (97.80%)[0m
[34mTime: 3.3 ms, iterations: 219[0m
[32m-> true[0m
[0m [0m
[90mline 782 <<: [0m
[90mline 783 <<: [33m# isspace tab/newline[0m[0m
[90mline 784 <<: alphaEq (isspace 9) true[0m
[35mEval: alphaEq (isspace 9) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 446/456 (97.81%)[0m
[34mTime: 0.7 ms, iterations: 39[0m
[32m-> true[0m
[0m [0m
[90mline 785 <<: alphaEq (isspace 10) true[0m
[35mEval: alphaEq (isspace 10) true[0m
[35mAlpha left:  true[0m
[35mAlpha right: true[0m
[32mAlpha passed - 447/457 (97.81%)[0m
[34mTime: 0.8 ms, iterations: 39[0m
[32m-> true[0m
[0m [0m
[90mline 786 <<: [0m
[0mPROGRESS::100[0m
[0mLoaded file 'tests.lambda' lines=787 time=2434.1 ms[0m

[0mLambda Calculus Interpreter - Interactive Mode[0m
[0mType ':help' for a list of commands or ':exit' to quit[0m

[36mlambda> [0m [35mEval: @'[0m
[34mTime: 0.1 ms, iterations: 1[0m
[32m-> @'[0m
[0m [0m

[36mlambda> [0m [0mInfix operator '$' defined with precedence 1 and right associativity[0m
[0m [0m

[36mlambda> [0m [32m-> $ = 1[0m
[0m [0m

[36mlambda> [0m [34mMacro 'm' defined successfully[0m
[0m [0m

[36mlambda> [0m [35mEval: alphaEq (succ (pred 5)) (succ (pred 5))[0m
[34mTime: 1.4 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m

[36mlambda> [0m [35mEval: alphaEq (succ (pred (succ 4))) (succ (pred (succ 4)))[0m
[34mTime: 1.5 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m

[36mlambda> [0m [34mMacro  0 m in   m 4[0m
[34mMacro  0   out  succ 4[0m
[34mMacro  0 m done succ 4[0m
[34mMacro  0 m in   m 4[0m
[34mMacro  0   out  succ 4[0m
[34mMacro  0 m done succ 4[0m
[35mEval: alphaEq (succ 4) 5[0m
[34mTime: 1.2 ms, iterations: 1[0m
[32m-> true[0m
[0m [0m

[36mlambda> [0m [0mbye[0m
[0m [0m
